## Task Analysis
- Main objective: Overhaul the Game Screen interface to improve readability by replacing the segmented card layout with a streamlined header for Sets and Games, and redesigning scoring interaction to allow adding points by tapping the score display directly with dedicated minus buttons for removal.
- Identified dependencies: Task 7 (Game Screen Layout Construction - establishes the initial layout pattern), Task 8 (Game Screen Interaction & Binding - provides scoring action handlers), Task 15 (Update Game Screen for Set Point Display - adds sets won display), existing design tokens in `GAME_TOKENS`, current view-model structure in `page/score-view-model.js`, i18n labels in `page/i18n/en-US.po`.
- System impact: High in `page/game.js` (major layout refactor of `renderGameScreen()`), low in `page/i18n/en-US.po` (new translation keys), low-medium in `page/index.js` and `page/setup.js` (spacing adjustments for consistency across screens); no scoring logic or persistence contract changes required.

## Chosen Approach
- Proposed solution: Refactor the Game Screen layout into three distinct zones: (1) a compact 2-row header displaying SETS and GAMES with accent-colored values, (2) a central score area where the large point numbers serve as tappable buttons for adding points, and (3) a bottom zone with centered minus buttons for team-specific point removal and a back-to-home button. Apply significantly larger font sizes using existing design token patterns.
- Justification for simplicity: Three approaches were evaluated: (A) keep existing segmented card layout and only increase font sizes (rejected - does not address interaction model improvement), (B) redesign layout with direct score tapping and dedicated minus buttons (chosen - provides best UX with minimal widget count), (C) implement floating overlay controls for score adjustment (rejected - overengineered for watch screen constraints). Option B delivers the clearest visual hierarchy and largest touch targets while maintaining code simplicity.
- Components to be modified/created: `page/game.js` (major refactor of `renderGameScreen()` layout and widget composition), `page/i18n/en-US.po` (add `game.setsLabel` for "SETS", update `game.gamesLabel` to "GAMES"), `page/index.js` (minor spacing adjustments for visual consistency), `page/setup.js` (minor spacing adjustments for visual consistency).

## Implementation Steps
1. Perform pre-implementation assumptions check: review current `renderGameScreen()` structure, confirm existing interaction handlers (`handleAddPointForTeam`, `handleRemovePoint`, `handleRemovePointForTeam`), verify round-screen safe inset helpers (`calculateRoundSafeSectionSideInset`), and lock non-goals (no scoring algorithm changes, no persistence schema changes).
2. Define new layout zones with proportional scaling: header section (~11% height with 2 rows for SETS/GAMES), score area (fills remaining space between header and bottom controls), and bottom zone (~15% height for minus buttons and back-home button). Document target percentages in `GAME_TOKENS.spacingScale`.
3. Update i18n resources: add `game.setsLabel` key with value "SETS", ensure `game.gamesLabel` is capitalized as "GAMES" for visual consistency across all screens.
4. Refactor header section: replace the previous segmented card layout with a compact 2-row display where each row contains a right-aligned muted label (SETS/GAMES) followed by a left-aligned accent value showing "X – Y" format. Use existing token colors (`mutedText` for labels, `accent` for values).
5. Redesign central score area: convert score display from TEXT widgets to BUTTON widgets so the large point numbers (0, 15, 30, etc.) are directly tappable. Increase font scale from previous implementation to `0.28` of screen width (clamped to 72-140px range). Wire `click_func` to existing `handleAddPointForTeam()` handler.
6. Implement team-specific minus buttons: add dedicated "−" buttons centered below each team's score display. Use secondary button styling (`buttonSecondary` color, `dangerText` for minus symbol). Wire Team A minus button to `handleRemovePointForTeam('teamA')` and Team B to `handleRemovePointForTeam('teamB')`.
7. Add vertical divider line: render a thin (1px) divider between Team A and Team B score areas spanning from near top of score area to bottom of minus buttons for clear visual separation.
8. Refactor finished-state layout: when match is finished, replace the active scoring UI with a centered winner message display. Use smaller font size for "Game Finished" label and larger accent-colored text for the winner announcement.
9. Apply responsive adaptations: ensure round-screen safe insets are applied to header and bottom button areas; verify score button hit areas do not overlap with divider or edge elements on 390x390, 454x454, and 390x450 screen sizes.
10. Adjust spacing on related screens: apply consistent spacing token updates to `page/index.js` and `page/setup.js` to maintain visual hierarchy consistency across the app (home screen button positioning, setup screen card spacing).
11. Run visual QA: test on both round and square simulators to verify: (a) header clearly separates SETS and GAMES, (b) score buttons are large enough for easy tapping, (c) minus buttons are accessible without accidental taps, (d) no visual overlap or cutoff on any target screen.
12. Run functional verification: tap each score button to confirm points increment correctly; tap each minus button to confirm team-specific point removal works; resume an existing match to verify UI populates correctly from persisted state.
13. Execute QA gate: run `npm run test` to ensure no regressions in existing test suite.

## Validation
- Success criteria: Game Screen header displays "SETS X – Y" and "GAMES X – Y" in clear, readable format; score numbers are directly tappable and increment points on tap; minus buttons correctly remove points for their respective teams; all elements remain fully visible on round (454x454) and square (390x450, 390x390) screens with no overlap; font sizes are visibly larger than previous implementation; existing match state correctly populates the new UI; full test suite passes.
- Checkpoints: Pre-implementation assumptions check (step 1) confirms existing handlers and non-goals; During-implementation checkpoint A (steps 4-5) confirms header layout and tappable score buttons function correctly; checkpoint B (steps 6-8) confirms minus button wiring, divider placement, and finished-state display; checkpoint C (steps 9-10) confirms responsive layout and cross-screen consistency; Post-implementation verification (steps 11-13) confirms visual QA acceptance, functional testing, and regression test suite passes.
