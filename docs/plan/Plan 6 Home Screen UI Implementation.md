## Task Analysis
- Main objective: Deliver Taskmaster Task 6 by turning `page/index` into the Home Screen that matches the Game Start reference and enforces correct Start/Resume behavior against persisted match state.
- Identified dependencies: Task 1 app configuration and storage permission (`app.json`), Task 3 persistence contract (`utils/storage.js` with `loadState`), current app state orchestration in `app.js`, and Task 5 page-level scoring hooks currently living in `page/index.js` that must be preserved when Home replaces that file.
- System impact: Medium cross-layer change in Device App module only (API level remains `minVersion: 1.0.0`): update routing/page ownership (`page/index` for Home, `page/game` as game destination), reuse persistence layer, add Home UI widget tree and event handlers, and verify round/square layout behavior without changing Side Service/Settings App.

## Chosen Approach
- Proposed solution: Use a route-split Home-first architecture: repurpose `page/index.js` as Home UI/controller, create/ensure `page/game` exists for navigation target, and keep Start/Resume logic thin by calling storage helpers plus app global state updates from one place.
- Justification for simplicity: Evaluated three approaches and selected the smallest safe one: (A) keep everything in `page/index` with mode toggles (rejected: mixes Home/Game responsibilities), (B) create a new Home page path and keep index as game (rejected: larger `app.json`/navigation churn for no product value), (C) keep `page/index` as Home and route to `page/game` (chosen: aligns with Task 6/7 contracts, minimizes conditional complexity, and keeps future Game work isolated).
- Components to be modified/created: `page/index.js` (Home UI + handlers), `app.json` (ensure `page/game` route configured for both targets), `page/game.js` (minimal scaffold or migrated existing game-page controller to avoid regression), `utils/storage.js` (add `clearState` helper if absent), `page/i18n/en-US.po` (Home labels), and `tests/home-screen.test.js` plus storage test extension for clear behavior.

## Implementation Steps
1. Run a pre-implementation assumptions check against `.taskmaster/tasks/tasks.json` and current code: confirm Task 6 acceptance criteria, verify `loadState` contract from `utils/storage.js`, and capture that `page/index.js` currently contains game-related handlers that must be intentionally migrated or deprecated.
2. Prepare routing safely: update `app.json` page arrays for both `gtr-3` and `gts-3` so `page/game` is a valid destination; if `page/game.js` does not exist, add a minimal `Page({ build() {} })` scaffold to prevent runtime navigation failure.
3. Protect prior behavior before Home rewrite: move reusable game controller methods currently in `page/index.js` into `page/game.js` (or isolate them in helpers) so Task 5 undo integration is preserved while index becomes Home.
4. Implement subtask 6.1 in `page/index.js`: define Home design tokens (colors, typography sizes, spacing constants) from `docs/images/game-start.png` / Lovable reference, then create centered title/logo widgets and baseline container metrics using responsive units compatible with both target design widths.
5. Add Home state initialization: in `onInit`/`onShow`, call `loadState()` once per refresh cycle, cache `savedMatchState`, derive `hasSavedGame`, and trigger Home re-render logic that decides whether Resume is shown.
6. Implement subtask 6.2 UI and logic: create the `Start New Game` button in the primary slot from the design reference, then wire handler flow as `clearState` -> reset in-memory app state/history (`globalData.matchState`, `globalData.matchHistory`) -> navigate to `page/game`.
7. Add/extend persistence helper for clear operation (if missing): implement `clearState()` in `utils/storage.js` using `removeItem`/safe fallback semantics and unit-test it so Start behavior is explicit and does not rely on side effects.
8. Implement subtask 6.3 UI and logic: render `Resume Game` button only when `hasSavedGame` is true, and on tap set app runtime state from the loaded snapshot then navigate to `page/game` without invoking `clearState`.
9. Add resilience guards for edge cases discovered in deepthink: treat corrupted/missing persisted payload as no saved game (`loadState` already returns `null`), prevent duplicate button creation on repeated `build()` calls, and ensure Resume never appears for invalid data.
10. Add focused tests and smoke checks: create `tests/home-screen.test.js` with mocked `Page`, `hmApp.gotoPage`, and storage helpers to validate button-visibility and Start/Resume side effects; extend `tests/storage.test.js` for `clearState`; then run full QA gate `npm run test`.
11. Execute visual verification on both simulator form factors: compare Home title/logo/button placement with `docs/images/game-start.png`, validate no overlap/cutoff on round and square targets, and confirm tap flows (`Start` clears + navigates, `Resume` navigates only).
12. Risk mitigation and rollback note (elevated risk in step 3 migration): if moving existing index game logic causes regressions, rollback only the migration chunk and keep a temporary minimal `page/game` scaffold with stable navigation while preserving completed Home behavior and tests.

## Validation
- Success criteria: Home UI in `page/index` visually matches Game Start reference for title/logo/button hierarchy; with empty storage only Start is rendered; with valid saved state Start and Resume are rendered; Start clears persisted state and resets runtime before navigation; Resume navigates using saved state without clearing; all tests pass via `npm run test`; route works for both configured targets.
- Checkpoints: Pre-implementation checkpoint (step 1) confirms assumptions and migration scope; implementation checkpoint A (steps 2-4) confirms routing/page split and static Home layout parity; checkpoint B (steps 5-8) confirms behavioral correctness for Start vs Resume flows; checkpoint C (steps 9-10) confirms edge-case handling and automated regression coverage; post-implementation checkpoint (step 11) confirms simulator visual/interaction parity on round and square screens, with rollback path from step 12 if migration instability appears.
