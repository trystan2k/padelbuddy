{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Project Initialization & Configuration",
        "description": "Set up the Zepp OS project structure, configuration files, and base directories.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Initialize a new Zepp OS Mini Program project. Configure `app.json` with the project ID, version, and necessary permissions (e.g., storage). Set up the folder structure (pages, utils, assets). Ensure the project is configured to support both round and square screen resolutions by defining viewport settings or using responsive units (px/rpx).",
        "testStrategy": "Verify the project compiles successfully using the Zepp developer tools. Confirm that the app launches on the simulator (round and square) without crashing and displays a blank page or default index.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Zepp OS Project and Directory Structure",
            "description": "Create the base project using the CLI and establish the folder scaffolding.",
            "dependencies": [],
            "details": "Execute the Zepp OS project initialization command to generate the boilerplate. Manually create the required directory structure including folders for 'pages', 'utils', and 'assets' to organize the codebase.",
            "status": "done",
            "testStrategy": "Verify that the project command executes without errors and all required folders exist in the file system.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.785Z"
          },
          {
            "id": 2,
            "title": "Configure Core App Metadata in app.json",
            "description": "Set the project identification and version information in the configuration file.",
            "dependencies": [
              1
            ],
            "details": "Edit the root `app.json` file to input the correct `appId`, `versionName`, `versionCode`, and `appName`. Ensure the JSON syntax is valid to prevent build errors.",
            "status": "done",
            "testStrategy": "Validate the JSON structure using a linter or the Zepp developer tools to ensure no syntax errors exist.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.791Z"
          },
          {
            "id": 3,
            "title": "Define Storage Permissions in app.json",
            "description": "Configure necessary permissions for local data access.",
            "dependencies": [
              2
            ],
            "details": "Add the appropriate permission keys to `app.json` to enable access to `storage` APIs. This is required for the subsequent implementation of local state persistence.",
            "status": "done",
            "testStrategy": "Review the configuration file to confirm permission keys are present and formatted according to Zepp OS documentation.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.794Z"
          },
          {
            "id": 4,
            "title": "Set Viewport Configuration for Round Screens",
            "description": "Configure the project settings to support circular screen resolutions.",
            "dependencies": [
              2
            ],
            "details": "Update the `app.json` or global configuration files to define the `designWidth` and viewport settings specifically tailored for round screen devices (e.g., 454px). Configure the design system to handle circular clipping zones.",
            "status": "done",
            "testStrategy": "Deploy the project to a round screen simulator and verify that the default page renders within the circular bounds without overflow.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.795Z"
          },
          {
            "id": 5,
            "title": "Set Viewport Configuration for Square Screens and Responsive Units",
            "description": "Ensure compatibility with square screens and implement responsive units.",
            "dependencies": [
              4
            ],
            "details": "Adjust configuration to support square screen resolutions. Enforce the use of responsive units (px/rpx) in the global settings or style guide to ensure layouts scale correctly across both round and square form factors.",
            "status": "done",
            "testStrategy": "Deploy to a square screen simulator. Verify elements are positioned correctly and that the layout adapts without distortion compared to the round screen view.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.797Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break this task down into subtasks covering: 1) Project creation and folder scaffolding, 2) Configuration of app.json (permissions, project ID), and 3) Viewport setup for round and square screens.",
        "updatedAt": "2026-02-20T07:17:14.797Z"
      },
      {
        "id": "2",
        "title": "Data Model & State Management Design",
        "description": "Define the data structures for the game state, scoring history, and team configurations.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create JavaScript/TypeScript interfaces for `MatchState` including: Team A/B scores (points, games), current set status, and match status (active/finished). Implement a history stack structure to store past states for the Undo functionality (as per 'Option 2' state machine approach). Define constants for scoring sequences (0, 15, 30, 40, Ad, Game).",
        "testStrategy": "Unit tests to verify that the state object initializes correctly with zero values and that the history stack can push and pop deep copies of the state without reference errors.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interfaces for Game Entities",
            "description": "Create TypeScript interfaces for MatchState, Team configurations, and status enumerations to type-check the game data.",
            "dependencies": [],
            "details": "Define `MatchState` interface including properties for Team A/B scores (points, games), current set status, and match status (active/finished). Create supporting types for TeamScore if necessary.",
            "status": "done",
            "testStrategy": "Unit tests to verify interfaces compile correctly and accept valid data shapes for match initialization.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:11.492Z"
          },
          {
            "id": 2,
            "title": "Implement History Stack with Deep Copy Logic",
            "description": "Develop the history stack data structure required for the Undo functionality, ensuring immutability via deep copying.",
            "dependencies": [
              1
            ],
            "details": "Implement a stack class or module with `push(state)` and `pop()` methods. Integrate deep copy logic (e.g., using JSON.parse(JSON.stringify()) or a utility library) to ensure stored states are independent snapshots.",
            "status": "done",
            "testStrategy": "Unit tests to verify that pushing a state and modifying the original does not affect the stored history, and that pop correctly restores previous states.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:13.045Z"
          },
          {
            "id": 3,
            "title": "Define Scoring Constants and Enumerations",
            "description": "Establish the standard scoring sequences and domain constants used throughout the scoring logic.",
            "dependencies": [],
            "details": "Define constants for the scoring sequence (0, 15, 30, 40, Ad, Game). Create enumerations for game phases or specific states to ensure type safety in the scoring engine.",
            "status": "done",
            "testStrategy": "Validation to ensure constant values match standard Padel/Tennis scoring rules and are accessible for import by other modules.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:14.673Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Defining TypeScript interfaces for MatchState and related entities, 2) Implementing the history stack structure with deep copy logic, and 3) Defining scoring constants and enumerations.",
        "updatedAt": "2026-02-20T13:23:14.673Z"
      },
      {
        "id": "3",
        "title": "Local Storage & Persistence Layer",
        "description": "Implement the mechanism to save and load the game state using the device's local storage.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Utilize Zepp OS `settingsStorage` API to persist the `MatchState` object as a JSON string. Implement `saveState(state)` and `loadState()` functions. Ensure data is serialized correctly and handle potential JSON parsing errors. The load function should return `null` if no saved game exists.",
        "testStrategy": "Manually save a state, restart the app/simulator, and verify the data is retrieved accurately. Test with invalid/corrupted storage data to ensure the app handles it gracefully (e.g., defaults to new game).",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement saveState function with JSON serialization",
            "description": "Create the saveState function to serialize the MatchState object into a JSON string and persist it using the Zepp OS settingsStorage API.",
            "dependencies": [],
            "details": "Implement the `saveState(state)` function. This function takes a `MatchState` object as input, serializes it using `JSON.stringify()`, and saves the resulting string to a specific key in the Zepp OS `settingsStorage`.",
            "status": "done",
            "testStrategy": "Test by calling the function with a valid MatchState object and verifying the data is written to storage. Ensure valid JSON stringification.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.978Z"
          },
          {
            "id": 2,
            "title": "Implement loadState function with error handling",
            "description": "Create the loadState function to retrieve and parse the game state, including robust error handling for missing or corrupted data.",
            "dependencies": [],
            "details": "Implement the `loadState()` function. Retrieve the raw string from `settingsStorage` using the defined key. Parse the string using `JSON.parse()` inside a try-catch block. Handle potential errors by returning `null` if data is missing or if parsing fails.",
            "status": "done",
            "testStrategy": "Test scenarios: empty storage (expect null), valid storage (expect state object), and corrupted JSON string (expect null without crashing).",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.982Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Implementing the saveState function with JSON serialization, and 2) Implementing the loadState function with error handling and null checks.",
        "updatedAt": "2026-02-20T14:42:51.982Z"
      },
      {
        "id": "4",
        "title": "Padel Scoring Logic Engine",
        "description": "Develop the core state machine logic for handling points, games, sets, and tie-breaks.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Implement the `addPoint(team)` function. Logic must handle: standard progression (0->15->30->40->Game), Deuce/Advantage rules (40-40 -> Ad -> Game or Deuce), and Game/Set increments. Implement Set logic: win at 6 games (margin of 2) or Tie-break at 6-6 (first to 7, margin of 2). Every state change must be pushed to the history stack before updating the current state to support Undo.",
        "testStrategy": "Write test cases for standard scoring, deuce scenarios (winning/losing from advantage), set wins (6-0, 6-4), and tie-break entry (6-6). Validate that the history stack grows with every point.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement standard point progression logic",
            "description": "Create the basic logic to handle point increments from 0 to 15, 30, 40, and Game for a winning team.",
            "dependencies": [],
            "details": "Define the mapping of internal point counters (0, 1, 2, 3) to display strings ('0', '15', '30', '40'). In the `addPoint(team)` function, increment the team's point counter. If the team reaches 4 points and the opponent has 3 or fewer points, award the Game.",
            "status": "done",
            "testStrategy": "Verify that calling `addPoint` updates the score from '0' to '15', '30', '40', and finally results in a Game win when the opponent is below 40.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.081Z"
          },
          {
            "id": 2,
            "title": "Implement deuce and advantage state handling",
            "description": "Develop logic to manage the 40-40 (Deuce) state and the subsequent Advantage transitions.",
            "dependencies": [
              1
            ],
            "details": "Modify `addPoint` to detect when both teams reach 3 points (40-40). If scores are equal (3-3) or higher and equal, the next point puts the scorer at 'Advantage'. If a team is at 'Advantage' and scores, they win the Game. If they lose the point, revert to 'Deuce'.",
            "status": "done",
            "testStrategy": "Test scenarios reaching 40-40, winning a point to get Advantage, and then both winning and losing the subsequent point to ensure correct Game or Deuce results.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.083Z"
          },
          {
            "id": 3,
            "title": "Implement game counting and set win conditions",
            "description": "Handle game score increments within a set and determine when a set is won based on game margins.",
            "dependencies": [
              2
            ],
            "details": "When a Game is won (from Task 1 or 2), increment the game counter for the winning team and reset points. Check set win conditions: A team wins the set if they reach 6 games and lead by at least 2 games (e.g., 6-4, 6-3, 6-0). Handle the transition to a new set or match end.",
            "status": "done",
            "testStrategy": "Test game progression to 6-0, 6-4. Verify that a score of 6-5 does not end the set. Confirm that reaching 7-5 (if allowed by logic flow) ends the set.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.085Z"
          },
          {
            "id": 4,
            "title": "Implement tie-break logic",
            "description": "Develop the specific scoring rules for a tie-break game triggered at a 6-6 game score.",
            "dependencies": [
              3
            ],
            "details": "Detect when the set score reaches 6-6. Switch to tie-break mode where points are counted as 1, 2, 3, etc., instead of 15/30/40. The first team to reach 7 points wins the tie-break and the set, provided they have a margin of at least 2 points (e.g., 7-5, 8-6). Reset points/games correctly upon completion.",
            "status": "done",
            "testStrategy": "Simulate a 6-6 set score. Verify tie-break points increment numerically. Test winning scenarios at 7-0, 7-5, and 8-6. Ensure the set concludes correctly upon winning the tie-break.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.086Z"
          },
          {
            "id": 5,
            "title": "Integrate history stack for state changes",
            "description": "Implement the mechanism to push deep copies of the state to the history stack before any score update.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "At the beginning of the `addPoint(team)` function, create a deep copy of the current match state object. Push this copy onto the `historyStack` array. This ensures that every modification to points, games, sets, or tie-break status is captured to support the Undo functionality.",
            "status": "done",
            "testStrategy": "Verify that the history stack length increases by exactly 1 for every point added. Check that popping the history restores the exact previous state without reference issues.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.087Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Standard point progression logic (0-15-30-40-Game), 2) Deuce and Advantage state handling, 3) Game counting and set win conditions, 4) Tie-break logic implementation, and 5) Integration of history stack pushing on every state change.",
        "updatedAt": "2026-02-20T15:35:54.087Z"
      },
      {
        "id": "5",
        "title": "Undo & Remove Point Logic",
        "description": "Implement the logic to reverse the last score action using the history stack.",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "details": "Implement `removePoint()` function. This function should pop the previous state from the history stack and set it as the current state. If the history is empty or score is at start (0-0, 0-0), the function should be a no-op. Ensure this effectively restores game points, set scores, and tie-break statuses.",
        "testStrategy": "Verify that pressing Undo after scoring reverts the score exactly to the previous state. Test rapid Undo presses until the score reaches 0-0 and ensure no errors occur or negative scores appear.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement removePoint() core logic in scoring engine",
            "description": "Implement the removePoint() function in the scoring engine to handle state restoration from the history stack.",
            "dependencies": [],
            "details": "Create or update utils/scoring-engine.js to include removePoint(). The function must: 1) Check if history is empty or state is initial (0-0, 0-0) -> return no-op, 2) Pop previous state from utils/history-stack.js, 3) Restore the popped state as current match state, 4) Ensure all fields (points, games, sets, tie-break status) are restored. Import historyStack and popState from utils/history-stack.js.",
            "status": "done",
            "testStrategy": "Write unit tests for single undo, multiple rapid undos, edge cases (empty history), and state integrity validation.",
            "metadata": {
              "files": [
                "utils/scoring-engine.js"
              ],
              "complexity": 2,
              "testCommand": "npm test -- scoring-engine.test.js"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:25:59.786Z"
          },
          {
            "id": 2,
            "title": "Create comprehensive unit tests for removePoint functionality",
            "description": "Write unit tests to verify the removePoint() function handles all scoring scenarios correctly.",
            "dependencies": [
              1
            ],
            "details": "Add test cases to tests/scoring-engine.test.js or create tests/remove-point.test.js. Cover: 1) Single undo after a point, 2) Multiple undos until initial state (0-0, 0-0), 3) Verify no-op when history is empty, 4) Verify no-op when already at initial state, 5) Ensure undo never produces negative scores or invalid transitions. Use createHistoryStack from utils/history-stack.js to mock history state.",
            "status": "done",
            "testStrategy": "Execute the test runner to ensure all test cases pass, including edge cases and rapid undo sequences.",
            "metadata": {
              "files": [
                "tests/scoring-engine.test.js",
                "tests/remove-point.test.js"
              ],
              "complexity": 2,
              "testCommand": "npm test"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:01.549Z"
          },
          {
            "id": 3,
            "title": "Integrate Undo action in app and UI layer",
            "description": "Wire up the removePoint() function to the UI layer and expose it as an action.",
            "dependencies": [
              1
            ],
            "details": "Update app.js and page/index.js. Expose a public removePoint action that calls the scoring engine function. If an Undo button exists in page/index.js UI, bind the handler to this action. Add an integration test or runtime check to verify the app's global state updates correctly after Undo is triggered, reflecting the restored state in the UI.",
            "status": "done",
            "testStrategy": "Manual test on Zepp OS simulator: click a point, then click Undo, verify UI reverts. Automated integration test to check global state restoration.",
            "metadata": {
              "files": [
                "app.js",
                "page/index.js"
              ],
              "complexity": 1,
              "testCommand": "npm run test:integration"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:03.053Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Create a subtask to implement the removePoint function, focusing on popping from history, validation checks (empty stack), and state restoration.",
        "updatedAt": "2026-02-20T16:26:03.053Z"
      },
      {
        "id": "6",
        "title": "Home Screen UI Implementation",
        "description": "Build the Home Screen with Start and Resume functionality based on the design reference.",
        "status": "done",
        "dependencies": [
          "1",
          "3"
        ],
        "priority": "medium",
        "details": "Create `page/index` using Zepp UI components. Implement the App Title/Logo. Add 'Start New Game' and 'Resume Game' buttons. Use the `loadState` result to conditionally render the 'Resume Game' button (only if a saved game exists). Apply design tokens (colors, fonts) from the Lovable reference.",
        "testStrategy": "UI Test: Verify button placement and text match the 'Game Start' design. Functional Test: With no data, only 'Start' is shown. With data, both are shown. Clicking 'Start' clears storage and navigates. Clicking 'Resume' navigates without clearing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Home Page Structure and App Title/Logo",
            "description": "Initialize the `page/index` file and implement the static visual elements including the App Title and Logo using Zepp UI components.",
            "dependencies": [],
            "details": "Create the `page/index` file structure. Implement the App Title and Logo widgets. Apply the design tokens (colors, fonts) from the Lovable reference to ensure visual consistency with the design spec.",
            "status": "done",
            "testStrategy": "Visual inspection to ensure the App Title and Logo match the 'Game Start' design reference and the layout is correctly centered.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:49:04.579Z"
          },
          {
            "id": 2,
            "title": "Implement Start New Game Button and Logic",
            "description": "Add the 'Start New Game' button to the interface and configure the logic to clear storage and navigate to the game screen.",
            "dependencies": [
              1
            ],
            "details": "Add the 'Start New Game' button component to the layout. Implement the click event handler to clear any saved game state and navigate the user to the game page (`page/game`).",
            "status": "done",
            "testStrategy": "Functional test to verify clicking 'Start New Game' clears any existing storage and navigates correctly to the game screen.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:52:38.735Z"
          },
          {
            "id": 3,
            "title": "Implement Conditional Resume Game Button and Data Fetching",
            "description": "Integrate data fetching to check for saved games and conditionally render the 'Resume Game' button based on the result.",
            "dependencies": [
              2
            ],
            "details": "Use the `loadState` function to check for a saved game state. Conditionally render the 'Resume Game' button only if data exists. Implement the click handler to navigate using the loaded state without clearing it.",
            "status": "done",
            "testStrategy": "Functional test verifying the button only appears when saved data exists, and clicking it loads the specific state and navigates correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T17:12:16.550Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Creating the basic page structure and adding App Title/Logo, 2) Implementing the 'Start New Game' button and logic, and 3) Implementing the conditional 'Resume Game' button and data fetching.",
        "updatedAt": "2026-02-20T17:12:16.550Z"
      },
      {
        "id": "7",
        "title": "Game Screen Layout Construction",
        "description": "Create the layout for the Game Screen displaying scores and control buttons.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Create `page/game`. Layout the top section for Set Scores (Games won) and the middle section for Current Game Points (0, 15, 30...). Ensure high contrast and large typography for readability. Place Team A and Team B action buttons (Add/Remove) at the bottom. Ensure layout adapts to Round vs Square screens using relative positioning or flexbox.",
        "testStrategy": "Visual inspection on Round and Square simulators to ensure elements do not overlap or get cut off. Verify text size is readable as per accessibility requirements.",
        "subtasks": [
          {
            "id": 1,
            "title": "Layout Set Score Section",
            "description": "Create the top section UI to display Set Scores (games won) for both teams.",
            "dependencies": [],
            "details": "Construct the top container in `page/game` to show Team A and Team B Set Scores. Use flexbox or relative positioning for alignment and apply high contrast colors for readability.",
            "status": "done",
            "testStrategy": "Inspect layout on simulator to ensure scores are positioned at the top and legible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.009Z"
          },
          {
            "id": 2,
            "title": "Layout Current Game Point Section",
            "description": "Create the middle section UI displaying current game points (0, 15, 30, etc.) with large, readable typography.",
            "dependencies": [
              1
            ],
            "details": "Implement the middle container in `page/game` for Current Game Points. Define large typography styles for visibility. Ensure high contrast text is used for the point values.",
            "status": "done",
            "testStrategy": "Verify text size is sufficient for readability and contrast meets accessibility standards.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.011Z"
          },
          {
            "id": 3,
            "title": "Layout Control Buttons and Responsive Adaptation",
            "description": "Create bottom control buttons for scoring and ensure the full layout is responsive for Round and Square screens.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add Team A and Team B action buttons (Add/Remove) at the bottom of `page/game`. Apply responsive layout logic (flexbox/relative) to ensure elements fit correctly on both Round and Square screen shapes without overlap.",
            "status": "done",
            "testStrategy": "Visual inspection on Round and Square simulators. Ensure no elements are cut off and buttons are accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.012Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split into: 1) Layout of the Set Score section (top), 2) Layout of the Current Game Point section (middle) with large typography, and 3) Layout of control buttons (bottom) and responsive adaptation for Round/Square screens.",
        "updatedAt": "2026-02-20T18:09:24.012Z"
      },
      {
        "id": "8",
        "title": "Game Screen Interaction & Binding",
        "description": "Connect the UI buttons to the Scoring Logic and update the view dynamically.",
        "status": "done",
        "dependencies": [
          "4",
          "5",
          "7"
        ],
        "priority": "high",
        "details": "Bind the 'Add Point' (+) and 'Remove Point' (-) buttons for both teams to the logic engine. On click: 1. Execute logic, 2. Update the UI state (re-render or update text widgets), 3. Trigger `saveState`. Ensure the UI updates within 100ms of the tap.",
        "testStrategy": "Integration test: Tap buttons and observe UI changes immediately. Verify that adding a point updates the Game Point score, and winning a game updates the Set Score. Verify persistence by closing and reopening the app.",
        "subtasks": [
          {
            "id": 1,
            "title": "Bind Game Controls to Scoring Logic",
            "description": "Attach click event listeners to the UI buttons (+/-) and invoke the scoring logic to update the game state.",
            "dependencies": [],
            "details": "Implement event handlers for Team A and Team B 'Add Point' and 'Remove Point' buttons defined in Task 7. On click, invoke the scoring engine functions (from Task 4/5) to calculate the new score. Update the specific UI widgets (Text/Score views) immediately after logic execution to reflect the new state.",
            "status": "done",
            "testStrategy": "Unit/Manual test: Click buttons and verify the displayed score changes correctly according to tennis rules. Check that removing points works correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:04.475Z"
          },
          {
            "id": 2,
            "title": "Implement Auto-Save and Performance Verification",
            "description": "Integrate state persistence into the click handlers and ensure UI rendering meets latency requirements.",
            "dependencies": [
              1
            ],
            "details": "Call `saveState` (from Task 3) within the button click handlers immediately after logic execution and UI update. Implement or verify logic to measure rendering latency from tap to screen update. Optimize the update loop if necessary to guarantee the UI updates within the 100ms requirement.",
            "status": "done",
            "testStrategy": "Performance test: Use console logging or profiling tools to ensure time delta between event trigger and UI paint is < 100ms. Persistence test: Close and reopen app to verify the last state is saved correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:05.999Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Expand into: 1) Binding Add/Remove buttons to the logic engine and triggering state updates, and 2) Implementing auto-save on state change and verifying UI update latency.",
        "updatedAt": "2026-02-20T18:47:05.999Z"
      },
      {
        "id": "9",
        "title": "Navigation & Lifecycle Handling",
        "description": "Manage navigation between screens and handle app backgrounding/foregrounding events.",
        "status": "done",
        "dependencies": [
          "6",
          "8"
        ],
        "priority": "medium",
        "details": "Implement the 'Back/Home' button logic in the Game Screen to return to the Home Screen. Add event listeners for lifecycle events (e.g., `app.on('pause')` or page hide events) to trigger `saveState` automatically, ensuring no data is lost if the user receives a call or locks the screen.",
        "testStrategy": "Navigate from Game to Home and verify save is triggered. Background the app while in a game state (simulate via tools or OS gesture) and foreground it to verify the state persists exactly as left.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Game Screen Back/Home Navigation",
            "description": "Configure the Back/Home button on the Game Screen to navigate to the Home Screen and trigger state saving.",
            "dependencies": [],
            "details": "Modify `pages/game` to handle navigation events. Implement a click handler for the Back/Home widget that first invokes `saveState()` to persist the current game score, then executes a navigation command (e.g., `router.replace` or `router.push`) to route the user back to `pages/index` (Home Screen). Ensure the transition is smooth.",
            "status": "done",
            "testStrategy": "Functional Test: Start a game session and modify the score. Tap the Back/Home button. Verify the app transitions to the Home Screen. Then, tap 'Resume Game' and verify the game state (scores) matches exactly what it was before navigation.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:27.026Z"
          },
          {
            "id": 2,
            "title": "Add Lifecycle Event Listeners for Auto-Save",
            "description": "Implement event listeners for app pause and visibility changes to automatically save the game state, preventing data loss during interruptions.",
            "dependencies": [],
            "details": "Integrate Zepp OS lifecycle event handling (e.g., `app.on('pause')` or page visibility events) within the app lifecycle or Game Screen controller. When a 'pause' or 'hide' event is detected (simulating a phone call or screen lock), automatically trigger the `saveState()` function. Ensure this happens synchronously or reliably before the app fully suspends to guarantee data integrity.",
            "status": "done",
            "testStrategy": "Lifecycle Test: Start a game and change the score. Simulate an interruption by backgrounding the app (using OS gesture or simulator tool) or triggering a 'pause' event. Foreground the app and verify the game resumes with the exact score. Verify storage to confirm data was written at the moment of pause.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:28.703Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into: 1) Implementing navigation logic (Back/Home button) and 2) Adding lifecycle event listeners (pause/hide) for automatic state persistence.",
        "updatedAt": "2026-02-20T21:30:28.703Z"
      },
      {
        "id": "10",
        "title": "Styling Refinement, Input Debouncing & Polish",
        "description": "Apply final design styles, implement input debouncing, and optimize performance.",
        "status": "done",
        "dependencies": [
          "9"
        ],
        "priority": "low",
        "details": "Refine the UI to strictly match the Lovable design (Game Finish, Score colors, button styles). Implement a debounce mechanism (e.g., ignore input for 300ms after a valid tap) on scoring buttons to prevent double-tap errors. Ensure touch targets are large enough (min 48px) for sports usage.",
        "testStrategy": "Perform rapid tapping tests to ensure debounce prevents double scoring. Conduct a final design audit against the provided images. Measure UI update latency to ensure <100ms compliance.",
        "subtasks": [
          {
            "id": 1,
            "title": "Apply Final Design Styles and Accessibility",
            "description": "Refine the UI to strictly match the Lovable design specifications, including the Game Finish screen, score colors, and button styles. Ensure all interactive elements meet accessibility standards with a minimum touch target size of 48px suitable for sports usage.",
            "dependencies": [],
            "details": "Update styling tokens and component properties to align with the 'Game Finish' and gameplay designs. Verify contrast ratios and implement layout adjustments to guarantee touch targets are at least 48x48 pixels on all scoring and navigation controls.",
            "status": "done",
            "testStrategy": "Conduct a visual audit comparing the UI against the provided Lovable design screenshots. Measure touch targets to ensure they meet the 48px minimum requirement and verify color contrast compliance.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T07:37:53.181Z"
          },
          {
            "id": 2,
            "title": "Implement Input Debouncing Logic",
            "description": "Implement a debounce mechanism on scoring buttons to prevent double-tap errors and ensure score integrity during rapid interactions.",
            "dependencies": [],
            "details": "Modify the event handlers associated with scoring buttons (established in Task 8) to include a debounce timer. Set a 300ms window during which subsequent tap events are ignored after a valid score update to prevent accidental double scoring.",
            "status": "done",
            "testStrategy": "Perform rapid tapping tests on the scoring interface to confirm that the debounce mechanism effectively prevents multiple score increments from a single intended action. Verify UI update latency remains below 100ms.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T07:37:54.865Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Applying final design styles and ensuring accessibility (touch targets), and 2) Implementing input debouncing logic to prevent double-tap errors.",
        "updatedAt": "2026-02-21T07:37:54.865Z"
      },
      {
        "id": "11",
        "title": "Define Match State Data Model and Storage Schema",
        "description": "Create the data structure interface for the match session that satisfies the persistence and scoring requirements defined in the PRD.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Define a TypeScript/JavaScript interface or object structure representing `MatchState`. It must include fields: `status` ('active' | 'finished'), `setsToPlay` (1|3|5), `setsNeededToWin` (1|2|3), `setsWon` ({teamA, teamB}), `currentSet` ({number, games: {teamA, teamB}}), `currentGame` ({points: {teamA, teamB}}), `setHistory` (Array of {setNumber, teamAGames, teamBGames}), and `updatedAt`. Establish a constant storage key (e.g., 'ACTIVE_MATCH_SESSION').",
        "testStrategy": "Verify that the data structure can be instantiated with all required fields and successfully serialized to JSON without data loss.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interface for MatchState",
            "description": "Create comprehensive TypeScript type definitions for the match state data structure with proper typing for all nested fields.",
            "dependencies": [],
            "details": "Define TypeScript interfaces and types: MatchState with fields status ('active'|'finished'), setsToPlay (1|3|5), setsNeededToWin (1|2|3), setsWon ({teamA, teamB}), currentSet ({number, games: {teamA, teamB}}), currentGame ({points: {teamA, teamB}}), setHistory (Array of {setNumber, teamAGames, teamBGames}), updatedAt (timestamp), and schemaVersion (number). Export all types from a central types module.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds, no type errors when creating MatchState objects, and all union types correctly restrict invalid values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:18:59.901Z"
          },
          {
            "id": 2,
            "title": "Create Default State Factory and Constants",
            "description": "Implement factory function to generate initial MatchState objects and define storage-related constants.",
            "dependencies": [
              1
            ],
            "details": "Create constant STORAGE_KEY = 'ACTIVE_MATCH_SESSION'. Implement createDefaultMatchState() factory function that returns a properly initialized MatchState object: status='active', setsToPlay=3, setsNeededToWin=2, setsWon={teamA:0, teamB:0}, currentSet={number:1, games:{teamA:0, teamB:0}}, currentGame={points:{teamA:0, teamB:0}}, setHistory=[], updatedAt=current timestamp, schemaVersion=1.",
            "status": "done",
            "testStrategy": "Test factory returns object with all required fields initialized correctly, default values match requirements, and multiple calls create independent objects (no shared references).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:01:13.890Z"
          },
          {
            "id": 3,
            "title": "Implement Serialization and Runtime Validation",
            "description": "Create functions to serialize MatchState to JSON and deserialize with runtime type validation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement serializeMatchState(state: MatchState): string that converts state to JSON string. Implement deserializeMatchState(json: string): MatchState | null that parses JSON and validates all fields match expected types and ranges. Validation should check status values, setsToPlay in [1,3,5], setsNeededToWin in [1,2,3], numeric scores are non-negative integers. Return null if validation fails.",
            "status": "done",
            "testStrategy": "Test round-trip serialization/deserialization preserves all data. Test with malformed JSON, missing fields, invalid enum values, and negative scores to verify null returns and no crashes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:05:01.012Z"
          },
          {
            "id": 4,
            "title": "Build Storage Adapter with Abstracted API",
            "description": "Implement storage adapter with save, load, and clear functions using Zepp OS settingsStorage API.",
            "dependencies": [
              3
            ],
            "details": "Create StorageAdapter interface with save(key: string, value: string): Promise<void>, load(key: string): Promise<string | null>, clear(key: string): Promise<void>. Implement ZeppOsStorageAdapter using settingsStorage.setItem/getItem/removeItem. Create MatchStorage class that wraps the adapter with saveMatchState(state), loadMatchState(), clearMatchState() methods using STORAGE_KEY constant. Handle JSON parsing errors gracefully.",
            "status": "done",
            "testStrategy": "Test save then load retrieves identical state. Test load returns null when no data exists. Test clear removes data. Test error handling with corrupted storage data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:05.663Z"
          },
          {
            "id": 5,
            "title": "Implement Migration and Versioning Utilities",
            "description": "Create version-aware migration system to upgrade saved MatchState from older schema versions to current format.",
            "dependencies": [
              3,
              4
            ],
            "details": "Define CURRENT_SCHEMA_VERSION constant matching factory output. Create migration registry Map<number, (oldState: any) => MatchState> mapping from version to upgrade function. Implement migrateMatchState(rawData: any): MatchState that checks schemaVersion field, applies migrations sequentially from stored version to current version, or returns default state if version missing or invalid. Include migration from version 0 (no version field) to version 1.",
            "status": "done",
            "testStrategy": "Test migrating from version 0 (legacy format without version) creates valid current state. Test stored version 1 bypasses migration unchanged. Test invalid or missing version returns default state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:07.650Z"
          },
          {
            "id": 6,
            "title": "Write Unit Tests for Data Model Components",
            "description": "Create comprehensive unit tests covering instantiation, serialization, storage round-trip, and migration logic.",
            "dependencies": [
              5
            ],
            "details": "Write test suite covering: MatchState interface type checking, factory function creates valid defaults, serialization/deserialization preserves all fields including edge cases (max scores, finished status), storage adapter save/load/clear operations work correctly, migration handles legacy and current formats, and invalid data is rejected safely. Include tests for deep cloning correctness (no reference sharing in nested objects). Achieve >90% code coverage.",
            "status": "done",
            "testStrategy": "Run automated test suite. Verify all tests pass. Check code coverage report. Ensure no race conditions in async storage operations.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:09.521Z"
          },
          {
            "id": 7,
            "title": "Document Integration Notes and Task Dependencies",
            "description": "Create documentation explaining how to integrate the MatchState storage into the match lifecycle and identify dependencies.",
            "details": "Document saveMatchState() call points: after each point scored, after set completion, when match finishes, and on app pause/background. Document loadMatchState() call points: on app startup and after undo operations. Create dependency mapping: requires Task 3 (Local Storage layer) complete, provides data structure for Task 12 (Match Logic Engine). Include usage examples in JSDoc comments and a separate INTEGRATION.md file with diagrams showing state flow.",
            "status": "done",
            "testStrategy": "Review documentation for clarity and completeness. Verify dependency mappings are accurate against project task list. Peer review of integration examples.",
            "dependencies": [],
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:11.291Z"
          }
        ],
        "updatedAt": "2026-02-21T09:19:11.291Z"
      },
      {
        "id": "12",
        "title": "Implement Core Persistence Service (Save/Load)",
        "description": "Develop the utility functions to save the match state to local storage and load it back, including error handling for corrupted data.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "Implement `saveMatchState(state: MatchState)` and `loadMatchState(): MatchState | null`. Use Zepp OS `localStorage` or `settingsStorage` API to persist the JSON stringified state. `saveMatchState` should update `updatedAt` timestamp. `loadMatchState` must be wrapped in a try-catch block to handle parsing errors or missing data gracefully, returning null if data is invalid/missing (safe failure).",
        "testStrategy": "Unit test saving a state object, verifying it exists in storage. Unit test loading the object back. Test loading with corrupted JSON to ensure it returns null instead of crashing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define storage constants and initialize persistence module",
            "description": "Create the persistence service module with storage key constants and basic structure.",
            "dependencies": [],
            "details": "Create a new file for the persistence service. Define the storage key constant (e.g., 'ACTIVE_MATCH_SESSION'). Export the module structure and any necessary imports for Zepp OS storage API (localStorage or settingsStorage).",
            "status": "done",
            "testStrategy": "Verify module imports correctly and constants are exported without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:05.022Z"
          },
          {
            "id": 2,
            "title": "Implement saveMatchState function with timestamp",
            "description": "Create the saveMatchState function that updates timestamp and persists state to storage.",
            "dependencies": [
              1
            ],
            "details": "Implement saveMatchState(state: MatchState): void. Before saving, update state.updatedAt to current timestamp (Date.now()). Stringify the state using JSON.stringify(). Use Zepp OS localStorage.setItem() or settingsStorage.setItem() to persist the JSON string using the defined storage key constant.",
            "status": "done",
            "testStrategy": "Unit test saving a sample MatchState object. Verify storage contains the expected key and the stringified JSON includes the updated timestamp.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:08.348Z"
          },
          {
            "id": 3,
            "title": "Implement loadMatchState with try-catch error handling",
            "description": "Create the loadMatchState function with error handling for parsing and missing data.",
            "dependencies": [
              1
            ],
            "details": "Implement loadMatchState(): MatchState | null. Wrap the logic in try-catch block. Read from storage using localStorage.getItem() or settingsStorage.getItem(). If data is null/undefined, return null. Parse using JSON.parse(). If parsing fails (JSON error), catch the exception and return null. Return the parsed MatchState on success.",
            "status": "done",
            "testStrategy": "Unit test loading with no saved data (returns null). Test loading corrupted JSON (returns null). Test loading valid saved state (returns MatchState object).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:10.356Z"
          },
          {
            "id": 4,
            "title": "Add state validation for loaded data integrity",
            "description": "Implement validation logic to ensure loaded state has required fields and valid structure.",
            "dependencies": [
              3
            ],
            "details": "After successfully parsing JSON in loadMatchState, validate the loaded object structure. Check for required fields (e.g., status, sets, currentSet, teams). Verify data types match expected MatchState interface. If validation fails, return null to prevent app crashes from corrupted state. Optionally log validation errors for debugging.",
            "status": "done",
            "testStrategy": "Unit test loading state with missing required fields (returns null). Test loading state with invalid data types (returns null). Test loading complete valid state (returns object).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:12.222Z"
          },
          {
            "id": 5,
            "title": "Implement clearMatchState utility function",
            "description": "Create a utility to delete saved match state from storage.",
            "dependencies": [
              1
            ],
            "details": "Implement clearMatchState(): void function. Use localStorage.removeItem() or settingsStorage.setItem(key, null) to delete the saved match state. This is required for Task 19 (New Match Reset) to clear existing sessions. Export this function for use by other modules.",
            "status": "done",
            "testStrategy": "Save a match state, call clearMatchState, verify storage key is removed or null. Verify no error when clearing empty storage.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:54:12.201Z"
          },
          {
            "id": 6,
            "title": "Write comprehensive unit tests for persistence service",
            "description": "Create full test coverage for all persistence functions and edge cases.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Write unit tests covering: save functionality with timestamp verification, load with valid state, load with missing data, load with corrupted JSON, load with malformed/incomplete state, clear functionality, and sequential save-load operations. Mock the Zepp OS storage API to isolate tests. Test that updatedAt is properly updated during save.",
            "status": "done",
            "testStrategy": "Run all unit tests and ensure 100% code coverage. Verify all test cases pass including happy paths and error scenarios.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:15.911Z"
          }
        ],
        "updatedAt": "2026-02-21T09:58:15.911Z"
      },
      {
        "id": "13",
        "title": "Implement Pre-Match Setup UI and Logic",
        "description": "Create the Match Setup screen allowing users to select 1, 3, or 5 sets and initialize the match session.",
        "status": "done",
        "dependencies": [
          "11",
          "12"
        ],
        "priority": "high",
        "details": "Build the 'Match Setup' view with three buttons or a selector for sets (1, 3, 5). When a user confirms a selection: 1. Calculate `setsNeededToWin` (Math.ceil(setsToPlay / 2)), 2. Initialize a fresh `MatchState` object with scores at 0 and status 'active', 3. Call `saveMatchState`, 4. Navigate to the Game screen. Ensure this flow blocks access to the Game screen without a selection.",
        "testStrategy": "Manual QA: Verify selecting '3' sets allows entry to game. Verify default state is initialized correctly with scores at 0-0 and `setsNeededToWin` set to 2.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match Setup UI Components",
            "description": "Build the visual interface for the match setup screen with set selection buttons",
            "dependencies": [],
            "details": "Create the Match Setup view UI with three distinct buttons/selector options for 1, 3, or 5 sets. Add a 'Start Match' confirmation button that is initially disabled. Style elements for clarity and touch interaction on Zepp OS display. Include visual feedback for selected option.",
            "status": "done",
            "testStrategy": "Visual verification of all buttons rendering correctly. Test button selection state changes. Verify touch responsiveness on each button element.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:16.182Z"
          },
          {
            "id": 2,
            "title": "Implement Match State Initialization Model",
            "description": "Create the logic to calculate setsNeededToWin and initialize MatchState object",
            "dependencies": [],
            "details": "Implement `initializeMatchState(setsToPlay: number)` function. Calculate `setsNeededToWin` using `Math.ceil(setsToPlay / 2)`. Create fresh MatchState object with: teamASets=0, teamBSets=0, currentSet={teamAGames:0, teamBGames:0, teamAPoints:0, teamBPoints:0}, setHistory=[], setsToPlay, setsNeededToWin, status='active', createdAt and updatedAt timestamps.",
            "status": "done",
            "testStrategy": "Unit test verifying MatchState initialization with 1 set (setsNeededToWin=1), 3 sets (setsNeededToWin=2), 5 sets (setsNeededToWin=3). Verify all fields are correctly initialized to zero or default values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:17.512Z"
          },
          {
            "id": 3,
            "title": "Integrate Match State Persistence",
            "description": "Connect the setup flow to save the initialized match state to storage",
            "dependencies": [
              2
            ],
            "details": "In the setup confirmation handler, call the existing `saveMatchState(state)` function (from Task 12) with the newly initialized MatchState object. Ensure this happens before navigation. Add error handling to display user feedback if save fails (e.g., toast message or inline error). Return boolean success/failure status.",
            "status": "done",
            "testStrategy": "Integration test confirming MatchState is persisted to storage after clicking Start Match button. Verify storage contains valid JSON with correct structure. Test failure scenario with mock save failure.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:18.879Z"
          },
          {
            "id": 4,
            "title": "Implement Navigation Flow to Game Screen",
            "description": "Add navigation logic to transition from Setup to Game screen after state initialization",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement `navigateToGame()` function triggered after successful state save. Use Zepp OS navigation API (e.g., `push` or `replace`) to transition to the Game screen view. Ensure Game screen loads state from storage on init. Prevent duplicate navigation calls during async operations.",
            "status": "done",
            "testStrategy": "Manual test: Complete setup flow, verify Game screen appears and displays initial 0-0 state. Test rapid button clicks to ensure no double-navigation bugs.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:20.253Z"
          },
          {
            "id": 5,
            "title": "Add Validation and Access Control",
            "description": "Implement safeguards to prevent access to Game screen without proper setup",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add validation on Setup confirmation button requiring an explicit set selection (1, 3, or 5) before enabling. Implement guard on Game screen init that checks for valid active MatchState in storage using `loadMatchState`; redirect to Setup if missing, invalid, or status is not 'active'. Block direct Game screen entry without setup completion.",
            "status": "done",
            "testStrategy": "Test attempting direct Game screen navigation without setup - should redirect to Setup. Test clicking Start Match without selection - button should remain disabled. Verify guard catches corrupted state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:21.577Z"
          },
          {
            "id": 6,
            "title": "Create Unit and Integration Tests for Setup Flow",
            "description": "Write comprehensive tests covering the complete match setup workflow",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create unit tests for `initializeMatchState` function with edge cases including invalid inputs. Create integration tests for the full flow: UI selection  state init  save  navigate. Mock storage and navigation services. Test invalid inputs, storage failures, and happy path scenarios. Ensure tests can run in CI environment.",
            "status": "done",
            "testStrategy": "Automated test suite with >80% coverage of setup flow logic. Verify all acceptance criteria: selecting '3' sets allows entry, default state initializes correctly with 0-0 scores and setsNeededToWin=2.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:22.871Z"
          }
        ],
        "updatedAt": "2026-02-21T11:36:22.871Z"
      },
      {
        "id": "14",
        "title": "Integrate Lifecycle Persistence Triggers",
        "description": "Ensure state is saved automatically on app lifecycle events (sleep, exit, background) to meet reliability requirements.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "Hook into Zepp OS lifecycle events (e.g., `page.onHide`, `app.onHide`, or specific sleep callbacks depending on API availability). In these handlers, retrieve the current runtime state and call `saveMatchState`. Additionally, ensure `saveMatchState` is called immediately after any scoring update (add/remove point).",
        "testStrategy": "Integration test: Start a match, score a few points, trigger a 'sleep' event or 'back' button press, and relaunch the app. Verify storage contains the latest score.",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Zepp OS lifecycle event APIs",
            "description": "Investigate and document available lifecycle hooks in Zepp OS for handling app sleep, background, exit, and page hide events.",
            "dependencies": [],
            "details": "Review Zepp OS documentation to identify all available lifecycle callbacks including page.onHide, app.onHide, sleep callbacks, and any relevant event emitters. Test which events fire reliably in different scenarios (app backgrounding, screen lock, device sleep, back button press). Create a reference mapping of available events to their trigger conditions and reliability characteristics.",
            "status": "done",
            "testStrategy": "Create a test script that logs all lifecycle events and verify which hooks fire in simulator/emulator during various app state transitions (background, foreground, back button, screen off).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:44.791Z"
          },
          {
            "id": 2,
            "title": "Implement lifecycle event handler registration",
            "description": "Create handler functions that retrieve current runtime state and call saveMatchState when lifecycle events trigger.",
            "dependencies": [
              1
            ],
            "details": "Implement lifecycle event handler registration in the main app or game screen initialization. Create wrapper functions for each relevant lifecycle hook that retrieve the current MatchState from the state manager and pass it to saveMatchState. Ensure handlers are registered at app startup and cleaned up appropriately if needed. Handle potential errors during save operations gracefully.",
            "status": "done",
            "testStrategy": "Manually trigger lifecycle events (back button, background app) and verify through logs that saveMatchState is called with the correct state object.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:45.867Z"
          },
          {
            "id": 3,
            "title": "Integrate automatic save on scoring updates",
            "description": "Add calls to saveMatchState immediately after each scoring update operation (addPoint and removePoint).",
            "dependencies": [
              1
            ],
            "details": "Locate the addPoint and removePoint functions in the scoring logic. After each successful state mutation, call saveMatchState with the updated state. Ensure this happens synchronously before any UI updates to guarantee persistence. Verify that the save doesn't cause noticeable performance degradation in the UI. Consider batching if rapid scoring causes issues.",
            "status": "done",
            "testStrategy": "Add points multiple times rapidly and verify storage contains the correct final state after each operation. Test undo operations to ensure state persistence is maintained correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:47.307Z"
          },
          {
            "id": 4,
            "title": "Implement debounce and atomic save mechanism",
            "description": "Add debouncing logic to prevent race conditions and redundant save operations when multiple events trigger simultaneously.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement a debounced version of saveMatchState that coalesces rapid successive calls within a short window (e.g., 100-300ms). Use a flag or promise-based approach to ensure only one save operation runs at a time, preventing race conditions. The debounce should ensure the final state is saved even if multiple triggers occur in quick succession (e.g., scoring + back button pressed together). Ensure pending saves complete before app terminates.",
            "status": "done",
            "testStrategy": "Simulate rapid scoring followed immediately by a back button press. Verify only one save operation occurs and the final correct state is persisted. Test concurrent save requests to ensure no data corruption.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:48.507Z"
          },
          {
            "id": 5,
            "title": "Create integration tests for lifecycle persistence",
            "description": "Implement automated tests that simulate app lifecycle events and verify state persists correctly across app restarts.",
            "dependencies": [
              4
            ],
            "details": "Create integration test scenarios: 1) Start match, add points, trigger background/foreground cycle, verify state persists. 2) Add points, simulate sleep/power-off, relaunch, verify latest state. 3) Add points, press back, relaunch game screen, verify state restored. Mock or stub the Zepp OS lifecycle APIs if needed. Verify storage contains expected JSON structure and values. Test edge cases like empty state, zero scores, and finished matches.",
            "status": "done",
            "testStrategy": "Automated test suite covering all lifecycle scenarios with assertions on storage contents after each event. Manual testing on actual device if simulation is insufficient.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:49.732Z"
          },
          {
            "id": 6,
            "title": "Update documentation and code comments",
            "description": "Document the persistence mechanism, lifecycle handling, and debouncing approach in code comments and project documentation.",
            "dependencies": [
              5
            ],
            "details": "Add comprehensive comments to lifecycle handler registration code explaining which events are hooked and why. Document the debouncing mechanism with explanation of the race condition problem it solves. Update README or technical documentation with details on automatic state persistence behavior. Add inline comments in scoring functions noting where automatic saves occur. Document any limitations or edge cases in the persistence system.",
            "status": "done",
            "testStrategy": "Review documentation for clarity and completeness. Have another developer verify they understand the persistence mechanism from the documentation alone.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:50.831Z"
          }
        ],
        "updatedAt": "2026-02-21T13:44:50.831Z"
      },
      {
        "id": "15",
        "title": "Update Game Screen for Set Point Display",
        "description": "Modify the Game Screen UI to visualize the match-level set points (Sets Won) alongside current game scores.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "details": "Update the Game View UI layout to include labels or indicators for `setsWon.teamA` and `setsWon.teamB`. Bind these UI elements to the current `MatchState` data. Ensure the display updates immediately when the underlying state changes.",
        "testStrategy": "Visual QA: Verify that upon entering a game, set counters are visible and set to 0. Verify UI updates when set counts change programmatically.",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Game View layout structure",
            "description": "Examine the existing Game View layout to determine optimal placement for set point indicators without disrupting current score display.",
            "dependencies": [],
            "details": "Open the current Game View layout file. Review the existing score display sections (Game Points and Set Scores). Identify the best position for adding the Sets Won indicators, likely in the top section near team labels or alongside existing set scores. Ensure placement maintains proper spacing and doesn't cause layout overflow on round/square screens.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.319Z"
          },
          {
            "id": 2,
            "title": "Add set point UI elements to Game View",
            "description": "Create and position text labels or indicators for Team A and Team B Sets Won in the Game View layout.",
            "dependencies": [
              1
            ],
            "details": "Add two new text label widgets to the Game View UI - one for Team A sets won and one for Team B sets won. Position them based on the analysis from subtask 1. Use appropriate UI component IDs (e.g., 'teamA-sets-won', 'teamB-sets-won') for later binding. Ensure labels have placeholder text initially (e.g., '0'). Apply proper alignment relative to team labels or score displays.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.321Z"
          },
          {
            "id": 3,
            "title": "Bind setsWon properties to UI elements",
            "description": "Connect the new set point indicator labels to the MatchState setsWon.teamA and setsWon.teamB data properties.",
            "dependencies": [
              2
            ],
            "details": "In the Game View controller or binding logic, establish data bindings between the newly created UI labels and the MatchState.setsWon properties. Create reference bindings for teamA-sets-won to setsWon.teamA and teamB-sets-won to setsWon.teamB. Ensure the binding path correctly accesses the nested properties within the match state object.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.322Z"
          },
          {
            "id": 4,
            "title": "Implement reactive state update mechanism",
            "description": "Ensure the set point display updates immediately when the underlying MatchState setsWon values change.",
            "dependencies": [
              3
            ],
            "details": "Verify or implement reactive observers or state change listeners that trigger UI updates when setsWon properties are modified. Ensure the view re-renders or text content updates within 100ms of state change. If using a reactive framework (like Zepp's state management), confirm the bindings are properly reactive. If manual updates are needed, implement update functions called after state changes.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.323Z"
          },
          {
            "id": 5,
            "title": "Style set point indicators",
            "description": "Apply consistent styling to the set point labels to match the existing design system and ensure visibility.",
            "dependencies": [
              2
            ],
            "details": "Apply design tokens (colors, fonts, font sizes) to the set point indicator labels. Ensure high contrast for readability. Match the styling approach used for existing score displays. Consider adding visual hierarchy - perhaps smaller than current game points but clearly visible. Test that the styling works on both round and square screen layouts without overlapping other elements.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.324Z"
          },
          {
            "id": 6,
            "title": "Verify set point display functionality",
            "description": "Comprehensive testing of the set point display feature including initialization, updates, and visual consistency.",
            "dependencies": [
              4,
              5
            ],
            "details": "Test the complete feature: 1) Verify upon entering game, set counters are visible and correctly initialized to 0. 2) Programmatically change set counts and verify UI updates immediately. 3) Test by playing through a game and winning a set - confirm sets won increments. 4) Verify both Team A and Team B indicators update independently. 5) Check display on both round and square screen simulators for proper rendering.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.326Z"
          }
        ],
        "updatedAt": "2026-02-21T16:28:42.326Z"
      },
      {
        "id": "16",
        "title": "Implement Set Completion and Match Completion Logic",
        "description": "Develop the logic to handle set wins, update set history, reset games, and determine the match winner based on the configured format.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "Implement a function `handleGameWin(team)`. Logic: 1. Increment current set games. 2. Check Padel game win condition (e.g., >= 6 and diff >= 2). 3. If set won: Increment `setsWon` for the winner. Push final scores ({setNumber, teamAGames, teamBGames}) to `setHistory`. Reset `currentSet.games`. 4. Check match completion: If `setsWon[winner] >= setsNeededToWin`, set status to 'finished'. 5. If match finished, trigger navigation to Summary. If not, start next set.",
        "testStrategy": "Unit tests simulating game sequences to trigger set wins. Verify `setsWon` increments, `setHistory` is populated, and match status changes to 'finished' at the correct threshold.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement game score increment for winning team",
            "description": "Create function to increment the games count for the current set when a team wins a game point",
            "dependencies": [],
            "details": "Implement the first part of handleGameWin(team) that increments the current set's game count for the specified team. Update the teamAGames or teamBGames counter in the match state based on the team parameter passed to the function.",
            "status": "done",
            "testStrategy": "Unit test to verify games counter increments correctly for team A and team B independently",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:27.363Z"
          },
          {
            "id": 2,
            "title": "Implement Padel game win condition check",
            "description": "Create validation logic to determine if a set is won based on games won threshold and margin",
            "dependencies": [
              1
            ],
            "details": "Implement logic to check if the current set has been won by either team. A team wins a set if they have >= 6 games AND lead by at least 2 games (6-4, 6-0, 7-5, etc.). Return the winning team or null if no winner yet.",
            "status": "done",
            "testStrategy": "Unit tests for various score scenarios including 6-4, 7-5, 6-0 wins, and 5-5, 6-5 where no winner exists",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:30.120Z"
          },
          {
            "id": 3,
            "title": "Implement set completion and history tracking",
            "description": "Handle set win by incrementing setsWon, recording set history, and resetting current games",
            "dependencies": [
              2
            ],
            "details": "When a set is won, increment the winner's setsWon counter in match state. Push an object {setNumber, teamAGames, teamBGames} to setHistory array with current set number and final game scores. Reset currentSet.games to {teamA: 0, teamB: 0} for the next set.",
            "status": "done",
            "testStrategy": "Unit tests to verify setsWon increments correctly, setHistory is populated with proper score objects, and games reset to zero",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:32.488Z"
          },
          {
            "id": 4,
            "title": "Implement match winner determination",
            "description": "Check if match is finished by comparing setsWon to setsNeededToWin configuration",
            "dependencies": [
              3
            ],
            "details": "After a set is won, check if the winner's setsWon count meets or exceeds setsNeededToWin (e.g., 2 for best-of-3 format). If condition is met, update match status to 'finished', store the winning team identifier, and update the finishedAt timestamp.",
            "status": "done",
            "testStrategy": "Unit tests simulating 2-set win (best-of-3) and 3-set win scenarios to verify match status changes to finished at correct threshold",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:35.647Z"
          },
          {
            "id": 5,
            "title": "Implement navigation to Summary or next set",
            "description": "Trigger appropriate screen navigation based on match completion status",
            "dependencies": [
              4
            ],
            "details": "If match status is 'finished', trigger navigation to Match Summary screen (Task 18) with final state. If match continues, initialize the next set by incrementing setNumber and reset games, then ensure game screen displays updated state for new set.",
            "status": "done",
            "testStrategy": "Integration test to verify navigation to Summary after match win, and proper set initialization for continuing matches",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:38.432Z"
          }
        ],
        "updatedAt": "2026-02-21T19:22:38.432Z"
      },
      {
        "id": "17",
        "title": "Implement Home Screen Resume Logic",
        "description": "Update the Home Screen to conditionally show 'Resume Game' and handle restoring the active match state.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "On Home Screen initialization (`onShow` or `init`), call `loadMatchState`. If the result is not null AND `status === 'active'`, display the 'Resume Game' button/element. On 'Resume Game' click: 1. Load the state into the global runtime match manager. 2. Navigate to Game Screen. 3. Update UI to reflect restored state. Hide button if state is null or status is 'finished'.",
        "testStrategy": "Integration test: Create a match, exit to home. Verify 'Resume' appears. Click resume. Verify game screen opens with exact previous score. Finish a match, go home. Verify 'Resume' does not appear.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Resume Game Button to Home Screen Layout",
            "description": "Add a new 'Resume Game' button element to the Home Screen view and configure its initial visibility state.",
            "dependencies": [],
            "details": "Create the button UI element in the Home Screen layout/template. Set its visibility to hidden/false by default. Style the button to match the existing UI theme. Position it appropriately, typically near the 'Start New Game' button for logical user flow.",
            "status": "done",
            "testStrategy": "Visual QA: Verify the Home Screen renders without the Resume Game button visible on initial load.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:08.629Z"
          },
          {
            "id": 2,
            "title": "Implement Home Screen Initialization State Check",
            "description": "Implement the logic on Home Screen initialization to check for active match state and conditionally display the Resume button.",
            "dependencies": [
              1
            ],
            "details": "In the Home Screen's onShow or init lifecycle method, call the loadMatchState() function from the persistence service (Task 12). Evaluate the returned state: if state is not null AND state.status equals 'active', set the Resume Game button visibility to true; otherwise, ensure it remains hidden. Handle null states gracefully.",
            "status": "done",
            "testStrategy": "Unit test: Mock loadMatchState to return active state - verify button shows. Mock return null or finished status - verify button stays hidden.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:10.148Z"
          },
          {
            "id": 3,
            "title": "Implement Resume Game State Loading",
            "description": "Implement the logic to load the persisted match state into the global runtime match manager when Resume Game is clicked.",
            "dependencies": [
              2
            ],
            "details": "Create a click event handler for the Resume Game button. In the handler, call loadMatchState() to retrieve the current active state. Pass this state to the global runtime match manager's initialization/load function to restore the match state in memory. Add error handling for cases where state loading fails or returns invalid data.",
            "status": "done",
            "testStrategy": "Unit test: Verify the handler calls loadMatchState and passes the result to the match manager. Test error handling when state loading fails.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:11.751Z"
          },
          {
            "id": 4,
            "title": "Implement Resume Game Navigation",
            "description": "Implement navigation from Home Screen to Game Screen after state is successfully loaded.",
            "dependencies": [
              3
            ],
            "details": "After successfully loading the state into the match manager (in the Resume click handler), trigger navigation to the Game Screen using the app's navigation router. Ensure the navigation happens only after state loading is complete and successful. Add fallback error UI if navigation or state loading fails.",
            "status": "done",
            "testStrategy": "Integration test: Click Resume button and verify the navigation router is called with Game Screen route.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:15.280Z"
          },
          {
            "id": 5,
            "title": "Implement Game Screen UI State Restoration",
            "description": "Update the Game Screen UI to reflect the restored match state when opened via Resume functionality.",
            "dependencies": [
              4
            ],
            "details": "When the Game Screen initializes, check if a match state is already loaded in the global match manager. If present, update all UI elements (team scores, current set scores, games won, serve indicators, team names, set history) to display the values from the restored state. Ensure the game appears exactly as it was when the user exited.",
            "status": "done",
            "testStrategy": "Visual QA: Create a match with specific scores, exit, resume. Verify all UI elements show exact previous state including scores, serves, and history.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:17.184Z"
          },
          {
            "id": 6,
            "title": "Testing and Documentation for Resume Logic",
            "description": "Write comprehensive tests for the resume functionality and document the implementation details.",
            "dependencies": [
              5
            ],
            "details": "Write integration tests simulating the full resume flow: create a match, exit to home, verify Resume appears, click Resume, verify Game Screen opens with correct state. Add test for finished match not showing Resume. Document the resume feature behavior, edge cases handled, and integration points in the project README or technical documentation.",
            "status": "done",
            "testStrategy": "End-to-end test: Complete full user journey from creating match, exiting, resuming, and verifying state persistence. Verify 'Resume' does not appear for finished matches.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:19.358Z"
          }
        ],
        "updatedAt": "2026-02-21T19:48:19.358Z"
      },
      {
        "id": "18",
        "title": "Implement Match Summary Screen",
        "description": "Create the Summary Screen to display the match winner, final set points, and per-set breakdown.",
        "status": "done",
        "dependencies": [
          "11",
          "16"
        ],
        "priority": "medium",
        "details": "Build the 'Match Summary' view. Display: 'Team [A/B] Wins', Final Set Score (e.g., '2-1'), and a list of sets (e.g., 'Set 1: 6-4', 'Set 2: 4-6'). Iterate through the `setHistory` array from the `MatchState` to populate the list. Add 'Home' and 'Start New Game' buttons.",
        "testStrategy": "Visual QA: Complete a 3-set match. Verify summary shows the correct winner and all 3 set scores. Verify buttons are functional.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match Summary screen UI structure",
            "description": "Set up the basic screen layout container for the Match Summary view",
            "dependencies": [],
            "details": "Create the Match Summary screen component with Zepp OS configuration. Define the main layout structure including: header section for winner announcement, middle section for set breakdown list, and bottom section for action buttons. Configure proper screen dimensions and styling containers.",
            "status": "done",
            "testStrategy": "Verify the summary screen renders without errors when navigated to, displaying empty layout containers",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.854Z"
          },
          {
            "id": 2,
            "title": "Implement winner and final set score display",
            "description": "Add logic to determine and display the winning team and final match score",
            "dependencies": [
              1
            ],
            "details": "Extract the winning team from MatchState by comparing total sets won by Team A vs Team B. Display 'Team A Wins' or 'Team B Wins' in the header. Show the final set score (e.g., '2-1') based on the sets count from the state. Style the winner text prominently for visibility.",
            "status": "done",
            "testStrategy": "Test with both Team A and Team B winning scenarios; verify correct winner text and final score format displays accurately",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.857Z"
          },
          {
            "id": 3,
            "title": "Implement set history list rendering",
            "description": "Iterate through setHistory array and display each set's breakdown score",
            "dependencies": [
              2
            ],
            "details": "Map through the setHistory array from MatchState. For each set entry, create a list item showing 'Set N: X-Y' format where X is Team A's games and Y is Team B's games. Implement dynamic list rendering to handle variable number of sets (1-3+). Ensure proper spacing and formatting for readability.",
            "status": "done",
            "testStrategy": "Complete 2-set and 3-set matches; verify all sets display in correct order with accurate game scores (e.g., 'Set 1: 6-4', 'Set 2: 4-6', 'Set 3: 6-2')",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.858Z"
          },
          {
            "id": 4,
            "title": "Add Home and Start New Game buttons",
            "description": "Create and wire up navigation buttons at the bottom of the summary screen",
            "dependencies": [
              3
            ],
            "details": "Add two action buttons in the bottom section: 'Home' button navigates back to the Home screen using navigation API. 'Start New Game' button triggers the new match flow (integration point for Task 19). Configure proper button sizing, spacing, and touch targets for usability on the device.",
            "status": "done",
            "testStrategy": "Verify both buttons are tappable and responsive; test 'Home' navigates correctly; verify 'Start New Game' button is ready for Task 19 integration",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.860Z"
          },
          {
            "id": 5,
            "title": "Integrate summary screen into match completion flow",
            "description": "Connect Match Summary to trigger automatically when match ends and perform final testing",
            "dependencies": [
              4
            ],
            "details": "Update the scoring engine or state listener to detect when match status changes to 'finished'. Automatically navigate to Match Summary screen with the complete MatchState passed as parameter. Ensure the screen receives and displays the latest state data. Perform full end-to-end testing of the complete match-to-summary flow.",
            "status": "done",
            "testStrategy": "Visual QA: Complete a full 3-set match and verify summary shows correct winner and all 3 set scores. Test both navigation buttons. Verify edge case with 2-set finish.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.861Z"
          }
        ],
        "updatedAt": "2026-02-21T21:10:33.861Z"
      },
      {
        "id": "19",
        "title": "Implement New Match Reset and Cleanup",
        "description": "Ensure starting a new match clears the existing active session and history properly.",
        "status": "done",
        "dependencies": [
          "12",
          "13"
        ],
        "priority": "medium",
        "details": "Implement a `startNewMatchFlow` function. This should clear the persisted `ACTIVE_MATCH_SESSION` from storage (set to null or delete key). Reset the in-memory state manager. Then navigate to the Match Setup screen (Task 13). This must be triggered from the Summary screen 'Start New Game' button and potentially the Home screen if a hard reset is needed.",
        "testStrategy": "Functional test: Finish a match. Click 'Start New Game'. Check storage to ensure old 'finished' match is cleared or overwritten. Verify setup screen appears fresh.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create storage clearing utility function",
            "description": "Implement a utility function to clear the persisted active match session from storage.",
            "dependencies": [],
            "details": "Create a function `clearActiveMatchSession()` that uses the existing persistence API (from Task 12) to delete or set to null the `ACTIVE_MATCH_SESSION` key in local storage/settings storage. Ensure proper error handling is in place.",
            "status": "done",
            "testStrategy": "Unit test that verifies the storage key is removed or set to null after calling the function. Test with existing and non-existing session data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:37.458Z"
          },
          {
            "id": 2,
            "title": "Create state manager reset utility function",
            "description": "Implement a utility function to reset the in-memory match state manager to initial values.",
            "dependencies": [],
            "details": "Create a function `resetMatchStateManager()` that resets the global match state to its initial state: scores to 0-0, history stack empty, setHistory empty, status to 'idle', and any other relevant properties to default values. This will use the logic from Task 4's state structure.",
            "status": "done",
            "testStrategy": "Unit test that verifies state manager is reset to initial values after calling the function, even after a simulated active match state exists.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:38.430Z"
          },
          {
            "id": 3,
            "title": "Implement startNewMatchFlow main function",
            "description": "Implement the main startNewMatchFlow function that orchestrates cleanup and navigation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `startNewMatchFlow()` that: 1) calls `clearActiveMatchSession()` to remove persisted data, 2) calls `resetMatchStateManager()` to clear in-memory state, 3) navigates to the Match Setup screen (Task 13). Wrap in try-catch for graceful error handling and ensure the flow completes or fails safely.",
            "status": "done",
            "testStrategy": "Integration test: simulate an active match, call startNewMatchFlow, verify storage is cleared, state is reset, and navigation occurs to Match Setup screen.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:39.543Z"
          },
          {
            "id": 4,
            "title": "Connect Summary screen Start New Game button",
            "description": "Integrate the startNewMatchFlow function with the Summary screen's Start New Game button.",
            "dependencies": [
              3
            ],
            "details": "In the Summary Screen implementation (Task 18), locate the 'Start New Game' button and add a click event handler that calls `startNewMatchFlow()`. Ensure the handler provides visual feedback (e.g., loading state) if needed and prevents double-taps.",
            "status": "done",
            "testStrategy": "Functional test: Complete a match, view the Summary screen, click 'Start New Game', verify storage is cleared and Match Setup screen appears fresh without previous match data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:40.609Z"
          },
          {
            "id": 5,
            "title": "Add hard reset capability to Home screen",
            "description": "Add optional hard reset functionality to the Home screen for emergency reset scenarios.",
            "dependencies": [
              3
            ],
            "details": "On the Home Screen (Task 17), implement a hard reset mechanism - either a dedicated button (for debugging/admin) or a long-press gesture on a UI element. When triggered, call `startNewMatchFlow()`. Consider adding a confirmation dialog to prevent accidental resets. Document this feature appropriately.",
            "status": "done",
            "testStrategy": "Functional test: With an active match in progress, trigger the hard reset on Home screen, verify confirmation appears (if implemented), confirm action, and verify state is cleared and Match Setup screen appears.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:41.728Z"
          }
        ],
        "updatedAt": "2026-02-22T09:27:41.728Z"
      },
      {
        "id": "20",
        "title": "Edge Case Handling and Data Validation",
        "description": "Robustness check to handle app interruptions before first point, corrupted data, and null reference safety.",
        "status": "done",
        "dependencies": [
          "12",
          "17"
        ],
        "priority": "medium",
        "details": "Add defensive coding in `loadMatchState` and state consumers. Scenario 1: User exits immediately after setup (0 points). Ensure state saves 'active' status and loads correctly. Scenario 2: Partial data in storage. Logic must default to 'no active game' (hide resume) rather than crashing. Add checks in Game screen to ensure state exists before rendering UI.",
        "testStrategy": "QA Scenarios: 1. Setup match -> Press Back -> Open App -> Verify Resume works. 2. Manually corrupt storage file -> Open App -> Verify app loads Home safely without 'Resume'.",
        "subtasks": [],
        "updatedAt": "2026-02-22T09:55:22.386Z"
      },
      {
        "id": "21",
        "title": "Increase Add Point Button Size for Game Screen (Accessibility)",
        "description": "Refactor the Game Screen UI to ensure Add Point buttons meet the 44x44 px touch target requirement, optimizing layout for round and square Zepp OS screens without breaking existing functionality.",
        "details": "Modify the `page/game` layout to increase the dimensions of Team A and Team B Add/Remove point controls to a minimum of 44x44 px. Adjust the Points Display and Set Points display areas (referencing Task 15) to be more compact or repositioned to accommodate larger controls. Reduce non-essential UI elements (padding, chrome) if necessary to maximize space. Ensure layout logic handles dynamic sizing for Round (designWidth 454) and Square (designWidth 390) screens. Maintain event bindings established in Task 8 and ensure visual separation between interactive elements to prevent accidental adjacent taps.",
        "testStrategy": "Visual QA on Zepp OS simulator (round 454, square 390) to verify 44px minimum touch targets and adequate spacing. Conduct manual on-device rapid tap tests to verify responsiveness and prevent accidental touches. Verify accessibility standards (contrast, separation). Run regression tests for scoring flows and save/restore functionality to ensure UI changes do not break existing logic.",
        "status": "cancelled",
        "dependencies": [
          "7",
          "8",
          "15",
          "2",
          "4"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T16:47:53.181Z"
      },
      {
        "id": "22",
        "title": "Redesign Game Screen UI for Enhanced Readability and Touch Interaction",
        "description": "Overhaul the Game Screen interface to improve readability by replacing the segmented card layout with a streamlined header for Sets and Games. Modify the scoring interaction to allow adding points by tapping the score display directly, with dedicated minus buttons positioned below.",
        "details": "Refactor the `page/game` layout to eliminate the segmented card style. Implement a new, cleaner header section that distinctly displays 'SETS' and 'GAMES' labels alongside the corresponding values for Team A and Team B. Apply design tokens to increase font sizes significantly across all text elements for better legibility. Redesign the central score area so that the Point Score (0, 15, 30, etc.) acts as a large, touch-sensitive button; tapping this area should trigger the `addPoint` logic. Place explicit, styled 'Minus' (-) buttons directly below the score displays to handle `removePoint` actions. Ensure the layout remains responsive for both Round (454px) and Square (390px) screens, adjusting padding and flex distribution to prevent overlap.",
        "testStrategy": "Visual QA: Verify the new header layout clearly separates 'SETS' and 'GAMES' and that font sizes are visibly larger than the previous implementation. Functional Test: Tap the main score display for a team; verify that the score increments correctly and the UI updates immediately. Functional Test: Tap the 'Minus' button below the score; verify the score decrements correctly. Layout Test: Run on Round and Square simulators to ensure the tappable score areas are large enough to be easily hit and do not overlap with other elements. Regression Test: Resume a match and verify the new UI correctly populates with the existing `MatchState` data.",
        "status": "done",
        "dependencies": [
          "7",
          "8",
          "15"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:04:07.334Z"
      },
      {
        "id": "23",
        "title": "Implement Scrollable Match History on Summary Screen",
        "description": "Replace static history text with a scrollable SCROLL_LIST widget to accommodate longer match histories, adjust font sizing, and remove the Start New Game button from the Summary Screen.",
        "details": "This task modifies the existing Match Summary Screen (Task 18) to enhance the match history display. Implementation steps:\n\n1. **Replace Static History with SCROLL_LIST**: Remove the current static text display for set history. Implement a SCROLL_LIST widget that dynamically populates with items from the `setHistory` array in the MatchState. Each list item should display a single set result (e.g., 'Set 1: 6-4'). Configure the scrollable list to handle histories longer than the screen viewport.\n\n2. **Increase Font Scale**: Update the body font scale property from 0.04 to 0.08 to improve text readability. This may require adjusting the scrollable list item height to prevent text clipping.\n\n3. **Remove Start New Game Button**: Delete the 'Start New Game' button from the Summary Screen UI. Ensure the 'Home' button remains and continues to navigate properly to the Home screen.\n\n4. **UI Adjustments**: Re-layout the Summary Screen components to accommodate the new scrollable list. The layout should flow: Winner announcement, final score, scrollable set history list, and Home button at the bottom.\n\nNote: The Start New Game functionality was already handled in Task 19, so removing this button is purely a UI change. The data source (setHistory from MatchState) remains unchanged from Task 16.",
        "testStrategy": "1. Visual QA with short match: Complete a 1-set match and verify the scrollable list displays 'Set 1: X-Y' correctly with the larger font size (0.08).\n\n2. Scroll functionality test: Complete a 3 or 5-set match where the history exceeds the screen height. Verify the list is scrollable and all sets are accessible.\n\n3. Button verification: Confirm only the Home button exists on the Summary screen. Clicking it should navigate to the Home screen.\n\n4. Text readability: Verify the increased font scale (0.08) renders clearly without overlapping other UI elements.\n\n5. Edge case: Test with a match that went to tie-breaks to ensure set history formatting remains correct in the scrollable list (e.g., 'Set 2: 7-6').",
        "status": "done",
        "dependencies": [
          "18",
          "16"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:23.415Z"
      },
      {
        "id": "24",
        "title": "Simplify New Game Start Flow on Home Screen",
        "description": "Remove the confirmation mechanism when starting a new game from the home screen to reduce friction and allow immediate game start without any intermediate confirmation step or timer logic.",
        "details": "Modify the Home Screen 'Start New Game' button behavior to eliminate the confirmation dialog flow. Remove any UI components related to the confirmation modal (dialog text, confirm/cancel buttons, backdrop). Delete state variables tracking confirmation visibility (e.g., `showConfirmDialog`, `isConfirming`). Remove any timer logic associated with auto-dismissing confirmation dialogs or countdown timers. Update the 'Start New Game' click event handler to directly execute the start sequence: 1) Call the match reset/cleanup function from Task 19 to clear existing session data, 2) Navigate immediately to the Match Setup screen. Ensure this simplification only affects the Home Screen start flow and does not impact other areas of the app that may use confirmation patterns. Clean up any unused CSS/styling and event listeners previously associated with the confirmation dialog.",
        "testStrategy": "Functional Test: Tap 'Start New Game' button on Home Screen and verify immediate navigation to Match Setup screen without any confirmation dialog appearing. Integration Test: With an active saved game, tap 'Start New Game' and verify storage is cleared (check for null ACTIVE_MATCH_SESSION) and Match Setup loads correctly. Regression Test: Verify 'Resume Game' button continues to work as expected and is unaffected by the start flow changes. Edge Case Test: Rapid successive taps on 'Start New Game' should not cause multiple navigation attempts or storage conflicts. Visual Inspection: Confirm no visual artifacts or unused UI elements remain from the removed confirmation dialog.",
        "status": "done",
        "dependencies": [
          "6",
          "19"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:28.916Z"
      },
      {
        "id": "25",
        "title": "Implement Screen Keep-Awake During Active Game",
        "description": "Implement screen keep-awake functionality to prevent the watch from returning to the watchface when the screen turns off during an active game, with maximum brightness setting and simulator compatibility handling.",
        "details": "Implement screen keep-awake functionality for the Game Screen to ensure continuous gameplay visibility during active matches. On `page/game` initialization or `onShow` lifecycle event, call the Zepp OS screen wake API (e.g., `wearable.keepScreenOn()` or `wakelock.acquire()`) to prevent the screen from turning off. Set the bright screen time to maximum using the appropriate brightness settings API (e.g., `setBrightScreenDuration(MAX)`). Store the reference to the wake lock or screen keep setting in a module-level variable for cleanup. On page exit (`onHide`, `onDestroy`, or navigation away), release the wake lock or cancel the keep-awake request to restore normal power behavior. Wrap all API calls in try-catch blocks with feature detection (check if APIs exist before calling) to handle the simulator environment where these APIs may be unavailable. Add a fallback mechanism or graceful degradation if the APIs are not present (e.g., log a warning to console but allow the app to continue functioning). Ensure the implementation does not cause memory leaks by properly cleaning up references and avoiding multiple wake lock acquisitions.",
        "testStrategy": "Functional Test: Deploy the app to a physical watch device. Navigate to the Game Screen and verify the screen does not turn off after the default timeout period (wait at least 1-2 minutes without interaction). Functional Test: Exit the Game Screen (navigate back or to another page) and verify that normal screen timeout behavior is restored. Simulator Test: Run the app in the Zepp simulator environment. Navigate to the Game Screen and verify the app does not crash or throw errors when keep-awake APIs are unavailable. Memory Test: Repeatedly enter and exit the Game Screen (10+ times) to verify there are no memory leaks or accumulating wake lock references. Integration Test: Play a full match from start to finish to ensure keep-awake functionality persists throughout the entire gameplay session and properly disengages upon match completion.",
        "status": "done",
        "dependencies": [
          "7"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:34.245Z"
      },
      {
        "id": "26",
        "title": "Update App Icons for GTR-3 and GTS-3 Devices",
        "description": "Replace the existing icon.png assets specifically for GTR-3 and GTS-3 device targets with updated versions. Additionally, update the project documentation to include a visual reference of the new sample icon.",
        "details": "Locate the asset directories specific to the GTR-3 and GTS-3 devices within the project structure (typically found under directories named or tagged with device identifiers). Replace the current `icon.png` files in these directories with the updated icon assets. Ensure that the new assets adhere to the specific resolution requirements for GTR-3 (usually 454x454 pixels) and GTS-3 (usually 390x390 pixels) and are in the supported format (e.g., PNG). Navigate to the project documentation file (e.g., README.md or docs folder) and insert the new sample icon image. Add a caption or label indicating it is the updated reference icon for the application.",
        "testStrategy": "Build the application specifically for GTR-3 and GTS-3 targets using the Zepp OS tooling. Deploy the built application to the respective simulators or physical devices. Visually inspect the app icon on the device home screen/app drawer to verify it matches the new design and is not distorted or pixelated. Review the documentation file to ensure the embedded sample icon renders correctly and is clearly visible.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:46.760Z"
      },
      {
        "id": "27",
        "title": "Refactor Tests to Use Synchronous Storage APIs",
        "description": "Update all test files to replace asynchronous storage calls with synchronous adapter methods, aligning test patterns with the production Zepp OS `hmFS` file system APIs.",
        "details": "Locate all test files that utilize the storage layer (specifically those testing `saveState`, `loadState`, or persistence logic). Remove `async`/`await` keywords from test function definitions and within the test bodies where storage operations occur. Replace the asynchronous calls with the synchronous `hmFS.SysProSetChars` and `hmFS.SysProGetChars` methods (or their synchronous adapter wrappers) to match the production implementation. Delete any `setTimeout`, `waitFor`, or promise-based delay logic that was previously required to wait for asynchronous storage operations to complete. Simplify test assertions by removing `await` prefixes and validating the state immediately following the synchronous function call. Ensure mock implementations in the test environment are updated to return values directly instead of resolving Promises.",
        "testStrategy": "Run the full test suite to verify all storage-related tests pass without 'UnhandledPromiseRejection' errors or timeout failures. Verify that tests execute faster due to the removal of artificial delays. Confirm that tests for edge cases (e.g., reading empty storage, handling corrupted data) still function correctly with the synchronous read/write pattern.",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:46.764Z"
      },
      {
        "id": "28",
        "title": "Fix Game Screen Navigation to Home Screen",
        "description": "Correct the navigation logic for the Game Screen so that both the 'Return to Home' button and the swipe-back gesture route directly to the Home Screen instead of the Game Setup Screen.",
        "details": "Locate the 'Return to Home' button event handler within the `page/game` implementation. Update the routing logic to navigate directly to `page/index` (Home Screen) instead of the Setup Screen. Implement or modify the `onBack` lifecycle event handler for the Game Screen to intercept system swipe-back gestures. Inside the `onBack` handler, explicitly set the navigation path to `page/index` and prevent the default behavior which currently routes to the Setup Screen. Ensure that match state is handled appropriately (e.g., saving) before navigation if the game is active.",
        "testStrategy": "Functional Test: Start a new game from the Home Screen. Tap the 'Return to Home' button and verify the app navigates directly to the Home Screen without passing through the Setup Screen. Functional Test: Start a new game, perform a swipe-back gesture, and verify the app navigates directly to the Home Screen. Regression Test: Verify that starting a new game from the Home Screen still functions correctly and that the Resume Game button appears correctly when exiting an active match.",
        "status": "done",
        "dependencies": [
          "7",
          "22"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Reproduce and document current navigation behavior",
            "description": "Investigate and document the current buggy navigation flow from Game Screen to Setup Screen",
            "dependencies": [],
            "details": "Navigate to the Game Screen from Home Screen. Attempt to use both the 'Return to Home' button and swipe-back gesture. Document the actual routing behavior (routes to Setup Screen instead of Home). Capture screenshots or record the issue. Identify the exact location in the codebase where routing decisions are made (page/game implementation, button event handlers). Deliverables: Issue documentation with reproduction steps and code location analysis.\n<info added on 2026-02-22T18:19:59.378Z>\nInvestigation Complete - Current Navigation Behavior Documented:\n\nBUG #1 - Button Handler (page/game.js lines 581-593):\nnavigateToHomePage() uses goBack() as primary navigation, which navigates to Setup Screen (previous page in stack) instead of Home Screen.\n\nBUG #2 - Swipe-back Gesture (page/game.js):\nNo onBack() lifecycle handler implemented. Swipe-back defaults to goBack() behavior, going to Setup instead of Home.\n\nFiles to modify:\n1. page/game.js - Modify navigateToHomePage() to always use gotoPage to page/index\n2. page/game.js - Add onBack() lifecycle handler\n3. tests/game-screen-layout.test.js - Update tests to expect gotoPage instead of goBack\n\nState preservation via saveCurrentRuntimeState({ force: true }) is working correctly.\n</info added on 2026-02-22T18:19:59.378Z>",
            "status": "done",
            "testStrategy": "Manual testing on simulator/device to confirm the bug exists and document steps",
            "updatedAt": "2026-02-22T18:20:07.304Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design routing changes and state-saving approach",
            "description": "Design the updated navigation flow and state preservation strategy for Game Screen",
            "dependencies": [
              1
            ],
            "details": "Design the new routing flow: both 'Return to Home' button and swipe-back should navigate directly to page/index (Home Screen). Determine when to save match state: always save before navigation, or only if match is active. Design confirm dialog behavior for matches in progress. Identify files to modify: page/game/index.js or similar, routing configuration, state management module. Deliverables: Updated routing flow diagram and state-saving logic specification.\n<info added on 2026-02-22T18:23:08.755Z>\nDesign Documentation Complete - Routing Changes and State-Saving Approach\n\n1. Updated Routing Flow Specification\nCurrent Buggy Behavior:\n- Home (page/index) -> Setup (page/setup) -> Game (page/game)\n- navigateToHomePage() uses goBack() which navigates to previous page in stack (Setup), not Home\n- No onBack() lifecycle handler exists, so swipe-back defaults to goBack() behavior\n\nNew Routing Flow (Both paths navigate directly to Home Screen):\nGame Screen -> [Button Tap OR Swipe-Back] -> Home Screen (page/index)\n\nImplementation:\n- Remove goBack() fallback from navigateToHomePage()\n- Always use direct navigation: hmApp.gotoPage({ url: 'page/index' })\n- Add onBack() lifecycle handler that returns true to prevent default back behavior\n\n2. State-Saving Logic Specification\nApproach: Save match state BEFORE navigation in all cases\n\nImplementation:\n- Reuse existing saveCurrentRuntimeState({ force: true }) method\n- Call this method in both navigateToHomePage() button handler AND the new onBack() handler\n- No confirm dialog needed (matches original behavior)\n- State is saved regardless of match status (active/inactive)\n\n3. Files to Modify\nFile: page/game.js\nChanges:\n1. Modify navigateToHomePage() - remove goBack(), always use gotoPage to page/index\n2. Add onBack() lifecycle handler after onDestroy()\n3. Both methods call saveCurrentRuntimeState({ force: true }) before navigation\n\nFile: tests/game-screen-layout.test.js\nChanges:\n1. Update \"game back-home control navigates back\" test to expect gotoPage instead of goBack\n2. Update \"game back-home control falls back...\" test description and remove goBack deletion logic\n3. Add new test: \"game onBack handler saves state and navigates to home\"\n\n4. Design Decisions Summary\n- Chosen Approach: Direct navigation with gotoPage + onBack handler (Simplest, minimal code change)\n- Rejected Approaches: Clear navigation stack (overengineered, limited Zepp OS APIs); Page replacement APIs (more complex without benefit)\n- Risk Level: Low - Both gotoPage and onBack are standard Zepp OS APIs\n- Backward Compatibility: Maintained - Resume Game functionality unchanged\n</info added on 2026-02-22T18:23:08.755Z>",
            "status": "done",
            "testStrategy": "Review design specification with team to ensure it handles all edge cases",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:23:16.028Z"
          },
          {
            "id": 3,
            "title": "Implement onBack handler for swipe-back interception",
            "description": "Implement the onBack lifecycle event handler to intercept system swipe-back gestures",
            "dependencies": [
              2
            ],
            "details": "In page/game implementation, add or modify the onBack lifecycle event handler. Intercept swipe-back gesture and prevent default behavior which routes to Setup Screen. Explicitly set navigation path to page/index (Home Screen). Call state saving logic before navigation if match is active. Return true to prevent default back behavior. Files to modify: page/game/index.js or page/game/page.js (main game screen file). Deliverables: Working onBack handler that routes to Home Screen.",
            "status": "done",
            "testStrategy": "Manual test: Start game, swipe back, verify direct navigation to Home Screen with state preserved",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:34:41.130Z"
          },
          {
            "id": 4,
            "title": "Implement Return to Home button handler with state saving",
            "description": "Update the Return to Home button event handler to route directly to Home Screen",
            "dependencies": [
              2
            ],
            "details": "Locate the 'Return to Home' button in page/game UI. Update its click event handler to navigate directly to page/index instead of Setup Screen. Implement state saving before navigation: save current match state to storage. Add confirm dialog (optional) if match is in progress to warn user. Debounce rapid clicks to prevent double navigation. Files to modify: page/game/index.js, page/game/game.view or similar UI file. Deliverables: Updated button handler with proper navigation and state preservation.\n<info added on 2026-02-22T18:33:22.842Z>\nImplementation update: Modified navigateToHomePage() in page/game.js (lines 952-964). The method now explicitly calls hmApp.gotoPage({ url: 'page/index' }) instead of goBack(). The goBack() fallback logic was removed entirely. Added try/catch block for error handling. This ensures the Return to Home button always navigates directly to Home Screen (page/index) regardless of navigation stack history.\n</info added on 2026-02-22T18:33:22.842Z>",
            "status": "done",
            "testStrategy": "Functional test: Click Return to Home, verify navigation to Home Screen with state saved",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:33:36.882Z"
          },
          {
            "id": 5,
            "title": "Add tests and perform QA verification",
            "description": "Implement unit/integration tests and conduct end-to-end QA for navigation fixes",
            "dependencies": [
              3,
              4
            ],
            "details": "Write unit tests for navigation logic and onBack handler. Write integration tests for complete flow from Game Screen to Home Screen. Create QA checklist: verify button navigation, verify swipe-back navigation, verify state preservation, verify 'Resume Game' appears after exit. Test edge cases: exit during active match, exit with no match in progress, rapid button clicks. Update documentation if needed. Deliverables: Test suite code, QA checklist with pass/fail results.\n<info added on 2026-02-22T18:37:50.890Z>\nQA Verification Complete - All tests pass (191/191)\n\nTests Added for onBack Handler:\n1. \"game onBack handler returns true to prevent default back behavior\" - PASS\n2. \"game onBack handler saves state before navigation\" - PASS\n3. \"game onBack handler navigates to home screen\" - PASS\n4. \"game onBack handler does not throw when hmApp is unavailable\" - PASS\n5. \"game onBack handler does not throw when gotoPage throws\" - PASS\n\nExisting Tests Verified:\n- \"game back-home control navigates directly to home screen\" - PASS\n- \"game back-home control navigates to home screen when gotoPage is available\" - PASS\n\nQA Checklist Results:\n Button navigation works - Return to Home button navigates directly to page/index\n Swipe-back navigation works - onBack() handler intercepts and navigates to page/index\n State preservation works - saveCurrentRuntimeState({ force: true }) called before navigation\n Resume Game functionality - State is saved before navigation, allowing resume\n\nQA Gate Result: PASS (191/191 tests passed)\n</info added on 2026-02-22T18:37:50.890Z>",
            "status": "done",
            "testStrategy": "Execute QA checklist on simulator and physical device; verify all test cases pass",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:38:01.379Z"
          }
        ],
        "updatedAt": "2026-02-22T18:38:01.379Z"
      },
      {
        "id": "29",
        "title": "Implement Match History Storage and Viewing",
        "description": "Implement persistent match history storage using Zepp OS hmFS and add a Previous Matches feature to the home screen for reviewing completed matches.",
        "details": "Implement a new history storage service using `hmFS` API to persist completed match results. Create a data structure for match history entries including: matchId (unique identifier), timestamp, date, time, finalScore, setsWon for both teams, setHistory array, matchDuration (in minutes), and setsToPlay format. Implement `saveMatchToHistory(matchState)` that generates a unique ID using timestamp, extracts relevant data, calculates match duration, and saves to hmFS with filename pattern `match_<timestamp>.json` or maintains a history index file. Implement `loadMatchHistory()` to read all stored matches and `loadMatchById(matchId)` for specific matches. Update Home Screen (Task 17) to add 'Previous Matches' button alongside Start and Resume. Create a new Match History screen with SCROLL_LIST displaying previous matches with date/time as primary label (e.g., '2024-01-15 14:30') and optional brief summary like 'Team A won 2-1'. Implement navigation so tapping a history item loads the match data and navigates to Summary Screen (Task 18) for display. Ensure Summary Screen can handle both active completed matches and historical matches. Handle edge cases: empty history, corrupted files, storage limits. Consider implementing a limit (e.g., last 50 matches) with cleanup logic.",
        "testStrategy": "1. Functional test: Complete a match and verify it's saved to hmFS by checking file existence or listing history. 2. Persistence test: Save a match, restart watch/app, verify match appears in history list. 3. UI test: Navigate to home screen, verify 'Previous Matches' button appears. 4. Navigation test: Tap 'Previous Matches', verify history screen appears with list. 5. Detail test: Tap on a history item, verify summary screen displays correct match data. 6. Data integrity test: Verify stored data includes all required fields (date, time, scores, sets won, duration). 7. Multiple matches test: Complete multiple matches, verify all appear in history in chronological order. 8. Edge case test: Test with empty history (first install), verify graceful handling. 9. Display test: Verify date/time format is readable on watch screen. 10. Scroll test: With many matches in history, verify scrolling works correctly.",
        "status": "done",
        "dependencies": [
          "16",
          "17",
          "18"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match History Data Structure and Storage Service",
            "description": "Define the data structure for match history entries and initialize the history storage service using hmFS API for persistent storage.",
            "dependencies": [],
            "details": "Create a new MatchHistoryService module using hmFS API. Define the MatchHistoryEntry interface with fields: matchId (string, unique timestamp), timestamp (number), date (string 'YYYY-MM-DD'), time (string 'HH:mm'), finalScore (string), setsWon (object with teamA and teamB), setHistory (array), matchDuration (number in minutes), setsToPlay (number). Implement the storage directory initialization and helper functions for file path construction using pattern 'match_<timestamp>.json'. Create an index file to track all stored match IDs for efficient listing.",
            "status": "done",
            "testStrategy": "Verify the data structure is correctly typed. Test that the storage directory is created on initialization. Validate that file paths are generated correctly using the match_<timestamp>.json pattern.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.553Z"
          },
          {
            "id": 2,
            "title": "Implement saveMatchToHistory Function",
            "description": "Implement the function to save completed match data to hmFS with unique ID generation, duration calculation, and storage limits enforcement.",
            "dependencies": [
              1
            ],
            "details": "Implement saveMatchToHistory(matchState) function that extracts relevant data from completed MatchState. Generate unique matchId using Date.now() timestamp. Calculate matchDuration by subtracting startTime from endTime (stored in matchState or derived from state timestamps). Create MatchHistoryEntry object and serialize to JSON. Save to hmFS using the filename pattern. Implement storage limit check (max 50 matches) - if limit exceeded, delete oldest match file and update index. Include error handling for write failures and disk full scenarios. Update the history index file with the new match ID.",
            "status": "done",
            "testStrategy": "Complete a match and verify file is created with correct filename pattern. Check that matchDuration is calculated correctly. Test that exceeding 50 matches triggers cleanup of oldest entry. Verify corrupted state doesn't crash the app.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.558Z"
          },
          {
            "id": 3,
            "title": "Implement loadMatchHistory and loadMatchById Functions",
            "description": "Implement functions to retrieve all stored matches from hmFS and load a specific match by its unique identifier with error handling.",
            "dependencies": [
              1
            ],
            "details": "Implement loadMatchHistory() that reads the index file to get all match IDs, then iterates through each ID to read individual match files. Return array of MatchHistoryEntry objects sorted by timestamp (newest first). Handle missing index file by returning empty array. Implement loadMatchById(matchId) that constructs the file path and reads the specific match JSON file. Both functions must include try-catch blocks to handle corrupted JSON files - skip corrupted entries in loadMatchHistory and return null for loadMatchById on errors. Handle file not found gracefully.",
            "status": "done",
            "testStrategy": "Test loading history with multiple matches saved. Verify sorting is correct (newest first). Test loading by specific matchId returns correct data. Test with corrupted file ensures it's skipped or returns null. Test empty history returns empty array.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.561Z"
          },
          {
            "id": 4,
            "title": "Update Home Screen with Previous Matches Button",
            "description": "Add a 'Previous Matches' button to the Home Screen alongside existing Start and Resume buttons to enable navigation to match history.",
            "dependencies": [],
            "details": "Modify the Home Screen component (from Task 17) to add a new 'Previous Matches' button positioned below or alongside the existing Start and Resume buttons. Style the button consistently with existing UI. Implement the button's onClick handler to navigate to the new Match History screen (using hmUI.push or similar navigation API). Ensure the button is always visible regardless of whether there's an active match session. Consider adding a small indicator (badge) showing the count of saved matches if desired.",
            "status": "done",
            "testStrategy": "Verify the 'Previous Matches' button appears on Home Screen. Confirm button styling matches existing buttons. Test clicking the button navigates to Match History screen. Verify button works both with and without active match sessions.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.565Z"
          },
          {
            "id": 5,
            "title": "Create Match History Screen with SCROLL_LIST and Navigation",
            "description": "Build the Match History screen displaying all stored matches in a scrollable list with tap-to-view navigation to Summary Screen.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create new Match History screen component using Zepp OS SCROLL_LIST widget. On screen load, call loadMatchHistory() to retrieve all matches. Configure SCROLL_LIST with custom list item template showing date/time as primary label (e.g., '2024-01-15 14:30') and brief summary as secondary label (e.g., 'Team A won 2-1, 45 min'). Handle empty history case by displaying 'No matches played yet' message. Implement onTap handler for list items that calls loadMatchById(matchId), stores the loaded match data (possibly in a global or navigation context), and navigates to Summary Screen. Modify Summary Screen (Task 18) to accept and display historical match data - distinguish between active completed matches and historical matches using a flag or data source check. Edge cases: gracefully handle navigation with no matches selected, display error for corrupted entries on tap.",
            "status": "done",
            "testStrategy": "Verify scrollable list displays all matches with correct format. Test tapping an item loads the match and navigates to Summary Screen. Verify Summary Screen correctly displays historical match data. Test empty history shows appropriate message. Test tapping corrupted entry shows error or is handled gracefully.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.568Z"
          },
          {
            "id": 6,
            "title": "Improve History List UI - Larger fonts and 2 items per view",
            "description": "Modify the SCROLL_LIST to show only 2 matches at a time; increase font size for better readability; display format: datetime + final score on single line (e.g., 23/02 14:30 - 2-1).",
            "dependencies": [],
            "details": "Update the SCROLL_LIST configuration and item template in page/history.js so the list shows two items per viewport (configure item height or viewport settings as needed). Increase font sizes for primary label and secondary label to improve readability on watch displays. Ensure each item shows single-line label combining date/time and final score as 'DD/MM HH:mm - finalScore'. Preserve existing onTap/navigation behavior.",
            "status": "done",
            "testStrategy": "verify two items visible, fonts larger, formatting correct",
            "updatedAt": "2026-02-23T13:43:14.678Z",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Research Zepp OS v1.0 Modal/Popup and Enhance Detail View",
            "description": "Research if Zepp OS v1.0 provides modal/popup functionality; if not present, enhance existing history-detail.js page to show full set-by-set scores (games in each set).",
            "dependencies": [],
            "details": "Perform research and document whether Zepp OS v1.0 supports modal/popup widgets or overlays. If modal/popup is available, note the recommended widget and implementation notes. If not available, implement improvements in page/history-detail.js to present a detailed match view showing full setHistory including games and points per set, arranged clearly for small-screen watches. Include UI/UX notes for readability and navigation (back/close).",
            "status": "done",
            "testStrategy": "verify detail view shows all games per set and is navigable",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T13:45:37.542Z"
          },
          {
            "id": 8,
            "title": "Integration - Connect history list to detail view",
            "description": "When clicking a match in history list, navigate to detail view with full data. Pass match data (including setHistory) to show detailed scores.",
            "dependencies": [],
            "details": "Implement or update the onTap handler in page/history.js to pass the selected match's full data (including setHistory and match metadata) to history-detail.js. Use navigation context or parameters supported by the app framework (e.g., push page with params or shared state). Ensure history-detail.js receives and renders the passed data; fall back to loading by matchId when full data isn't passed.",
            "status": "done",
            "testStrategy": "verify tapping list item opens detail view with full set-by-set scores displayed",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T13:46:46.158Z"
          }
        ],
        "updatedAt": "2026-02-23T13:46:46.158Z"
      },
      {
        "id": "30",
        "title": "Add QA Controls with Husky, Biome, and Commitlint",
        "description": "Set up code quality tooling for the project, including git hooks for pre-commit and commit-msg validation, automated linting with Biome, and test execution on pre-push.",
        "details": "1. **Install Dependencies**: Run package manager commands to install `husky`, `@commitlint/cli`, `@commitlint/config-conventional`, `@biomejs/biome`, and `lint-staged` as dev dependencies.\n2. **Initialize Husky**: Run `npx husky install` to set up the git hooks infrastructure and configure the `prepare` script in `package.json` to ensure hooks are installed after `npm install`.\n3. **Configure Commitlint**: Create a `commitlint.config.js` file extending `@commitlint/config-conventional` to enforce commit message standards.\n4. **Configure Biome**: Create a `biome.json` configuration file to define linting and formatting rules for JavaScript and JSON files.\n5. **Configure lint-staged**: Create a `.lintstagedrc.json` file to map file extensions (`.js`, `.json`, `.ts`) to the Biome lint command.\n6. **Create Git Hooks**:\n   - **Pre-commit**: Create `.husky/pre-commit` containing `npx lint-staged` to run linters only on staged files.\n   - **Commit-msg**: Create `.husky/commit-msg` containing `npx commitlint --edit $1` to validate messages.\n   - **Pre-push**: Create `.husky/pre-push` containing `npm test` to ensure the test suite passes before pushing.\n7. **Update package.json Scripts**: Add scripts for `\"lint\"`, `\"format\"`, and `\"lint:fix\"` using Biome CLI commands (`biome check .`, `biome format --write .`, `biome check --write .`).",
        "testStrategy": "1. **Pre-commit Verification**: Intentionally introduce a linting error (e.g., unused variable) in a JavaScript file, stage it, and attempt to commit. Verify that the commit is blocked by the pre-commit hook and the Biome error is displayed in the console.\n2. **Linting Fix**: Run the `npm run lint:fix` command, stage the changes, and verify the commit now succeeds.\n3. **Commit-msg Verification**: Attempt to commit with a message like 'bad message' and verify the commit-msg hook blocks it. Retry with a conventional commit like 'feat: add qa controls' and verify success.\n4. **Pre-push Verification**: Temporarily break a unit test, then attempt to `git push`. Verify that the pre-push hook blocks the push due to the test failure. Fix the test and verify the push succeeds.",
        "status": "done",
        "dependencies": [
          "1",
          "3"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Dependencies and Initialize Husky",
            "description": "Install all required development dependencies and set up the Husky git hooks infrastructure for the project.",
            "dependencies": [],
            "details": "Run package manager commands to install husky, @commitlint/cli, @commitlint/config-conventional, @biomejs/biome, and lint-staged as dev dependencies. Then run `npx husky install` to set up the git hooks infrastructure. Finally, configure the `prepare` script in package.json to ensure hooks are installed automatically after `npm install`.",
            "status": "done",
            "testStrategy": "Verify the Husky .husky directory is created and the prepare script exists in package.json. Run `npm run prepare` and confirm no errors occur.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:52:36.704Z"
          },
          {
            "id": 2,
            "title": "Configure Biome and Add Package Scripts",
            "description": "Create the Biome configuration file and add linting and formatting scripts to package.json.",
            "dependencies": [
              1
            ],
            "details": "Create a `biome.json` configuration file in the project root to define linting and formatting rules for JavaScript and JSON files. Update package.json to add the following scripts: \"lint\" using `biome check .`, \"format\" using `biome format --write .`, and \"lint:fix\" using `biome check --write .`.",
            "status": "done",
            "testStrategy": "Run `npm run lint` to verify Biome checks files without errors. Run `npm run lint:fix` to ensure auto-fixing works correctly. Verify the biome.json file is valid JSON.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:54:10.892Z"
          },
          {
            "id": 3,
            "title": "Configure Commitlint and Create Commit-msg Hook",
            "description": "Set up commit message validation using Commitlint and create the git hook for message checking.",
            "dependencies": [
              1
            ],
            "details": "Create a `commitlint.config.js` file in the project root that extends `@commitlint/config-conventional` to enforce conventional commit message standards. Create the `.husky/commit-msg` hook file containing the command `npx commitlint --edit $1` to validate commit messages before they are accepted.",
            "status": "done",
            "testStrategy": "Attempt to commit with an invalid message (e.g., 'bad commit') and verify the commit is rejected. Commit with a valid message (e.g., 'feat: add new feature') and verify it succeeds.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:54:30.937Z"
          },
          {
            "id": 4,
            "title": "Configure Lint-staged and Create Pre-commit Hook",
            "description": "Set up lint-staged to run linters only on staged files and create the pre-commit git hook.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a `.lintstagedrc.json` configuration file in the project root that maps file extensions (`.js`, `.json`, `.ts`) to the appropriate Biome lint command. Create the `.husky/pre-commit` hook file containing `npx lint-staged` to run linters automatically on staged files before each commit.",
            "status": "done",
            "testStrategy": "Intentionally introduce a linting error (e.g., unused variable or trailing whitespace) in a JavaScript file, stage it, and attempt to commit. Verify that the commit is blocked and the Biome error is displayed. Fix the error and confirm the commit succeeds.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:54:50.648Z"
          },
          {
            "id": 5,
            "title": "Create Pre-push Hook and Verify All Quality Controls",
            "description": "Create the pre-push git hook for test execution and perform end-to-end testing of all quality controls.",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Create the `.husky/pre-push` hook file containing `npm test` to ensure the test suite passes before pushing changes to remote. Perform comprehensive testing of all three hooks: verify pre-commit blocks commits with linting errors, verify commit-msg rejects non-conventional messages, and verify pre-push blocks pushes when tests fail.",
            "status": "done",
            "testStrategy": "Make a test fail temporarily and attempt to push - verify the push is blocked. Fix the test and verify push succeeds. Run through a full workflow: create a change, fix any linting issues, write a proper commit message, and push to confirm all quality gates work together.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:55:23.366Z"
          }
        ],
        "updatedAt": "2026-02-23T17:55:23.366Z"
      },
      {
        "id": "31",
        "title": "Set up GitHub Actions CI/CD Workflow",
        "description": "Create a GitHub Actions workflow to validate Pull Requests and pushes to the main branch, implementing quality gates, Node.js matrix testing, build verification, and security checks.",
        "details": "1. Create the workflow file at `.github/workflows/ci.yml`.\n2. Configure triggers for `push` on `main` branch and `pull_request` events.\n3. Define a strategy matrix to test against Node.js versions `18.x` and `20.x` to ensure compatibility.\n4. Implement caching for `node_modules` using `actions/cache` keyed on `package-lock.json` to optimize build times.\n5. Add sequential job steps to:\n   - Checkout code using `actions/checkout`.\n   - Setup Node.js using `actions/setup-node`.\n   - Restore cache and install dependencies (`npm ci`).\n   - Run code quality checks: `npm run lint` (Biome) and `npm run format -- --check`.\n   - Check for dependency vulnerabilities: `npm audit`.\n   - Verify the build process: `zeus build` (if applicable to the Zepp OS project structure).\n   - Execute the test suite: `npm run test`.\n6. Ensure the workflow is configured to fail the status check if any of the quality gates or tests fail.",
        "testStrategy": "1. Trigger the workflow by pushing a commit to the main branch and verify it initializes automatically in the Actions tab.\n2. Open a test Pull Request and confirm the workflow runs against the proposed changes.\n3. Verify the matrix strategy executes jobs for both Node.js 18.x and 20.x versions.\n4. Inspect workflow logs to confirm `node_modules` caching is working (cache hit/restored) on subsequent runs.\n5. Intentionally break the build configuration (e.g., add a linting error) in a PR to verify that the CI status fails and correctly prevents merging.\n6. Ensure `npm audit` and format checks run successfully on clean code.",
        "status": "done",
        "dependencies": [
          "30"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GitHub Actions workflow file and configure triggers",
            "description": "Initialize the CI workflow file with proper event triggers for push and pull request events",
            "dependencies": [],
            "details": "Create `.github/workflows/ci.yml` file with basic workflow structure. Configure triggers for `push` events on the `main` branch and `pull_request` events for all branches to ensure validation on all proposed changes.",
            "status": "done",
            "testStrategy": "Push a commit to main branch and verify workflow appears in Actions tab. Open a test PR and confirm workflow triggers automatically.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:10.965Z"
          },
          {
            "id": 2,
            "title": "Configure Node.js matrix testing strategy",
            "description": "Set up multi-version Node.js testing using GitHub Actions matrix strategy",
            "dependencies": [
              1
            ],
            "details": "Define a job strategy with a matrix to test against Node.js versions `18.x` and `20.x`. This ensures compatibility across supported Node.js versions and validates the application works in both environments.",
            "status": "done",
            "testStrategy": "Verify workflow executes 2 parallel jobs, one for each Node.js version. Check job names reflect the matrix versions.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:12.365Z"
          },
          {
            "id": 3,
            "title": "Implement dependency caching and installation",
            "description": "Set up node_modules caching and install project dependencies",
            "dependencies": [
              2
            ],
            "details": "Use `actions/cache` with key based on `package-lock.json` to cache `node_modules` directory. Configure the job to restore cache before installation. Add `npm ci` step to install dependencies cleanly, which uses the lockfile for reproducible builds.",
            "status": "done",
            "testStrategy": "Run workflow twice and verify second run uses cache (check for 'Cache restored' message in logs). Confirm dependencies install without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:13.730Z"
          },
          {
            "id": 4,
            "title": "Add code quality and security verification steps",
            "description": "Implement linting, formatting checks, and dependency vulnerability scanning",
            "dependencies": [
              3
            ],
            "details": "Add sequential steps for code quality checks: `npm run lint` using Biome for linting, `npm run format -- --check` to verify code formatting compliance, and `npm audit` to check for known security vulnerabilities in dependencies.",
            "status": "done",
            "testStrategy": "Intentionally introduce a linting error and verify workflow fails. Run on clean codebase and confirm all quality checks pass.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:15.180Z"
          },
          {
            "id": 5,
            "title": "Add build verification and test execution",
            "description": "Implement build process validation and automated test suite execution",
            "dependencies": [
              4
            ],
            "details": "Add build verification step using `zeus build` command to validate the Zepp OS project structure compiles correctly. Add test execution step using `npm run test` to run the full test suite. Configure workflow to fail status check if any step fails.",
            "status": "done",
            "testStrategy": "Verify build completes successfully and tests execute. Break a test and confirm workflow fails the status check, blocking PR merge.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:16.540Z"
          }
        ],
        "updatedAt": "2026-02-23T18:50:16.540Z"
      },
      {
        "id": "32",
        "title": "Audit & Fix Zepp OS v1.0 Lifecycle API Usage",
        "description": "Find and fix usages of Zepp OS lifecycle methods (onShow, onHide, onResume, onPause) that are invalid for API v1.0 in the codebase, replacing them with v1.0-compatible alternatives.",
        "details": "Perform a comprehensive audit of lifecycle API usage across the codebase to ensure compatibility with Zepp OS v1.0. Steps: 1) Search the repository for all occurrences of onShow, onHide, onResume, and onPause methods. 2) Verify and document usage in reporter-listed files: page/index.js, page/summary.js, page/setup.js, page/game.js, page/history-detail.js, page/history.js, identifying any additional occurrences. 3) For each occurrence, create a detailed documentation entry including: file path, exact code snippet, explanation of why it's invalid in v1.0, recommended v1.0 alternative approach, and proposed fix strategy. 4) Implement straightforward fixes by replacing onShow/onHide with v1.0 entry points (e.g., page initialization, event-based approaches) or creating feature-detection wrapper functions. 5) For complex or risky changes, document the recommended approach and create follow-up subtasks instead of implementing immediately. 6) Replace deprecated lifecycle methods with appropriate v1.0 equivalents such as using page initialization callbacks, app event listeners, or manual state management. 7) Update documentation in .taskmaster/notes with audit findings and modifications made. Deliverables include: complete audit findings list, summary of modified files, list of follow-up subtasks for risky fixes, and updated documentation.",
        "testStrategy": "1) Code review: Verify no instances of onShow/onHide/onResume/onPause remain in the codebase after fixes. 2) Functional testing for each modified page: index - verify page loads correctly and state initializes; game - confirm keep-awake functionality works and scoring persists on background; summary - validate match results display correctly after page navigation; setup - ensure match configuration initializes properly; history/history-detail - verify match history loads and displays; all pages - test navigation flow (forward and back) to ensure no state loss or crashes occur. 3) Lifecycle testing: Background the app during different states (game active, on setup screen, viewing history) and foreground to verify persistence works correctly. 4) Regression testing: Confirm that functionality from related tasks (screen keep-awake, auto-save on lifecycle events, match history storage) still operates as expected.",
        "status": "done",
        "dependencies": [
          "9",
          "14",
          "25",
          "12"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Search and Catalog All Lifecycle API Usage",
            "description": "Perform a comprehensive repository-wide search for deprecated Zepp OS lifecycle methods and catalog all findings.",
            "dependencies": [],
            "details": "Execute a code search across the entire repository for all occurrences of onShow, onHide, onResume, and onPause methods. Use grep or IDE search functionality to find all instances. Create a preliminary catalog listing file paths, line numbers, and exact method signatures for each occurrence. Pay special attention to the reporter-listed files: page/index.js, page/summary.js, page/setup.js, page/game.js, page/history-detail.js, and page/history.js, while also scanning the entire codebase for any additional occurrences in utility files or other components.",
            "status": "done",
            "testStrategy": "Verify the search results by manually checking the catalog against the known file list and randomly sampling entries to ensure accuracy.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:24.876Z"
          },
          {
            "id": 2,
            "title": "Analyze and Document Incompatibility Issues",
            "description": "Analyze each discovered lifecycle API usage and create detailed documentation explaining why it's incompatible with Zepp OS v1.0.",
            "dependencies": [
              1
            ],
            "details": "For each occurrence catalogued in the previous task, create a detailed documentation entry including: complete file path, exact code snippet context, explanation of why the method is invalid in v1.0 API, recommended v1.0 alternative approach (e.g., page initialization callbacks, app event listeners, or manual state management), and a specific proposed fix strategy. Categorize occurrences by complexity level: straightforward (simple replacement needed), moderate (requires refactoring logic), or complex/risky (requires significant architectural changes). Store this analysis in .taskmaster/notes/audit-findings.md.",
            "status": "done",
            "testStrategy": "Review documentation for completeness and technical accuracy. Ensure every occurrence has a clear recommended alternative documented.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:27.335Z"
          },
          {
            "id": 3,
            "title": "Implement Straightforward Page Initialization Fixes",
            "description": "Replace onShow/onHide methods with v1.0-compatible page initialization approaches for pages with simple requirements.",
            "dependencies": [
              2
            ],
            "details": "Implement fixes for pages categorized as straightforward in the audit. Replace onShow calls with page initialization logic placed directly in the page constructor or init function. For onHide calls that only need to save state, replace with explicit save calls before navigation. Focus on pages like page/index.js, page/summary.js, and page/setup.js where the lifecycle is simple. Create feature-detection wrapper functions if needed to maintain compatibility during transition. Ensure all state initialization happens synchronously during page load rather than waiting for show events.",
            "status": "done",
            "testStrategy": "Test each modified page by navigating to it and verifying it loads correctly with proper initialization. Verify no onShow/onHide methods remain in these files.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:29.983Z"
          },
          {
            "id": 4,
            "title": "Implement Event-Based Lifecycle Replacements",
            "description": "Replace deprecated lifecycle methods with v1.0 event listeners and manual state management for complex pages.",
            "dependencies": [
              2
            ],
            "details": "Implement fixes for complex pages like page/game.js, page/history-detail.js, and page/history.js. Replace onShow/onHide/onResume/onPause with app-level event listeners using app.on('pause') and app.on('resume') where appropriate. For page-specific visibility changes, implement manual state management using boolean flags or state objects that track visibility. Integrate these fixes with the existing saveMatchState functionality from Task 14. Ensure keep-awake functionality from the game page is preserved through alternative mechanisms such as wake-lock API calls on page load.",
            "status": "done",
            "testStrategy": "Functional testing: simulate backgrounding/foregrounding events and verify state persists correctly. Test game page to ensure scoring survives background transitions and keep-awake works as expected.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:32.574Z"
          },
          {
            "id": 5,
            "title": "Document Complex or Risky Changes for Follow-up",
            "description": "Create detailed documentation and recommendations for any lifecycle fixes that are too complex or risky to implement immediately.",
            "dependencies": [
              2
            ],
            "details": "For any occurrences categorized as complex or risky, do not implement the fix directly. Instead, create comprehensive documentation in .taskmaster/notes/risky-fixes.md that includes: the specific code that needs changing, why the change is risky (potential side effects, performance impact, architectural concerns), detailed step-by-step recommended approach for implementation, potential migration path or phased rollout strategy, and any additional dependencies or prerequisite work needed. This documentation will serve as the basis for future follow-up tasks.",
            "status": "done",
            "testStrategy": "Peer review of the documentation to ensure technical accuracy and that the proposed approach is feasible and well-documented.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:35.016Z"
          },
          {
            "id": 6,
            "title": "Final Verification and Documentation Update",
            "description": "Complete the audit by verifying all deprecated lifecycle methods are addressed and updating project documentation with findings.",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Perform a final code review to verify no instances of onShow, onHide, onResume, or onPause remain in the codebase except in the risky-fixes documentation. Update .taskmaster/notes with the complete audit findings summary including: total occurrences found, files modified, fixes implemented, and list of follow-up subtasks created for risky fixes. Create a summary document .taskmaster/notes/lifecycle-audit-summary.md with deliverables: complete audit findings list, summary of modified files, list of follow-up subtasks for risky fixes, and updated documentation. Ensure all changes are committed with appropriate commit messages referencing Task 32.",
            "status": "done",
            "testStrategy": "Code review: search codebase one final time for any remaining deprecated lifecycle methods. Verify documentation is complete and accurate. Build project to ensure no syntax errors were introduced.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:37.823Z"
          }
        ],
        "updatedAt": "2026-02-23T16:00:37.823Z"
      },
      {
        "id": "33",
        "title": "Create Settings Page with Scroll List",
        "description": "Implement a new Settings page featuring a SCROLL_LIST widget with navigation to match history and functionality to clear all app data, while removing these actions from the Home Screen.",
        "details": "Implementation Steps:\n\n1. **Create Settings Page Structure**: Create a new page at `page/settings` using Zepp UI components. Implement the page layout with a SCROLL_LIST (try to reproduce the same as the list example in here: https://docs.zepp.com/docs/1.0/designs/template/list/, with the text and the chevron, using the chevron-icon.png) widget as the primary container, following the Zepp SCROLL_LIST API documentation (https://docs.zepp.com/docs/1.0/reference/device-app-api/hmUI/widget/SCROLL_LIST/).\n\n2. **Implement SCROLL_LIST Items**: Configure the scrollable list with the following menu items:\n   - 'Previous Matches' item: Displayed text label with navigation indicator\n   - 'Clear App Data' item: Displayed text label with appropriate icon (delete-icon.png)\n\n3. **Implement 'Previous Matches' Navigation**: Add click event handler for the 'Previous Matches' list item that navigates to the match history view. This should use `hmUI.gotoPage()` or appropriate navigation method to navigate to the page that displays match history (likely the Match Summary screen or a dedicated history view).\n\n4. **Implement 'Clear App Data' Functionality**: Create a comprehensive `clearAllAppData()` function that:\n   - Reviews all storage keys used by the application (including 'ACTIVE_MATCH_SESSION', any history storage, settings preferences)\n   - Clears in-memory data structures and state variables\n   - Removes all files from the filesystem if any are persisted\n   - Uses `hmFS.remove()` or similar APIs to delete files\n   - Uses storage clearing methods (e.g., `localStorage.removeItem()` or device-specific APIs)\n   - Logs confirmation of cleared data for debugging\n   - Returns to Home Screen after clearing\n   Add this function as the click handler for the 'Clear App Data' list item.",
        "testStrategy": "1. **Settings Page Display Test**: Launch the app and navigate to the Settings page. Verify the SCROLL_LIST widget displays correctly with both 'Previous Matches' and 'Clear App Data' items visible. Test scrolling behavior if the list is longer than the viewport.\n\n2. **Previous Matches Navigation Test**: Tap 'Previous Matches' in the Settings list. Verify the app navigates successfully to the history/match summary view. Confirm the correct history data is displayed. Test navigation back to Settings.\n\n3. **Clear App Data Functionality Test**:\n   - Start a new game and record some scores to ensure data exists in storage\n   - Navigate to Settings and tap 'Clear App Data'\n   - Verify that the action completes without errors\n   - Check that all app data has been cleared:\n     * Navigate to Home Screen - verify 'Resume Game' button is not shown (no saved match)\n     * Navigate to Previous Matches - verify no history is displayed\n     * If the app has settings/preferences, verify they are reset to defaults\n   - Attempt to navigate to game - verify the app requires new match setup\n\n4. **Home Screen Integration Test**: Verify the Home Screen no longer displays 'Previous Matches' and 'Clear App Data' buttons. Confirm the 'Settings' button is present and functional. Test that the Home Screen layout is balanced and no empty space or layout issues exist.\n\n5. **Edge Case Test**: Try to clear app data when the app is already empty. Verify no errors occur and the app remains stable.\n\n6. **Round and Square Screen Testing**: Verify the Settings page SCROLL_LIST displays correctly on both screen types, ensuring items are properly aligned and readable.",
        "status": "done",
        "dependencies": [
          "6",
          "11"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Settings page structure with SCROLL_LIST widget",
            "description": "Create the new Settings page directory and main page file with the SCROLL_LIST widget as the primary container, following Zepp UI design patterns.",
            "dependencies": [],
            "details": "Create a new page directory at `page/settings`. Create the `page/settings/index.js` file implementing the page lifecycle hooks (onInit, onReady, onDestroy). Add a SCROLL_LIST widget using hmUI.createWidget() following the Zepp SCROLL_LIST API documentation. Configure the list to display items with text labels and chevron indicators. Import the chevron-icon.png asset and ensure proper positioning. Test the page renders correctly on both round and square screen resolutions.",
            "status": "done",
            "testStrategy": "Launch the app and navigate to the Settings page. Verify the SCROLL_LIST widget displays correctly with the expected layout. Test scrolling behavior if the list exceeds viewport height.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:16.079Z"
          },
          {
            "id": 2,
            "title": "Implement SCROLL_LIST items for Previous Matches and Clear App Data",
            "description": "Configure the scrollable list with two menu items: Previous Matches with chevron icon, and Clear App Data with delete icon.",
            "dependencies": [
              1
            ],
            "details": "Define an array of list item objects containing text labels and icon paths for 'Previous Matches' (with chevron-icon.png) and 'Clear App Data' (with delete-icon.png). Use hmUI.createWidget() to add TEXT widgets for the labels and IMAGE widgets for the icons within each list item. Position elements to match the Zepp list template design with consistent padding and alignment. Ensure both items are properly clickable and have visual feedback when pressed.",
            "status": "done",
            "testStrategy": "Verify both 'Previous Matches' and 'Clear App Data' items are visible and correctly styled with their respective icons. Confirm items are visually distinct and aligned properly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.274Z"
          },
          {
            "id": 3,
            "title": "Implement Previous Matches navigation handler",
            "description": "Add click event handler for the Previous Matches list item that navigates to the match history view using hmUI.gotoPage().",
            "dependencies": [
              2
            ],
            "details": "Attach an event listener to the 'Previous Matches' list item widget using the click_event property. Implement the handler function to call hmUI.gotoPage() with the appropriate route to the match history page (likely 'page/match-summary' or similar). Ensure the navigation passes any necessary parameters such as the history data reference. Add logging for debugging to confirm navigation triggers correctly when the item is clicked.",
            "status": "done",
            "testStrategy": "Click the 'Previous Matches' item and verify it navigates to the match history view. Confirm the destination page loads correctly and displays expected data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.280Z"
          },
          {
            "id": 4,
            "title": "Implement clearAllAppData() function",
            "description": "Create a comprehensive function to clear all application data including storage, in-memory state, and persisted files.",
            "dependencies": [
              2
            ],
            "details": "Create the clearAllAppData() function that: 1) Identifies all storage keys used (ACTIVE_MATCH_SESSION, history storage, settings preferences), 2) Clears in-memory data structures and state variables by resetting them to initial values, 3) Iterates through persisted files and removes them using hmFS.remove(), 4) Uses localStorage.clear() or storage-specific APIs to clear all stored data, 5) Adds console.log statements to confirm each step completes successfully, 6) Returns true or false indicating success/failure. Place this function in a utils file or within the Settings page module.",
            "status": "done",
            "testStrategy": "Call clearAllAppData() and verify all storage keys are removed, state is reset, and files are deleted. Check console logs for confirmation messages.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.283Z"
          },
          {
            "id": 5,
            "title": "Connect Clear App Data click handler and navigate home",
            "description": "Attach the clearAllAppData() function to the Clear App Data list item and implement navigation back to Home Screen after clearing.",
            "dependencies": [
              4
            ],
            "details": "Attach an event listener to the 'Clear App Data' list item widget. Implement the click handler to call clearAllAppData() function. After successful data clearing, call hmUI.gotoPage() to navigate back to the Home Screen ('page/index'). Add a short delay or confirmation before navigation if needed. Include error handling to display an error message if clearing fails. Add visual feedback during the clearing operation if possible.",
            "status": "done",
            "testStrategy": "Click 'Clear App Data' and verify all app data is cleared. Confirm the app navigates back to the Home Screen automatically. Test error handling by simulating clearing failures.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.294Z"
          },
          {
            "id": 6,
            "title": "Remove Previous Matches and Clear App Data from Home Screen",
            "description": "Remove the navigation buttons and actions for Previous Matches and Clear App Data from the Home Screen since they are now in Settings.",
            "dependencies": [
              5
            ],
            "details": "Open the Home Screen file ('page/index.js'). Locate and remove the widgets or buttons that provide navigation to 'Previous Matches' and 'Clear App Data' functionality. Delete any associated event handlers for these removed buttons. Clean up any unused imports or variables related to these features. Ensure the Home Screen layout adjusts properly after removal (e.g., remaining buttons are centered or fill the space appropriately). Update any UI text or labels that reference these removed features.",
            "status": "done",
            "testStrategy": "Launch the app and verify the Home Screen no longer displays Previous Matches or Clear App Data buttons. Confirm the Home Screen layout remains clean and functional. Navigate to Settings to confirm these features are accessible from there.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.297Z"
          },
          {
            "id": 7,
            "title": "Add navigation entry point to Settings from Home Screen",
            "description": "Add a Settings button or menu item on the Home Screen to allow users to navigate to the new Settings page.",
            "dependencies": [
              1
            ],
            "details": "Add a Settings button or menu item to the Home Screen layout. This could be a small icon button (settings-icon.png), a text menu item, or integrated into an existing menu. Position the button appropriately (e.g., top corner, bottom area, or in a hamburger menu). Attach a click event handler that calls hmUI.gotoPage('page/settings') to navigate to the Settings page. Ensure the button is accessible and clearly labeled. Test the positioning on both round and square screen layouts.",
            "status": "done",
            "testStrategy": "Verify the Settings button is visible and accessible on the Home Screen. Click the button and confirm it navigates to the Settings page. Test positioning on both round and square screens.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.299Z"
          }
        ],
        "updatedAt": "2026-02-24T00:57:21.299Z"
      },
      {
        "id": "34",
        "title": "Home Screen UI Enhancements",
        "description": "Refine the Home Screen UI by removing unnecessary buttons, standardizing the size of action buttons, and adding a settings access button.",
        "details": "Update the Home Screen layout in `page/index` to remove the 'Previous Matches' and 'Clear App Data' buttons. Resize the 'Start New Game' and 'Resume Game' buttons to make them larger (increase height and padding) and ensure they have identical dimensions for visual consistency. Add a gear icon button positioned after the two main buttons. Implement click handler for the gear icon to navigate to the Settings page (`page/settings`). Apply design tokens for consistent spacing, colors, and icon sizing. Ensure the layout remains responsive and properly aligned on both Round and Square screen types. Maintain all existing functionality for the Start and Resume buttons.",
        "testStrategy": "Visual QA: Verify 'Previous Matches' and 'Clear App Data' buttons are completely removed from the Home Screen. Visual QA: Confirm 'Start New Game' and 'Resume Game' buttons are visibly larger than the previous implementation and have exactly matching dimensions. Functional Test: Tap the gear icon button and verify it successfully navigates to the Settings page. Visual QA: Verify the gear icon is properly positioned after the two main buttons with appropriate spacing. Responsive Test: Test on both Round and Square simulators to ensure buttons and icon do not overlap or get cut off. Regression Test: Verify 'Start New Game' clears storage and navigates correctly; verify 'Resume Game' restores state and navigates correctly. Verify conditional display of 'Resume Game' button still works based on saved match state.",
        "status": "done",
        "dependencies": [
          "6"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-24T00:31:18.393Z"
      },
      {
        "id": "35",
        "title": "General UI Enhancements - Navigation Icons and Background Refinements",
        "description": "Remove gray backgrounds from all page containers and update navigation buttons with appropriate icons across multiple screens. Implement swipe-right-to-close behavior on the home screen.",
        "details": "This task involves multiple UI refinements across different screens:\n\n1. **Remove Gray Backgrounds from All Pages**:\n   - Update `page/index` (Home Screen), `page/game` (Game Play Screen), Match Summary Screen, and Match History pages\n   - Locate container boxes/cards with gray background properties and remove or set to transparent\n   - Ensure text contrast and readability remains acceptable after background removal\n   - Apply consistent background styling across all screens\n\n2. **Replace Back to Home Buttons with House Icon Buttons (home-icon.png)**:\n   - In Game Play screen (`page/game`): Locate the 'Back to Home' button element and replace its text content with a house icon asset (home-icon.png)\n   - In Match Summary screen: Replace any 'Back to Home' text button with a house icon button\n   - Ensure both buttons maintain existing click handlers that navigate to home screen\n   - Style icon buttons with appropriate touch target sizes for usability\n\n3. **Replace Back Buttons with Return Icon Buttons**:\n   - In Match History List and Match History Detail pages: Locate 'Back' button elements\n   - Replace text with a return/back arrow icon (goback-icon.png)\n   - Verify navigation behavior remains unchanged (returns to previous page)\n\n4. **Implement Swipe Right to Close on Home Screen**:\n   - Add gesture event listener to `page/index` for swipe right detection\n   - On swipe right event, call Zepp OS app exit API (e.g., `app.exit()` or `wx.exitApp()`)\n   - Ensure this gesture only triggers on home screen and doesn't interfere with other screen interactions\n   - Test that app properly closes and returns to watchface\n\n5. **Testing and Verification**:\n   - Perform visual inspection on all affected screens\n   - Verify all navigation flows remain intact after button changes\n   - Test touch responsiveness of new icon buttons",
        "testStrategy": "1. Visual Test: Navigate to Home Screen and verify all gray backgrounds have been removed from containers\n2. Visual Test: Navigate to Game Play Screen and verify gray backgrounds are removed\n3. Functional Test: Tap the house icon button on Game Play Screen and verify it navigates to Home Screen\n4. Visual Test: Navigate to Match Summary Screen and verify gray backgrounds are removed\n5. Functional Test: Tap the house icon button on Match Summary Screen and verify it navigates to Home Screen\n6. Visual Test: Navigate to Match History List and verify back arrow icon is displayed instead of text\n7. Functional Test: Tap the return icon on Match History pages and verify it returns to the previous page\n8. Functional Test: On Home Screen, perform a swipe right gesture and verify the app closes and returns to watchface\n9. Regression Test: Verify scoring functionality and game flow still works correctly after UI changes\n10. Touch Target Test: Ensure all new icon buttons are easily tappable with appropriate touch response",
        "status": "pending",
        "dependencies": [
          "6",
          "7",
          "18",
          "22",
          "23"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "36",
        "title": "Delete Match from History",
        "description": "Implement functionality to delete individual matches from the match history by adding a bin icon alongside each history match entry in the match list.",
        "details": "Implement a delete mechanism for match history entries that allows users to remove specific completed matches. The implementation should:\n\n1. **UI Update - Add Delete Icon (delete-icon.png) to Match List**: Modify the existing match history list view (from Task 29) to include a trash/bin icon (delete-icon.png) button next to each match entry. The icon should be positioned on the right side of each history item and be easily tappable. (similar to this lists example: https://docs.zepp.com/docs/1.0/designs/template/list/ where the trash icon would be in the right side, in the place of the chevron)\n\n2. **Implement Delete Function**: Create a `deleteMatchFromHistory(matchId)` function that:\n   - Accepts the unique matchId of the match to delete\n   - Constructs the correct filename using the established pattern: `match_<matchId>.json`\n   - Uses the Zepp OS `hmFS` API to delete the file (e.g., `hmFS.removeAsset(path)`)\n   - Returns a boolean indicating success/failure\n   - Handles cases where the file doesn't exist gracefully\n\n3. **Handle Delete Action**: Add an event handler for the bin icon that:\n   - Calls `deleteMatchFromHistory()` with the appropriate matchId\n   - Shows a confirmation dialog (optional but recommended) before deletion to prevent accidental deletion\n   - Removes the item from the UI and refreshes the match history list\n   - Provides user feedback (e.g., toast message) confirming the deletion\n\n4. **Error Handling**: Implement proper error handling for:\n   - File system deletion failures\n   - Corrupted or missing history files\n   - Race conditions (if multiple deletions are triggered quickly)\n\n5. **UI Considerations**: Ensure the bin icon:\n   - Has adequate touch target size (at least 44x44 pixels)\n   - Uses appropriate styling (red color for delete action)\n   - Doesn't interfere with navigation to match details (if clicking on the match itself views details)",
        "testStrategy": "1. UI Visibility Test: Navigate to the match history list and verify that a bin icon appears next to each match entry.\n\n2. Delete Functionality Test: Click the bin icon on a history item, confirm the deletion (if confirmation dialog exists), and verify the match is immediately removed from the list.\n\n3. Persistence Test: Delete a match, then restart the watch/app and navigate back to match history. Verify the deleted match no longer appears in the list.\n\n4. File System Verification Test: After deleting a match through the UI, programmatically check the file system to ensure the corresponding `match_<id>.json` file has been removed.\n\n5. Multiple Deletion Test: Delete several matches in succession and verify the UI updates correctly after each deletion without crashes or glitches.\n\n6. Edge Case Test: Attempt to delete the last remaining match in history and verify the UI handles the empty state gracefully (e.g., shows 'No matches' message).\n\n7. Error Handling Test: Mock a file system deletion failure and verify appropriate user feedback is displayed without crashing the app.",
        "status": "pending",
        "dependencies": [
          "29"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "37",
        "title": "Cancel Ongoing Game",
        "description": "Implement a cancel game feature on the game play screen with a bin icon button that deletes the current active match state and navigates back to the home screen.",
        "details": "1. **UI Update - Add Cancel Button to Game Screen**: Modify the Game Screen to include a bin/trash icon button positioned alongside the existing home icon button. The icon should be clearly visible and tappable, using a standard trash icon asset.\n\n2. **Implement Cancel Handler**: Create an `cancelCurrentMatch()` function that handles the cancellation flow:\n   - Optionally display a confirmation dialog (e.g., 'Are you sure you want to cancel this match?') to prevent accidental cancellations\n   - Delete the persisted match state from storage by removing the 'ACTIVE_MATCH_SESSION' key using the persistence service (Task 12)\n   - Clear any in-memory state manager references to the active match\n   - Navigate to the Home Screen\n\n3. **Reuse Cleanup Logic**: Leverage or reference the cleanup pattern established in Task 19 (New Match Reset and Cleanup) to ensure consistency in how active sessions are terminated.\n\n4. **Error Handling**: Implement graceful handling for edge cases such as:\n   - Storage deletion failures\n   - Missing or corrupted match state\n   - Navigation errors\n\n5. **State Verification**: Ensure that after cancellation, the Home Screen properly recognizes that no active match exists and does not display the 'Resume Game' button.",
        "testStrategy": "1. **UI Visibility Test**: Navigate to the Game Screen and verify that a bin icon appears alongside the home icon button.\n\n2. **Basic Cancellation Test**: Start a new match, score a few points, then click the bin icon. Verify the game is cancelled and you are returned to the Home Screen.\n\n3. **State Cleanup Test**: After cancelling, verify that the 'Resume Game' button does NOT appear on the Home Screen, confirming the active match state was properly deleted.\n\n4. **Fresh Start Test**: Cancel an active game, then immediately start a new match. Verify the match starts fresh with scores at 0-0 and no data from the cancelled game.\n\n5. **Confirmation Dialog Test**: If a confirmation dialog is implemented, verify that clicking 'Cancel' or 'No' keeps the game running, while clicking 'Confirm' or 'Yes' proceeds with cancellation.\n\n6. **Edge Case Test**: Attempt to cancel at different game stages (just started, mid-match, near completion) and verify consistent behavior.\n\n7. **Storage Verification Test**: Use storage inspection tools to verify that the 'ACTIVE_MATCH_SESSION' key is removed after cancellation.",
        "status": "pending",
        "dependencies": [
          "12",
          "19"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "38",
        "title": "Implement Multi-Language Support for Portuguese and Spanish",
        "description": "Add comprehensive multi-language support for Portuguese and Spanish with automatic device language detection and English fallback, including translation of all UI text strings across the application.",
        "details": "Implement a localization system for the Padel scoring app with the following components:\n\n1. **Translation Infrastructure**: Create a `LocalizationService` module that manages language resources. Define a translation dictionary structure containing key-value pairs for all UI text in the app (English, Portuguese, Spanish). Store translations in JSON files or objects organized by language code (en, pt, es).\n\n2. **Language Detection**: Implement automatic language detection using Zepp OS device settings API (e.g., `hmSystem.getDeviceInfo().language` or similar). Parse the device language code and map it to supported languages:\n   - 'pt' or 'pt-PT' or 'pt-BR'  Portuguese\n   - 'es' or 'es-ES'  Spanish\n   - Any other  English (default/fallback)\n\n3. **Translation Keys**: Identify all text strings in the application that need translation:\n   - Home Screen: 'Resume Game', 'New Game', 'Previous Matches'\n   - Setup Screen: 'Match Setup', '1 Set', '3 Sets', '5 Sets', instructions\n   - Game Screen: Score labels, team names, 'Undo' button\n   - Summary Screen: 'Team A Wins', 'Set 1:', 'Home', 'Start New Game'\n   - History Screen: 'Previous Matches', date/time formats, delete confirmation\n   - General: 'Confirm', 'Cancel', 'Back', any toast messages or alerts\n\n4. **Translation Function**: Create a `t(key, params)` function that:\n   - Takes a translation key and optional parameters for dynamic values\n   - Returns the translated string based on current language\n   - Falls back to English if key is missing in target language\n   - Handles parameter interpolation (e.g., 'Team {name} Wins')\n\n5. **Language Persistence**: Store the selected/detected language in settings storage using the persistence service from Task 12. This allows manual language override (if needed) and consistent behavior across app restarts.\n\n6. **UI Integration**: Update all UI components to use the translation function instead of hardcoded strings. This includes:\n   - Screen titles and labels\n   - Button text\n   - Status messages and toasts\n   - Date/time formatting (may need locale-specific formatting)\n\n7. **Implementation Structure**:\n   ```javascript\n   // translations/en.json, translations/pt.json, translations/es.json\n   {\n     \"home.resumeGame\": \"Resume Game\",\n     \"home.newGame\": \"New Game\",\n     \"setup.title\": \"Match Setup\",\n     \"setup.sets\": \"Sets\",\n     \"summary.teamWins\": \"Team {team} Wins\",\n     ...\n   }\n   \n   // LocalizationService.js\n   class LocalizationService {\n     constructor() {\n       this.currentLang = this.detectLanguage();\n       this.translations = this.loadTranslations(this.currentLang);\n     }\n     \n     detectLanguage() {\n       const deviceLang = hmSystem.getDeviceInfo().language || 'en';\n       if (deviceLang.startsWith('pt')) return 'pt';\n       if (deviceLang.startsWith('es')) return 'es';\n       return 'en';\n     }\n     \n     t(key, params = {}) {\n       let text = this.translations[key] || this.english[key] || key;\n       Object.keys(params).forEach(param => {\n         text = text.replace(`{${param}}`, params[param]);\n       });\n       return text;\n     }\n   }\n   ```",
        "testStrategy": "1. **Language Detection Test**: Change device language settings to Portuguese and launch the app. Verify all UI text displays in Portuguese. Repeat for Spanish. Test with unsupported languages (e.g., German, French) and verify English is used as fallback.\n\n2. **Translation Coverage Test**: Navigate through all screens (Home, Setup, Game, Summary, History) and verify every text element is properly translated. Check for any missing translations or English fallbacks where they shouldn't be.\n\n3. **Persistence Test**: Set device language to Spanish, launch the app, then restart. Verify Spanish is maintained after restart. Change device language to Portuguese and verify the app updates on next launch.\n\n4. **Parameter Interpolation Test**: Complete a match and verify dynamic text like 'Team A Wins' displays correctly in all three languages. Check date/time formatting in the history list for proper locale formatting.\n\n5. **Edge Case Test**: Test with partial locale codes (e.g., 'pt' without country) and verify it correctly maps to Portuguese. Ensure no crashes or errors occur if translation files are missing keys.\n\n6. **Visual QA**: Take screenshots of all screens in English, Portuguese, and Spanish to verify text fits properly within UI elements and doesn't cause layout issues or text overflow.",
        "status": "pending",
        "dependencies": [
          "13",
          "17",
          "18",
          "29"
        ],
        "priority": "medium",
        "subtasks": []
      },
      {
        "id": "39",
        "title": "Implement Release and Changelog Generation with GitHub Actions",
        "description": "Research and implement an automated release and changelog generation system using GitHub Actions with semantic-release and conventional commits. This task enables automated versioning, changelog creation, and GitHub releases triggered by the npm run release command.",
        "details": "Implement a comprehensive release automation system using the conventional-commits and semantic-release approach, similar to the reference implementation at https://github.com/trystan2k/publish-blog-post/. The implementation includes:\n\n1. **Install and Configure Dependencies**:\n   - Install `semantic-release` and related plugins (`@semantic-release/git`, `@semantic-release/changelog`, `@semantic-release/npm`, `@semantic-release/github`)\n   - Configure `.releaserc` or `release.config.js` with appropriate settings for the Zepp OS/JavaScript project\n\n2. **Configure package.json Scripts**:\n   - Add `\"release\": \"semantic-release\"` script to package.json\n   - Ensure `version` field is managed by semantic-release (set to a placeholder like `0.0.0-semantically-released`)\n\n3. **Create GitHub Actions Workflow**:\n   - Create `.github/workflows/release.yml` workflow file\n   - Configure trigger: `on:\n  push:\n    tags:\n      - 'v*'`\n   - Set up job steps:\n     - Checkout code\n     - Setup Node.js environment\n     - Install dependencies\n     - Run semantic-release (which will create the GitHub release)\n\n4. **Configure Conventional Commits**:\n   - Add `commitlint` configuration to enforce conventional commit format\n   - Configure supported commit types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`, `revert`\n   - Set up pre-commit hooks or CI checks to validate commit messages\n\n5. **Release Process Flow**:\n   - Developer runs `npm run release` locally or pushes commits with conventional commit messages\n   - Semantic-release analyzes commit history since last release\n   - Determines next version number based on commit types (major for breaking changes, minor for features, patch for fixes)\n   - Generates changelog from commit messages\n   - Creates git tag with version number\n   - Pushes changes to repository\n   - GitHub Actions workflow detects new tag and creates GitHub release with changelog\n\n6. **Changelog Configuration**:\n   - Configure changelog format and sections\n   - Include link to commit comparison in generated changelog\n   - Store changelog in `CHANGELOG.md` file\n\n7. **Branch Protection (Recommended)**:\n   - Configure main branch to require pull request reviews\n   - Enable status checks for conventional commit validation",
        "testStrategy": "1. **Local Script Test**: Run `npm run release` locally on the main branch. Verify the script executes without errors and provides appropriate output (e.g., 'no release needed' if no changes).\n\n2. **Conventional Commit Validation Test**: Create commits with various formats:\n   - Valid: `feat: add new scoring logic`\n   - Valid: `fix: resolve crash on game start`\n   - Valid: `feat(match-history): implement storage`\n   - Invalid: `add new feature` (should fail validation if commitlint is configured)\n   Verify that valid commits pass and invalid commits are rejected.\n\n3. **Version Bump Test**: Create a series of commits:\n   - `feat: add feature A`\n   - `fix: minor bug fix`\n   Push to main and trigger release. Verify version increments to `1.0.0` (from initial). Then:\n   - `feat: add feature B`  verify version bumps to `1.1.0`\n   - `fix: resolve bug`  verify version bumps to `1.1.1`\n   - `feat!: breaking change`  verify version bumps to `2.0.0`\n\n4. **Changelog Generation Test**: After triggering a release, verify that:\n   - `CHANGELOG.md` is updated with new version section\n   - Changelog includes proper categorization (Features, Bug Fixes, etc.)\n   - Commit messages are properly formatted in the changelog\n   - Links to commits and comparisons are included\n\n5. **GitHub Release Test**: Verify that:\n   - Git tags are created with correct version format (v1.0.0)\n   - GitHub Actions workflow triggers on tag push\n   - GitHub Release is created with:\n     - Correct version tag\n     - Changelog as release notes\n     - Proper release title\n\n6. **No Release Scenario Test**: Make a commit with type `chore:` or `docs:` that doesn't trigger a release. Run `npm run release` and verify no new release is created and the version remains unchanged.\n\n7. **End-to-End Integration Test**: Complete the full flow:\n   - Create a feature branch with a conventional commit\n   - Create PR and merge to main\n   - Run `npm run release` locally or via CI\n   - Verify tag is pushed and GitHub Release is created automatically\n   - Verify project version in package.json is updated",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-24T00:57:21.299Z",
      "taskCount": 39,
      "completedCount": 33,
      "tags": [
        "master"
      ]
    }
  }
}