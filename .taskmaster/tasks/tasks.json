{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Project Initialization & Configuration",
        "description": "Set up the Zepp OS project structure, configuration files, and base directories.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Initialize a new Zepp OS Mini Program project. Configure `app.json` with the project ID, version, and necessary permissions (e.g., storage). Set up the folder structure (pages, utils, assets). Ensure the project is configured to support both round and square screen resolutions by defining viewport settings or using responsive units (px/rpx).",
        "testStrategy": "Verify the project compiles successfully using the Zepp developer tools. Confirm that the app launches on the simulator (round and square) without crashing and displays a blank page or default index.",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Zepp OS Project and Directory Structure",
            "description": "Create the base project using the CLI and establish the folder scaffolding.",
            "dependencies": [],
            "details": "Execute the Zepp OS project initialization command to generate the boilerplate. Manually create the required directory structure including folders for 'pages', 'utils', and 'assets' to organize the codebase.",
            "status": "done",
            "testStrategy": "Verify that the project command executes without errors and all required folders exist in the file system.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.785Z"
          },
          {
            "id": 2,
            "title": "Configure Core App Metadata in app.json",
            "description": "Set the project identification and version information in the configuration file.",
            "dependencies": [
              1
            ],
            "details": "Edit the root `app.json` file to input the correct `appId`, `versionName`, `versionCode`, and `appName`. Ensure the JSON syntax is valid to prevent build errors.",
            "status": "done",
            "testStrategy": "Validate the JSON structure using a linter or the Zepp developer tools to ensure no syntax errors exist.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.791Z"
          },
          {
            "id": 3,
            "title": "Define Storage Permissions in app.json",
            "description": "Configure necessary permissions for local data access.",
            "dependencies": [
              2
            ],
            "details": "Add the appropriate permission keys to `app.json` to enable access to `storage` APIs. This is required for the subsequent implementation of local state persistence.",
            "status": "done",
            "testStrategy": "Review the configuration file to confirm permission keys are present and formatted according to Zepp OS documentation.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.794Z"
          },
          {
            "id": 4,
            "title": "Set Viewport Configuration for Round Screens",
            "description": "Configure the project settings to support circular screen resolutions.",
            "dependencies": [
              2
            ],
            "details": "Update the `app.json` or global configuration files to define the `designWidth` and viewport settings specifically tailored for round screen devices (e.g., 454px). Configure the design system to handle circular clipping zones.",
            "status": "done",
            "testStrategy": "Deploy the project to a round screen simulator and verify that the default page renders within the circular bounds without overflow.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.795Z"
          },
          {
            "id": 5,
            "title": "Set Viewport Configuration for Square Screens and Responsive Units",
            "description": "Ensure compatibility with square screens and implement responsive units.",
            "dependencies": [
              4
            ],
            "details": "Adjust configuration to support square screen resolutions. Enforce the use of responsive units (px/rpx) in the global settings or style guide to ensure layouts scale correctly across both round and square form factors.",
            "status": "done",
            "testStrategy": "Deploy to a square screen simulator. Verify elements are positioned correctly and that the layout adapts without distortion compared to the round screen view.",
            "parentId": "1",
            "updatedAt": "2026-02-20T07:17:14.797Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break this task down into subtasks covering: 1) Project creation and folder scaffolding, 2) Configuration of app.json (permissions, project ID), and 3) Viewport setup for round and square screens.",
        "updatedAt": "2026-02-20T07:17:14.797Z"
      },
      {
        "id": "2",
        "title": "Data Model & State Management Design",
        "description": "Define the data structures for the game state, scoring history, and team configurations.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create JavaScript/TypeScript interfaces for `MatchState` including: Team A/B scores (points, games), current set status, and match status (active/finished). Implement a history stack structure to store past states for the Undo functionality (as per 'Option 2' state machine approach). Define constants for scoring sequences (0, 15, 30, 40, Ad, Game).",
        "testStrategy": "Unit tests to verify that the state object initializes correctly with zero values and that the history stack can push and pop deep copies of the state without reference errors.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interfaces for Game Entities",
            "description": "Create TypeScript interfaces for MatchState, Team configurations, and status enumerations to type-check the game data.",
            "dependencies": [],
            "details": "Define `MatchState` interface including properties for Team A/B scores (points, games), current set status, and match status (active/finished). Create supporting types for TeamScore if necessary.",
            "status": "done",
            "testStrategy": "Unit tests to verify interfaces compile correctly and accept valid data shapes for match initialization.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:11.492Z"
          },
          {
            "id": 2,
            "title": "Implement History Stack with Deep Copy Logic",
            "description": "Develop the history stack data structure required for the Undo functionality, ensuring immutability via deep copying.",
            "dependencies": [
              1
            ],
            "details": "Implement a stack class or module with `push(state)` and `pop()` methods. Integrate deep copy logic (e.g., using JSON.parse(JSON.stringify()) or a utility library) to ensure stored states are independent snapshots.",
            "status": "done",
            "testStrategy": "Unit tests to verify that pushing a state and modifying the original does not affect the stored history, and that pop correctly restores previous states.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:13.045Z"
          },
          {
            "id": 3,
            "title": "Define Scoring Constants and Enumerations",
            "description": "Establish the standard scoring sequences and domain constants used throughout the scoring logic.",
            "dependencies": [],
            "details": "Define constants for the scoring sequence (0, 15, 30, 40, Ad, Game). Create enumerations for game phases or specific states to ensure type safety in the scoring engine.",
            "status": "done",
            "testStrategy": "Validation to ensure constant values match standard Padel/Tennis scoring rules and are accessible for import by other modules.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T13:23:14.673Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Defining TypeScript interfaces for MatchState and related entities, 2) Implementing the history stack structure with deep copy logic, and 3) Defining scoring constants and enumerations.",
        "updatedAt": "2026-02-20T13:23:14.673Z"
      },
      {
        "id": "3",
        "title": "Local Storage & Persistence Layer",
        "description": "Implement the mechanism to save and load the game state using the device's local storage.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Utilize Zepp OS `settingsStorage` API to persist the `MatchState` object as a JSON string. Implement `saveState(state)` and `loadState()` functions. Ensure data is serialized correctly and handle potential JSON parsing errors. The load function should return `null` if no saved game exists.",
        "testStrategy": "Manually save a state, restart the app/simulator, and verify the data is retrieved accurately. Test with invalid/corrupted storage data to ensure the app handles it gracefully (e.g., defaults to new game).",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement saveState function with JSON serialization",
            "description": "Create the saveState function to serialize the MatchState object into a JSON string and persist it using the Zepp OS settingsStorage API.",
            "dependencies": [],
            "details": "Implement the `saveState(state)` function. This function takes a `MatchState` object as input, serializes it using `JSON.stringify()`, and saves the resulting string to a specific key in the Zepp OS `settingsStorage`.",
            "status": "done",
            "testStrategy": "Test by calling the function with a valid MatchState object and verifying the data is written to storage. Ensure valid JSON stringification.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.978Z"
          },
          {
            "id": 2,
            "title": "Implement loadState function with error handling",
            "description": "Create the loadState function to retrieve and parse the game state, including robust error handling for missing or corrupted data.",
            "dependencies": [],
            "details": "Implement the `loadState()` function. Retrieve the raw string from `settingsStorage` using the defined key. Parse the string using `JSON.parse()` inside a try-catch block. Handle potential errors by returning `null` if data is missing or if parsing fails.",
            "status": "done",
            "testStrategy": "Test scenarios: empty storage (expect null), valid storage (expect state object), and corrupted JSON string (expect null without crashing).",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T14:42:51.982Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Implementing the saveState function with JSON serialization, and 2) Implementing the loadState function with error handling and null checks.",
        "updatedAt": "2026-02-20T14:42:51.982Z"
      },
      {
        "id": "4",
        "title": "Padel Scoring Logic Engine",
        "description": "Develop the core state machine logic for handling points, games, sets, and tie-breaks.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "details": "Implement the `addPoint(team)` function. Logic must handle: standard progression (0->15->30->40->Game), Deuce/Advantage rules (40-40 -> Ad -> Game or Deuce), and Game/Set increments. Implement Set logic: win at 6 games (margin of 2) or Tie-break at 6-6 (first to 7, margin of 2). Every state change must be pushed to the history stack before updating the current state to support Undo.",
        "testStrategy": "Write test cases for standard scoring, deuce scenarios (winning/losing from advantage), set wins (6-0, 6-4), and tie-break entry (6-6). Validate that the history stack grows with every point.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement standard point progression logic",
            "description": "Create the basic logic to handle point increments from 0 to 15, 30, 40, and Game for a winning team.",
            "dependencies": [],
            "details": "Define the mapping of internal point counters (0, 1, 2, 3) to display strings ('0', '15', '30', '40'). In the `addPoint(team)` function, increment the team's point counter. If the team reaches 4 points and the opponent has 3 or fewer points, award the Game.",
            "status": "done",
            "testStrategy": "Verify that calling `addPoint` updates the score from '0' to '15', '30', '40', and finally results in a Game win when the opponent is below 40.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.081Z"
          },
          {
            "id": 2,
            "title": "Implement deuce and advantage state handling",
            "description": "Develop logic to manage the 40-40 (Deuce) state and the subsequent Advantage transitions.",
            "dependencies": [
              1
            ],
            "details": "Modify `addPoint` to detect when both teams reach 3 points (40-40). If scores are equal (3-3) or higher and equal, the next point puts the scorer at 'Advantage'. If a team is at 'Advantage' and scores, they win the Game. If they lose the point, revert to 'Deuce'.",
            "status": "done",
            "testStrategy": "Test scenarios reaching 40-40, winning a point to get Advantage, and then both winning and losing the subsequent point to ensure correct Game or Deuce results.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.083Z"
          },
          {
            "id": 3,
            "title": "Implement game counting and set win conditions",
            "description": "Handle game score increments within a set and determine when a set is won based on game margins.",
            "dependencies": [
              2
            ],
            "details": "When a Game is won (from Task 1 or 2), increment the game counter for the winning team and reset points. Check set win conditions: A team wins the set if they reach 6 games and lead by at least 2 games (e.g., 6-4, 6-3, 6-0). Handle the transition to a new set or match end.",
            "status": "done",
            "testStrategy": "Test game progression to 6-0, 6-4. Verify that a score of 6-5 does not end the set. Confirm that reaching 7-5 (if allowed by logic flow) ends the set.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.085Z"
          },
          {
            "id": 4,
            "title": "Implement tie-break logic",
            "description": "Develop the specific scoring rules for a tie-break game triggered at a 6-6 game score.",
            "dependencies": [
              3
            ],
            "details": "Detect when the set score reaches 6-6. Switch to tie-break mode where points are counted as 1, 2, 3, etc., instead of 15/30/40. The first team to reach 7 points wins the tie-break and the set, provided they have a margin of at least 2 points (e.g., 7-5, 8-6). Reset points/games correctly upon completion.",
            "status": "done",
            "testStrategy": "Simulate a 6-6 set score. Verify tie-break points increment numerically. Test winning scenarios at 7-0, 7-5, and 8-6. Ensure the set concludes correctly upon winning the tie-break.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.086Z"
          },
          {
            "id": 5,
            "title": "Integrate history stack for state changes",
            "description": "Implement the mechanism to push deep copies of the state to the history stack before any score update.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "At the beginning of the `addPoint(team)` function, create a deep copy of the current match state object. Push this copy onto the `historyStack` array. This ensures that every modification to points, games, sets, or tie-break status is captured to support the Undo functionality.",
            "status": "done",
            "testStrategy": "Verify that the history stack length increases by exactly 1 for every point added. Check that popping the history restores the exact previous state without reference issues.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T15:35:54.087Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break down into: 1) Standard point progression logic (0-15-30-40-Game), 2) Deuce and Advantage state handling, 3) Game counting and set win conditions, 4) Tie-break logic implementation, and 5) Integration of history stack pushing on every state change.",
        "updatedAt": "2026-02-20T15:35:54.087Z"
      },
      {
        "id": "5",
        "title": "Undo & Remove Point Logic",
        "description": "Implement the logic to reverse the last score action using the history stack.",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "details": "Implement `removePoint()` function. This function should pop the previous state from the history stack and set it as the current state. If the history is empty or score is at start (0-0, 0-0), the function should be a no-op. Ensure this effectively restores game points, set scores, and tie-break statuses.",
        "testStrategy": "Verify that pressing Undo after scoring reverts the score exactly to the previous state. Test rapid Undo presses until the score reaches 0-0 and ensure no errors occur or negative scores appear.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement removePoint() core logic in scoring engine",
            "description": "Implement the removePoint() function in the scoring engine to handle state restoration from the history stack.",
            "dependencies": [],
            "details": "Create or update utils/scoring-engine.js to include removePoint(). The function must: 1) Check if history is empty or state is initial (0-0, 0-0) -> return no-op, 2) Pop previous state from utils/history-stack.js, 3) Restore the popped state as current match state, 4) Ensure all fields (points, games, sets, tie-break status) are restored. Import historyStack and popState from utils/history-stack.js.",
            "status": "done",
            "testStrategy": "Write unit tests for single undo, multiple rapid undos, edge cases (empty history), and state integrity validation.",
            "metadata": {
              "files": [
                "utils/scoring-engine.js"
              ],
              "complexity": 2,
              "testCommand": "npm test -- scoring-engine.test.js"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:25:59.786Z"
          },
          {
            "id": 2,
            "title": "Create comprehensive unit tests for removePoint functionality",
            "description": "Write unit tests to verify the removePoint() function handles all scoring scenarios correctly.",
            "dependencies": [
              1
            ],
            "details": "Add test cases to tests/scoring-engine.test.js or create tests/remove-point.test.js. Cover: 1) Single undo after a point, 2) Multiple undos until initial state (0-0, 0-0), 3) Verify no-op when history is empty, 4) Verify no-op when already at initial state, 5) Ensure undo never produces negative scores or invalid transitions. Use createHistoryStack from utils/history-stack.js to mock history state.",
            "status": "done",
            "testStrategy": "Execute the test runner to ensure all test cases pass, including edge cases and rapid undo sequences.",
            "metadata": {
              "files": [
                "tests/scoring-engine.test.js",
                "tests/remove-point.test.js"
              ],
              "complexity": 2,
              "testCommand": "npm test"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:01.549Z"
          },
          {
            "id": 3,
            "title": "Integrate Undo action in app and UI layer",
            "description": "Wire up the removePoint() function to the UI layer and expose it as an action.",
            "dependencies": [
              1
            ],
            "details": "Update app.js and page/index.js. Expose a public removePoint action that calls the scoring engine function. If an Undo button exists in page/index.js UI, bind the handler to this action. Add an integration test or runtime check to verify the app's global state updates correctly after Undo is triggered, reflecting the restored state in the UI.",
            "status": "done",
            "testStrategy": "Manual test on Zepp OS simulator: click a point, then click Undo, verify UI reverts. Automated integration test to check global state restoration.",
            "metadata": {
              "files": [
                "app.js",
                "page/index.js"
              ],
              "complexity": 1,
              "testCommand": "npm run test:integration"
            },
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:26:03.053Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 1,
        "expansionPrompt": "Create a subtask to implement the removePoint function, focusing on popping from history, validation checks (empty stack), and state restoration.",
        "updatedAt": "2026-02-20T16:26:03.053Z"
      },
      {
        "id": "6",
        "title": "Home Screen UI Implementation",
        "description": "Build the Home Screen with Start and Resume functionality based on the design reference.",
        "status": "done",
        "dependencies": [
          "1",
          "3"
        ],
        "priority": "medium",
        "details": "Create `page/index` using Zepp UI components. Implement the App Title/Logo. Add 'Start New Game' and 'Resume Game' buttons. Use the `loadState` result to conditionally render the 'Resume Game' button (only if a saved game exists). Apply design tokens (colors, fonts) from the Lovable reference.",
        "testStrategy": "UI Test: Verify button placement and text match the 'Game Start' design. Functional Test: With no data, only 'Start' is shown. With data, both are shown. Clicking 'Start' clears storage and navigates. Clicking 'Resume' navigates without clearing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Home Page Structure and App Title/Logo",
            "description": "Initialize the `page/index` file and implement the static visual elements including the App Title and Logo using Zepp UI components.",
            "dependencies": [],
            "details": "Create the `page/index` file structure. Implement the App Title and Logo widgets. Apply the design tokens (colors, fonts) from the Lovable reference to ensure visual consistency with the design spec.",
            "status": "done",
            "testStrategy": "Visual inspection to ensure the App Title and Logo match the 'Game Start' design reference and the layout is correctly centered.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:49:04.579Z"
          },
          {
            "id": 2,
            "title": "Implement Start New Game Button and Logic",
            "description": "Add the 'Start New Game' button to the interface and configure the logic to clear storage and navigate to the game screen.",
            "dependencies": [
              1
            ],
            "details": "Add the 'Start New Game' button component to the layout. Implement the click event handler to clear any saved game state and navigate the user to the game page (`page/game`).",
            "status": "done",
            "testStrategy": "Functional test to verify clicking 'Start New Game' clears any existing storage and navigates correctly to the game screen.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T16:52:38.735Z"
          },
          {
            "id": 3,
            "title": "Implement Conditional Resume Game Button and Data Fetching",
            "description": "Integrate data fetching to check for saved games and conditionally render the 'Resume Game' button based on the result.",
            "dependencies": [
              2
            ],
            "details": "Use the `loadState` function to check for a saved game state. Conditionally render the 'Resume Game' button only if data exists. Implement the click handler to navigate using the loaded state without clearing it.",
            "status": "done",
            "testStrategy": "Functional test verifying the button only appears when saved data exists, and clicking it loads the specific state and navigates correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T17:12:16.550Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1) Creating the basic page structure and adding App Title/Logo, 2) Implementing the 'Start New Game' button and logic, and 3) Implementing the conditional 'Resume Game' button and data fetching.",
        "updatedAt": "2026-02-20T17:12:16.550Z"
      },
      {
        "id": "7",
        "title": "Game Screen Layout Construction",
        "description": "Create the layout for the Game Screen displaying scores and control buttons.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "medium",
        "details": "Create `page/game`. Layout the top section for Set Scores (Games won) and the middle section for Current Game Points (0, 15, 30...). Ensure high contrast and large typography for readability. Place Team A and Team B action buttons (Add/Remove) at the bottom. Ensure layout adapts to Round vs Square screens using relative positioning or flexbox.",
        "testStrategy": "Visual inspection on Round and Square simulators to ensure elements do not overlap or get cut off. Verify text size is readable as per accessibility requirements.",
        "subtasks": [
          {
            "id": 1,
            "title": "Layout Set Score Section",
            "description": "Create the top section UI to display Set Scores (games won) for both teams.",
            "dependencies": [],
            "details": "Construct the top container in `page/game` to show Team A and Team B Set Scores. Use flexbox or relative positioning for alignment and apply high contrast colors for readability.",
            "status": "done",
            "testStrategy": "Inspect layout on simulator to ensure scores are positioned at the top and legible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.009Z"
          },
          {
            "id": 2,
            "title": "Layout Current Game Point Section",
            "description": "Create the middle section UI displaying current game points (0, 15, 30, etc.) with large, readable typography.",
            "dependencies": [
              1
            ],
            "details": "Implement the middle container in `page/game` for Current Game Points. Define large typography styles for visibility. Ensure high contrast text is used for the point values.",
            "status": "done",
            "testStrategy": "Verify text size is sufficient for readability and contrast meets accessibility standards.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.011Z"
          },
          {
            "id": 3,
            "title": "Layout Control Buttons and Responsive Adaptation",
            "description": "Create bottom control buttons for scoring and ensure the full layout is responsive for Round and Square screens.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add Team A and Team B action buttons (Add/Remove) at the bottom of `page/game`. Apply responsive layout logic (flexbox/relative) to ensure elements fit correctly on both Round and Square screen shapes without overlap.",
            "status": "done",
            "testStrategy": "Visual inspection on Round and Square simulators. Ensure no elements are cut off and buttons are accessible.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:09:24.012Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Split into: 1) Layout of the Set Score section (top), 2) Layout of the Current Game Point section (middle) with large typography, and 3) Layout of control buttons (bottom) and responsive adaptation for Round/Square screens.",
        "updatedAt": "2026-02-20T18:09:24.012Z"
      },
      {
        "id": "8",
        "title": "Game Screen Interaction & Binding",
        "description": "Connect the UI buttons to the Scoring Logic and update the view dynamically.",
        "status": "done",
        "dependencies": [
          "4",
          "5",
          "7"
        ],
        "priority": "high",
        "details": "Bind the 'Add Point' (+) and 'Remove Point' (-) buttons for both teams to the logic engine. On click: 1. Execute logic, 2. Update the UI state (re-render or update text widgets), 3. Trigger `saveState`. Ensure the UI updates within 100ms of the tap.",
        "testStrategy": "Integration test: Tap buttons and observe UI changes immediately. Verify that adding a point updates the Game Point score, and winning a game updates the Set Score. Verify persistence by closing and reopening the app.",
        "subtasks": [
          {
            "id": 1,
            "title": "Bind Game Controls to Scoring Logic",
            "description": "Attach click event listeners to the UI buttons (+/-) and invoke the scoring logic to update the game state.",
            "dependencies": [],
            "details": "Implement event handlers for Team A and Team B 'Add Point' and 'Remove Point' buttons defined in Task 7. On click, invoke the scoring engine functions (from Task 4/5) to calculate the new score. Update the specific UI widgets (Text/Score views) immediately after logic execution to reflect the new state.",
            "status": "done",
            "testStrategy": "Unit/Manual test: Click buttons and verify the displayed score changes correctly according to tennis rules. Check that removing points works correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:04.475Z"
          },
          {
            "id": 2,
            "title": "Implement Auto-Save and Performance Verification",
            "description": "Integrate state persistence into the click handlers and ensure UI rendering meets latency requirements.",
            "dependencies": [
              1
            ],
            "details": "Call `saveState` (from Task 3) within the button click handlers immediately after logic execution and UI update. Implement or verify logic to measure rendering latency from tap to screen update. Optimize the update loop if necessary to guarantee the UI updates within the 100ms requirement.",
            "status": "done",
            "testStrategy": "Performance test: Use console logging or profiling tools to ensure time delta between event trigger and UI paint is < 100ms. Persistence test: Close and reopen app to verify the last state is saved correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T18:47:05.999Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Expand into: 1) Binding Add/Remove buttons to the logic engine and triggering state updates, and 2) Implementing auto-save on state change and verifying UI update latency.",
        "updatedAt": "2026-02-20T18:47:05.999Z"
      },
      {
        "id": "9",
        "title": "Navigation & Lifecycle Handling",
        "description": "Manage navigation between screens and handle app backgrounding/foregrounding events.",
        "status": "done",
        "dependencies": [
          "6",
          "8"
        ],
        "priority": "medium",
        "details": "Implement the 'Back/Home' button logic in the Game Screen to return to the Home Screen. Add event listeners for lifecycle events (e.g., `app.on('pause')` or page hide events) to trigger `saveState` automatically, ensuring no data is lost if the user receives a call or locks the screen.",
        "testStrategy": "Navigate from Game to Home and verify save is triggered. Background the app while in a game state (simulate via tools or OS gesture) and foreground it to verify the state persists exactly as left.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Game Screen Back/Home Navigation",
            "description": "Configure the Back/Home button on the Game Screen to navigate to the Home Screen and trigger state saving.",
            "dependencies": [],
            "details": "Modify `pages/game` to handle navigation events. Implement a click handler for the Back/Home widget that first invokes `saveState()` to persist the current game score, then executes a navigation command (e.g., `router.replace` or `router.push`) to route the user back to `pages/index` (Home Screen). Ensure the transition is smooth.",
            "status": "done",
            "testStrategy": "Functional Test: Start a game session and modify the score. Tap the Back/Home button. Verify the app transitions to the Home Screen. Then, tap 'Resume Game' and verify the game state (scores) matches exactly what it was before navigation.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:27.026Z"
          },
          {
            "id": 2,
            "title": "Add Lifecycle Event Listeners for Auto-Save",
            "description": "Implement event listeners for app pause and visibility changes to automatically save the game state, preventing data loss during interruptions.",
            "dependencies": [],
            "details": "Integrate Zepp OS lifecycle event handling (e.g., `app.on('pause')` or page visibility events) within the app lifecycle or Game Screen controller. When a 'pause' or 'hide' event is detected (simulating a phone call or screen lock), automatically trigger the `saveState()` function. Ensure this happens synchronously or reliably before the app fully suspends to guarantee data integrity.",
            "status": "done",
            "testStrategy": "Lifecycle Test: Start a game and change the score. Simulate an interruption by backgrounding the app (using OS gesture or simulator tool) or triggering a 'pause' event. Foreground the app and verify the game resumes with the exact score. Verify storage to confirm data was written at the moment of pause.",
            "parentId": "undefined",
            "updatedAt": "2026-02-20T21:30:28.703Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Break into: 1) Implementing navigation logic (Back/Home button) and 2) Adding lifecycle event listeners (pause/hide) for automatic state persistence.",
        "updatedAt": "2026-02-20T21:30:28.703Z"
      },
      {
        "id": "10",
        "title": "Styling Refinement, Input Debouncing & Polish",
        "description": "Apply final design styles, implement input debouncing, and optimize performance.",
        "status": "done",
        "dependencies": [
          "9"
        ],
        "priority": "low",
        "details": "Refine the UI to strictly match the Lovable design (Game Finish, Score colors, button styles). Implement a debounce mechanism (e.g., ignore input for 300ms after a valid tap) on scoring buttons to prevent double-tap errors. Ensure touch targets are large enough (min 48px) for sports usage.",
        "testStrategy": "Perform rapid tapping tests to ensure debounce prevents double scoring. Conduct a final design audit against the provided images. Measure UI update latency to ensure <100ms compliance.",
        "subtasks": [
          {
            "id": 1,
            "title": "Apply Final Design Styles and Accessibility",
            "description": "Refine the UI to strictly match the Lovable design specifications, including the Game Finish screen, score colors, and button styles. Ensure all interactive elements meet accessibility standards with a minimum touch target size of 48px suitable for sports usage.",
            "dependencies": [],
            "details": "Update styling tokens and component properties to align with the 'Game Finish' and gameplay designs. Verify contrast ratios and implement layout adjustments to guarantee touch targets are at least 48x48 pixels on all scoring and navigation controls.",
            "status": "done",
            "testStrategy": "Conduct a visual audit comparing the UI against the provided Lovable design screenshots. Measure touch targets to ensure they meet the 48px minimum requirement and verify color contrast compliance.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T07:37:53.181Z"
          },
          {
            "id": 2,
            "title": "Implement Input Debouncing Logic",
            "description": "Implement a debounce mechanism on scoring buttons to prevent double-tap errors and ensure score integrity during rapid interactions.",
            "dependencies": [],
            "details": "Modify the event handlers associated with scoring buttons (established in Task 8) to include a debounce timer. Set a 300ms window during which subsequent tap events are ignored after a valid score update to prevent accidental double scoring.",
            "status": "done",
            "testStrategy": "Perform rapid tapping tests on the scoring interface to confirm that the debounce mechanism effectively prevents multiple score increments from a single intended action. Verify UI update latency remains below 100ms.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T07:37:54.865Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) Applying final design styles and ensuring accessibility (touch targets), and 2) Implementing input debouncing logic to prevent double-tap errors.",
        "updatedAt": "2026-02-21T07:37:54.865Z"
      },
      {
        "id": "11",
        "title": "Define Match State Data Model and Storage Schema",
        "description": "Create the data structure interface for the match session that satisfies the persistence and scoring requirements defined in the PRD.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Define a TypeScript/JavaScript interface or object structure representing `MatchState`. It must include fields: `status` ('active' | 'finished'), `setsToPlay` (1|3|5), `setsNeededToWin` (1|2|3), `setsWon` ({teamA, teamB}), `currentSet` ({number, games: {teamA, teamB}}), `currentGame` ({points: {teamA, teamB}}), `setHistory` (Array of {setNumber, teamAGames, teamBGames}), and `updatedAt`. Establish a constant storage key (e.g., 'ACTIVE_MATCH_SESSION').",
        "testStrategy": "Verify that the data structure can be instantiated with all required fields and successfully serialized to JSON without data loss.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define TypeScript Interface for MatchState",
            "description": "Create comprehensive TypeScript type definitions for the match state data structure with proper typing for all nested fields.",
            "dependencies": [],
            "details": "Define TypeScript interfaces and types: MatchState with fields status ('active'|'finished'), setsToPlay (1|3|5), setsNeededToWin (1|2|3), setsWon ({teamA, teamB}), currentSet ({number, games: {teamA, teamB}}), currentGame ({points: {teamA, teamB}}), setHistory (Array of {setNumber, teamAGames, teamBGames}), updatedAt (timestamp), and schemaVersion (number). Export all types from a central types module.",
            "status": "done",
            "testStrategy": "Verify TypeScript compilation succeeds, no type errors when creating MatchState objects, and all union types correctly restrict invalid values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:18:59.901Z"
          },
          {
            "id": 2,
            "title": "Create Default State Factory and Constants",
            "description": "Implement factory function to generate initial MatchState objects and define storage-related constants.",
            "dependencies": [
              1
            ],
            "details": "Create constant STORAGE_KEY = 'ACTIVE_MATCH_SESSION'. Implement createDefaultMatchState() factory function that returns a properly initialized MatchState object: status='active', setsToPlay=3, setsNeededToWin=2, setsWon={teamA:0, teamB:0}, currentSet={number:1, games:{teamA:0, teamB:0}}, currentGame={points:{teamA:0, teamB:0}}, setHistory=[], updatedAt=current timestamp, schemaVersion=1.",
            "status": "done",
            "testStrategy": "Test factory returns object with all required fields initialized correctly, default values match requirements, and multiple calls create independent objects (no shared references).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:01:13.890Z"
          },
          {
            "id": 3,
            "title": "Implement Serialization and Runtime Validation",
            "description": "Create functions to serialize MatchState to JSON and deserialize with runtime type validation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement serializeMatchState(state: MatchState): string that converts state to JSON string. Implement deserializeMatchState(json: string): MatchState | null that parses JSON and validates all fields match expected types and ranges. Validation should check status values, setsToPlay in [1,3,5], setsNeededToWin in [1,2,3], numeric scores are non-negative integers. Return null if validation fails.",
            "status": "done",
            "testStrategy": "Test round-trip serialization/deserialization preserves all data. Test with malformed JSON, missing fields, invalid enum values, and negative scores to verify null returns and no crashes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:05:01.012Z"
          },
          {
            "id": 4,
            "title": "Build Storage Adapter with Abstracted API",
            "description": "Implement storage adapter with save, load, and clear functions using Zepp OS settingsStorage API.",
            "dependencies": [
              3
            ],
            "details": "Create StorageAdapter interface with save(key: string, value: string): Promise<void>, load(key: string): Promise<string | null>, clear(key: string): Promise<void>. Implement ZeppOsStorageAdapter using settingsStorage.setItem/getItem/removeItem. Create MatchStorage class that wraps the adapter with saveMatchState(state), loadMatchState(), clearMatchState() methods using STORAGE_KEY constant. Handle JSON parsing errors gracefully.",
            "status": "done",
            "testStrategy": "Test save then load retrieves identical state. Test load returns null when no data exists. Test clear removes data. Test error handling with corrupted storage data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:05.663Z"
          },
          {
            "id": 5,
            "title": "Implement Migration and Versioning Utilities",
            "description": "Create version-aware migration system to upgrade saved MatchState from older schema versions to current format.",
            "dependencies": [
              3,
              4
            ],
            "details": "Define CURRENT_SCHEMA_VERSION constant matching factory output. Create migration registry Map<number, (oldState: any) => MatchState> mapping from version to upgrade function. Implement migrateMatchState(rawData: any): MatchState that checks schemaVersion field, applies migrations sequentially from stored version to current version, or returns default state if version missing or invalid. Include migration from version 0 (no version field) to version 1.",
            "status": "done",
            "testStrategy": "Test migrating from version 0 (legacy format without version) creates valid current state. Test stored version 1 bypasses migration unchanged. Test invalid or missing version returns default state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:07.650Z"
          },
          {
            "id": 6,
            "title": "Write Unit Tests for Data Model Components",
            "description": "Create comprehensive unit tests covering instantiation, serialization, storage round-trip, and migration logic.",
            "dependencies": [
              5
            ],
            "details": "Write test suite covering: MatchState interface type checking, factory function creates valid defaults, serialization/deserialization preserves all fields including edge cases (max scores, finished status), storage adapter save/load/clear operations work correctly, migration handles legacy and current formats, and invalid data is rejected safely. Include tests for deep cloning correctness (no reference sharing in nested objects). Achieve >90% code coverage.",
            "status": "done",
            "testStrategy": "Run automated test suite. Verify all tests pass. Check code coverage report. Ensure no race conditions in async storage operations.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:09.521Z"
          },
          {
            "id": 7,
            "title": "Document Integration Notes and Task Dependencies",
            "description": "Create documentation explaining how to integrate the MatchState storage into the match lifecycle and identify dependencies.",
            "details": "Document saveMatchState() call points: after each point scored, after set completion, when match finishes, and on app pause/background. Document loadMatchState() call points: on app startup and after undo operations. Create dependency mapping: requires Task 3 (Local Storage layer) complete, provides data structure for Task 12 (Match Logic Engine). Include usage examples in JSDoc comments and a separate INTEGRATION.md file with diagrams showing state flow.",
            "status": "done",
            "testStrategy": "Review documentation for clarity and completeness. Verify dependency mappings are accurate against project task list. Peer review of integration examples.",
            "dependencies": [],
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:19:11.291Z"
          }
        ],
        "updatedAt": "2026-02-21T09:19:11.291Z"
      },
      {
        "id": "12",
        "title": "Implement Core Persistence Service (Save/Load)",
        "description": "Develop the utility functions to save the match state to local storage and load it back, including error handling for corrupted data.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "Implement `saveMatchState(state: MatchState)` and `loadMatchState(): MatchState | null`. Use Zepp OS `localStorage` or `settingsStorage` API to persist the JSON stringified state. `saveMatchState` should update `updatedAt` timestamp. `loadMatchState` must be wrapped in a try-catch block to handle parsing errors or missing data gracefully, returning null if data is invalid/missing (safe failure).",
        "testStrategy": "Unit test saving a state object, verifying it exists in storage. Unit test loading the object back. Test loading with corrupted JSON to ensure it returns null instead of crashing.",
        "subtasks": [
          {
            "id": 1,
            "title": "Define storage constants and initialize persistence module",
            "description": "Create the persistence service module with storage key constants and basic structure.",
            "dependencies": [],
            "details": "Create a new file for the persistence service. Define the storage key constant (e.g., 'ACTIVE_MATCH_SESSION'). Export the module structure and any necessary imports for Zepp OS storage API (localStorage or settingsStorage).",
            "status": "done",
            "testStrategy": "Verify module imports correctly and constants are exported without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:05.022Z"
          },
          {
            "id": 2,
            "title": "Implement saveMatchState function with timestamp",
            "description": "Create the saveMatchState function that updates timestamp and persists state to storage.",
            "dependencies": [
              1
            ],
            "details": "Implement saveMatchState(state: MatchState): void. Before saving, update state.updatedAt to current timestamp (Date.now()). Stringify the state using JSON.stringify(). Use Zepp OS localStorage.setItem() or settingsStorage.setItem() to persist the JSON string using the defined storage key constant.",
            "status": "done",
            "testStrategy": "Unit test saving a sample MatchState object. Verify storage contains the expected key and the stringified JSON includes the updated timestamp.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:08.348Z"
          },
          {
            "id": 3,
            "title": "Implement loadMatchState with try-catch error handling",
            "description": "Create the loadMatchState function with error handling for parsing and missing data.",
            "dependencies": [
              1
            ],
            "details": "Implement loadMatchState(): MatchState | null. Wrap the logic in try-catch block. Read from storage using localStorage.getItem() or settingsStorage.getItem(). If data is null/undefined, return null. Parse using JSON.parse(). If parsing fails (JSON error), catch the exception and return null. Return the parsed MatchState on success.",
            "status": "done",
            "testStrategy": "Unit test loading with no saved data (returns null). Test loading corrupted JSON (returns null). Test loading valid saved state (returns MatchState object).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:10.356Z"
          },
          {
            "id": 4,
            "title": "Add state validation for loaded data integrity",
            "description": "Implement validation logic to ensure loaded state has required fields and valid structure.",
            "dependencies": [
              3
            ],
            "details": "After successfully parsing JSON in loadMatchState, validate the loaded object structure. Check for required fields (e.g., status, sets, currentSet, teams). Verify data types match expected MatchState interface. If validation fails, return null to prevent app crashes from corrupted state. Optionally log validation errors for debugging.",
            "status": "done",
            "testStrategy": "Unit test loading state with missing required fields (returns null). Test loading state with invalid data types (returns null). Test loading complete valid state (returns object).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:12.222Z"
          },
          {
            "id": 5,
            "title": "Implement clearMatchState utility function",
            "description": "Create a utility to delete saved match state from storage.",
            "dependencies": [
              1
            ],
            "details": "Implement clearMatchState(): void function. Use localStorage.removeItem() or settingsStorage.setItem(key, null) to delete the saved match state. This is required for Task 19 (New Match Reset) to clear existing sessions. Export this function for use by other modules.",
            "status": "done",
            "testStrategy": "Save a match state, call clearMatchState, verify storage key is removed or null. Verify no error when clearing empty storage.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:54:12.201Z"
          },
          {
            "id": 6,
            "title": "Write comprehensive unit tests for persistence service",
            "description": "Create full test coverage for all persistence functions and edge cases.",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Write unit tests covering: save functionality with timestamp verification, load with valid state, load with missing data, load with corrupted JSON, load with malformed/incomplete state, clear functionality, and sequential save-load operations. Mock the Zepp OS storage API to isolate tests. Test that updatedAt is properly updated during save.",
            "status": "done",
            "testStrategy": "Run all unit tests and ensure 100% code coverage. Verify all test cases pass including happy paths and error scenarios.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T09:58:15.911Z"
          }
        ],
        "updatedAt": "2026-02-21T09:58:15.911Z"
      },
      {
        "id": "13",
        "title": "Implement Pre-Match Setup UI and Logic",
        "description": "Create the Match Setup screen allowing users to select 1, 3, or 5 sets and initialize the match session.",
        "status": "done",
        "dependencies": [
          "11",
          "12"
        ],
        "priority": "high",
        "details": "Build the 'Match Setup' view with three buttons or a selector for sets (1, 3, 5). When a user confirms a selection: 1. Calculate `setsNeededToWin` (Math.ceil(setsToPlay / 2)), 2. Initialize a fresh `MatchState` object with scores at 0 and status 'active', 3. Call `saveMatchState`, 4. Navigate to the Game screen. Ensure this flow blocks access to the Game screen without a selection.",
        "testStrategy": "Manual QA: Verify selecting '3' sets allows entry to game. Verify default state is initialized correctly with scores at 0-0 and `setsNeededToWin` set to 2.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match Setup UI Components",
            "description": "Build the visual interface for the match setup screen with set selection buttons",
            "dependencies": [],
            "details": "Create the Match Setup view UI with three distinct buttons/selector options for 1, 3, or 5 sets. Add a 'Start Match' confirmation button that is initially disabled. Style elements for clarity and touch interaction on Zepp OS display. Include visual feedback for selected option.",
            "status": "done",
            "testStrategy": "Visual verification of all buttons rendering correctly. Test button selection state changes. Verify touch responsiveness on each button element.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:16.182Z"
          },
          {
            "id": 2,
            "title": "Implement Match State Initialization Model",
            "description": "Create the logic to calculate setsNeededToWin and initialize MatchState object",
            "dependencies": [],
            "details": "Implement `initializeMatchState(setsToPlay: number)` function. Calculate `setsNeededToWin` using `Math.ceil(setsToPlay / 2)`. Create fresh MatchState object with: teamASets=0, teamBSets=0, currentSet={teamAGames:0, teamBGames:0, teamAPoints:0, teamBPoints:0}, setHistory=[], setsToPlay, setsNeededToWin, status='active', createdAt and updatedAt timestamps.",
            "status": "done",
            "testStrategy": "Unit test verifying MatchState initialization with 1 set (setsNeededToWin=1), 3 sets (setsNeededToWin=2), 5 sets (setsNeededToWin=3). Verify all fields are correctly initialized to zero or default values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:17.512Z"
          },
          {
            "id": 3,
            "title": "Integrate Match State Persistence",
            "description": "Connect the setup flow to save the initialized match state to storage",
            "dependencies": [
              2
            ],
            "details": "In the setup confirmation handler, call the existing `saveMatchState(state)` function (from Task 12) with the newly initialized MatchState object. Ensure this happens before navigation. Add error handling to display user feedback if save fails (e.g., toast message or inline error). Return boolean success/failure status.",
            "status": "done",
            "testStrategy": "Integration test confirming MatchState is persisted to storage after clicking Start Match button. Verify storage contains valid JSON with correct structure. Test failure scenario with mock save failure.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:18.879Z"
          },
          {
            "id": 4,
            "title": "Implement Navigation Flow to Game Screen",
            "description": "Add navigation logic to transition from Setup to Game screen after state initialization",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement `navigateToGame()` function triggered after successful state save. Use Zepp OS navigation API (e.g., `push` or `replace`) to transition to the Game screen view. Ensure Game screen loads state from storage on init. Prevent duplicate navigation calls during async operations.",
            "status": "done",
            "testStrategy": "Manual test: Complete setup flow, verify Game screen appears and displays initial 0-0 state. Test rapid button clicks to ensure no double-navigation bugs.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:20.253Z"
          },
          {
            "id": 5,
            "title": "Add Validation and Access Control",
            "description": "Implement safeguards to prevent access to Game screen without proper setup",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add validation on Setup confirmation button requiring an explicit set selection (1, 3, or 5) before enabling. Implement guard on Game screen init that checks for valid active MatchState in storage using `loadMatchState`; redirect to Setup if missing, invalid, or status is not 'active'. Block direct Game screen entry without setup completion.",
            "status": "done",
            "testStrategy": "Test attempting direct Game screen navigation without setup - should redirect to Setup. Test clicking Start Match without selection - button should remain disabled. Verify guard catches corrupted state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:21.577Z"
          },
          {
            "id": 6,
            "title": "Create Unit and Integration Tests for Setup Flow",
            "description": "Write comprehensive tests covering the complete match setup workflow",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Create unit tests for `initializeMatchState` function with edge cases including invalid inputs. Create integration tests for the full flow: UI selection  state init  save  navigate. Mock storage and navigation services. Test invalid inputs, storage failures, and happy path scenarios. Ensure tests can run in CI environment.",
            "status": "done",
            "testStrategy": "Automated test suite with >80% coverage of setup flow logic. Verify all acceptance criteria: selecting '3' sets allows entry, default state initializes correctly with 0-0 scores and setsNeededToWin=2.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T11:36:22.871Z"
          }
        ],
        "updatedAt": "2026-02-21T11:36:22.871Z"
      },
      {
        "id": "14",
        "title": "Integrate Lifecycle Persistence Triggers",
        "description": "Ensure state is saved automatically on app lifecycle events (sleep, exit, background) to meet reliability requirements.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "Hook into Zepp OS lifecycle events (e.g., `page.onHide`, `app.onHide`, or specific sleep callbacks depending on API availability). In these handlers, retrieve the current runtime state and call `saveMatchState`. Additionally, ensure `saveMatchState` is called immediately after any scoring update (add/remove point).",
        "testStrategy": "Integration test: Start a match, score a few points, trigger a 'sleep' event or 'back' button press, and relaunch the app. Verify storage contains the latest score.",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Zepp OS lifecycle event APIs",
            "description": "Investigate and document available lifecycle hooks in Zepp OS for handling app sleep, background, exit, and page hide events.",
            "dependencies": [],
            "details": "Review Zepp OS documentation to identify all available lifecycle callbacks including page.onHide, app.onHide, sleep callbacks, and any relevant event emitters. Test which events fire reliably in different scenarios (app backgrounding, screen lock, device sleep, back button press). Create a reference mapping of available events to their trigger conditions and reliability characteristics.",
            "status": "done",
            "testStrategy": "Create a test script that logs all lifecycle events and verify which hooks fire in simulator/emulator during various app state transitions (background, foreground, back button, screen off).",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:44.791Z"
          },
          {
            "id": 2,
            "title": "Implement lifecycle event handler registration",
            "description": "Create handler functions that retrieve current runtime state and call saveMatchState when lifecycle events trigger.",
            "dependencies": [
              1
            ],
            "details": "Implement lifecycle event handler registration in the main app or game screen initialization. Create wrapper functions for each relevant lifecycle hook that retrieve the current MatchState from the state manager and pass it to saveMatchState. Ensure handlers are registered at app startup and cleaned up appropriately if needed. Handle potential errors during save operations gracefully.",
            "status": "done",
            "testStrategy": "Manually trigger lifecycle events (back button, background app) and verify through logs that saveMatchState is called with the correct state object.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:45.867Z"
          },
          {
            "id": 3,
            "title": "Integrate automatic save on scoring updates",
            "description": "Add calls to saveMatchState immediately after each scoring update operation (addPoint and removePoint).",
            "dependencies": [
              1
            ],
            "details": "Locate the addPoint and removePoint functions in the scoring logic. After each successful state mutation, call saveMatchState with the updated state. Ensure this happens synchronously before any UI updates to guarantee persistence. Verify that the save doesn't cause noticeable performance degradation in the UI. Consider batching if rapid scoring causes issues.",
            "status": "done",
            "testStrategy": "Add points multiple times rapidly and verify storage contains the correct final state after each operation. Test undo operations to ensure state persistence is maintained correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:47.307Z"
          },
          {
            "id": 4,
            "title": "Implement debounce and atomic save mechanism",
            "description": "Add debouncing logic to prevent race conditions and redundant save operations when multiple events trigger simultaneously.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement a debounced version of saveMatchState that coalesces rapid successive calls within a short window (e.g., 100-300ms). Use a flag or promise-based approach to ensure only one save operation runs at a time, preventing race conditions. The debounce should ensure the final state is saved even if multiple triggers occur in quick succession (e.g., scoring + back button pressed together). Ensure pending saves complete before app terminates.",
            "status": "done",
            "testStrategy": "Simulate rapid scoring followed immediately by a back button press. Verify only one save operation occurs and the final correct state is persisted. Test concurrent save requests to ensure no data corruption.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:48.507Z"
          },
          {
            "id": 5,
            "title": "Create integration tests for lifecycle persistence",
            "description": "Implement automated tests that simulate app lifecycle events and verify state persists correctly across app restarts.",
            "dependencies": [
              4
            ],
            "details": "Create integration test scenarios: 1) Start match, add points, trigger background/foreground cycle, verify state persists. 2) Add points, simulate sleep/power-off, relaunch, verify latest state. 3) Add points, press back, relaunch game screen, verify state restored. Mock or stub the Zepp OS lifecycle APIs if needed. Verify storage contains expected JSON structure and values. Test edge cases like empty state, zero scores, and finished matches.",
            "status": "done",
            "testStrategy": "Automated test suite covering all lifecycle scenarios with assertions on storage contents after each event. Manual testing on actual device if simulation is insufficient.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:49.732Z"
          },
          {
            "id": 6,
            "title": "Update documentation and code comments",
            "description": "Document the persistence mechanism, lifecycle handling, and debouncing approach in code comments and project documentation.",
            "dependencies": [
              5
            ],
            "details": "Add comprehensive comments to lifecycle handler registration code explaining which events are hooked and why. Document the debouncing mechanism with explanation of the race condition problem it solves. Update README or technical documentation with details on automatic state persistence behavior. Add inline comments in scoring functions noting where automatic saves occur. Document any limitations or edge cases in the persistence system.",
            "status": "done",
            "testStrategy": "Review documentation for clarity and completeness. Have another developer verify they understand the persistence mechanism from the documentation alone.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T13:44:50.831Z"
          }
        ],
        "updatedAt": "2026-02-21T13:44:50.831Z"
      },
      {
        "id": "15",
        "title": "Update Game Screen for Set Point Display",
        "description": "Modify the Game Screen UI to visualize the match-level set points (Sets Won) alongside current game scores.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "medium",
        "details": "Update the Game View UI layout to include labels or indicators for `setsWon.teamA` and `setsWon.teamB`. Bind these UI elements to the current `MatchState` data. Ensure the display updates immediately when the underlying state changes.",
        "testStrategy": "Visual QA: Verify that upon entering a game, set counters are visible and set to 0. Verify UI updates when set counts change programmatically.",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Game View layout structure",
            "description": "Examine the existing Game View layout to determine optimal placement for set point indicators without disrupting current score display.",
            "dependencies": [],
            "details": "Open the current Game View layout file. Review the existing score display sections (Game Points and Set Scores). Identify the best position for adding the Sets Won indicators, likely in the top section near team labels or alongside existing set scores. Ensure placement maintains proper spacing and doesn't cause layout overflow on round/square screens.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.319Z"
          },
          {
            "id": 2,
            "title": "Add set point UI elements to Game View",
            "description": "Create and position text labels or indicators for Team A and Team B Sets Won in the Game View layout.",
            "dependencies": [
              1
            ],
            "details": "Add two new text label widgets to the Game View UI - one for Team A sets won and one for Team B sets won. Position them based on the analysis from subtask 1. Use appropriate UI component IDs (e.g., 'teamA-sets-won', 'teamB-sets-won') for later binding. Ensure labels have placeholder text initially (e.g., '0'). Apply proper alignment relative to team labels or score displays.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.321Z"
          },
          {
            "id": 3,
            "title": "Bind setsWon properties to UI elements",
            "description": "Connect the new set point indicator labels to the MatchState setsWon.teamA and setsWon.teamB data properties.",
            "dependencies": [
              2
            ],
            "details": "In the Game View controller or binding logic, establish data bindings between the newly created UI labels and the MatchState.setsWon properties. Create reference bindings for teamA-sets-won to setsWon.teamA and teamB-sets-won to setsWon.teamB. Ensure the binding path correctly accesses the nested properties within the match state object.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.322Z"
          },
          {
            "id": 4,
            "title": "Implement reactive state update mechanism",
            "description": "Ensure the set point display updates immediately when the underlying MatchState setsWon values change.",
            "dependencies": [
              3
            ],
            "details": "Verify or implement reactive observers or state change listeners that trigger UI updates when setsWon properties are modified. Ensure the view re-renders or text content updates within 100ms of state change. If using a reactive framework (like Zepp's state management), confirm the bindings are properly reactive. If manual updates are needed, implement update functions called after state changes.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.323Z"
          },
          {
            "id": 5,
            "title": "Style set point indicators",
            "description": "Apply consistent styling to the set point labels to match the existing design system and ensure visibility.",
            "dependencies": [
              2
            ],
            "details": "Apply design tokens (colors, fonts, font sizes) to the set point indicator labels. Ensure high contrast for readability. Match the styling approach used for existing score displays. Consider adding visual hierarchy - perhaps smaller than current game points but clearly visible. Test that the styling works on both round and square screen layouts without overlapping other elements.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.324Z"
          },
          {
            "id": 6,
            "title": "Verify set point display functionality",
            "description": "Comprehensive testing of the set point display feature including initialization, updates, and visual consistency.",
            "dependencies": [
              4,
              5
            ],
            "details": "Test the complete feature: 1) Verify upon entering game, set counters are visible and correctly initialized to 0. 2) Programmatically change set counts and verify UI updates immediately. 3) Test by playing through a game and winning a set - confirm sets won increments. 4) Verify both Team A and Team B indicators update independently. 5) Check display on both round and square screen simulators for proper rendering.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-21T16:28:42.326Z"
          }
        ],
        "updatedAt": "2026-02-21T16:28:42.326Z"
      },
      {
        "id": "16",
        "title": "Implement Set Completion and Match Completion Logic",
        "description": "Develop the logic to handle set wins, update set history, reset games, and determine the match winner based on the configured format.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "Implement a function `handleGameWin(team)`. Logic: 1. Increment current set games. 2. Check Padel game win condition (e.g., >= 6 and diff >= 2). 3. If set won: Increment `setsWon` for the winner. Push final scores ({setNumber, teamAGames, teamBGames}) to `setHistory`. Reset `currentSet.games`. 4. Check match completion: If `setsWon[winner] >= setsNeededToWin`, set status to 'finished'. 5. If match finished, trigger navigation to Summary. If not, start next set.",
        "testStrategy": "Unit tests simulating game sequences to trigger set wins. Verify `setsWon` increments, `setHistory` is populated, and match status changes to 'finished' at the correct threshold.",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement game score increment for winning team",
            "description": "Create function to increment the games count for the current set when a team wins a game point",
            "dependencies": [],
            "details": "Implement the first part of handleGameWin(team) that increments the current set's game count for the specified team. Update the teamAGames or teamBGames counter in the match state based on the team parameter passed to the function.",
            "status": "done",
            "testStrategy": "Unit test to verify games counter increments correctly for team A and team B independently",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:27.363Z"
          },
          {
            "id": 2,
            "title": "Implement Padel game win condition check",
            "description": "Create validation logic to determine if a set is won based on games won threshold and margin",
            "dependencies": [
              1
            ],
            "details": "Implement logic to check if the current set has been won by either team. A team wins a set if they have >= 6 games AND lead by at least 2 games (6-4, 6-0, 7-5, etc.). Return the winning team or null if no winner yet.",
            "status": "done",
            "testStrategy": "Unit tests for various score scenarios including 6-4, 7-5, 6-0 wins, and 5-5, 6-5 where no winner exists",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:30.120Z"
          },
          {
            "id": 3,
            "title": "Implement set completion and history tracking",
            "description": "Handle set win by incrementing setsWon, recording set history, and resetting current games",
            "dependencies": [
              2
            ],
            "details": "When a set is won, increment the winner's setsWon counter in match state. Push an object {setNumber, teamAGames, teamBGames} to setHistory array with current set number and final game scores. Reset currentSet.games to {teamA: 0, teamB: 0} for the next set.",
            "status": "done",
            "testStrategy": "Unit tests to verify setsWon increments correctly, setHistory is populated with proper score objects, and games reset to zero",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:32.488Z"
          },
          {
            "id": 4,
            "title": "Implement match winner determination",
            "description": "Check if match is finished by comparing setsWon to setsNeededToWin configuration",
            "dependencies": [
              3
            ],
            "details": "After a set is won, check if the winner's setsWon count meets or exceeds setsNeededToWin (e.g., 2 for best-of-3 format). If condition is met, update match status to 'finished', store the winning team identifier, and update the finishedAt timestamp.",
            "status": "done",
            "testStrategy": "Unit tests simulating 2-set win (best-of-3) and 3-set win scenarios to verify match status changes to finished at correct threshold",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:35.647Z"
          },
          {
            "id": 5,
            "title": "Implement navigation to Summary or next set",
            "description": "Trigger appropriate screen navigation based on match completion status",
            "dependencies": [
              4
            ],
            "details": "If match status is 'finished', trigger navigation to Match Summary screen (Task 18) with final state. If match continues, initialize the next set by incrementing setNumber and reset games, then ensure game screen displays updated state for new set.",
            "status": "done",
            "testStrategy": "Integration test to verify navigation to Summary after match win, and proper set initialization for continuing matches",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:22:38.432Z"
          }
        ],
        "updatedAt": "2026-02-21T19:22:38.432Z"
      },
      {
        "id": "17",
        "title": "Implement Home Screen Resume Logic",
        "description": "Update the Home Screen to conditionally show 'Resume Game' and handle restoring the active match state.",
        "status": "done",
        "dependencies": [
          "12"
        ],
        "priority": "high",
        "details": "On Home Screen initialization (`onShow` or `init`), call `loadMatchState`. If the result is not null AND `status === 'active'`, display the 'Resume Game' button/element. On 'Resume Game' click: 1. Load the state into the global runtime match manager. 2. Navigate to Game Screen. 3. Update UI to reflect restored state. Hide button if state is null or status is 'finished'.",
        "testStrategy": "Integration test: Create a match, exit to home. Verify 'Resume' appears. Click resume. Verify game screen opens with exact previous score. Finish a match, go home. Verify 'Resume' does not appear.",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Resume Game Button to Home Screen Layout",
            "description": "Add a new 'Resume Game' button element to the Home Screen view and configure its initial visibility state.",
            "dependencies": [],
            "details": "Create the button UI element in the Home Screen layout/template. Set its visibility to hidden/false by default. Style the button to match the existing UI theme. Position it appropriately, typically near the 'Start New Game' button for logical user flow.",
            "status": "done",
            "testStrategy": "Visual QA: Verify the Home Screen renders without the Resume Game button visible on initial load.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:08.629Z"
          },
          {
            "id": 2,
            "title": "Implement Home Screen Initialization State Check",
            "description": "Implement the logic on Home Screen initialization to check for active match state and conditionally display the Resume button.",
            "dependencies": [
              1
            ],
            "details": "In the Home Screen's onShow or init lifecycle method, call the loadMatchState() function from the persistence service (Task 12). Evaluate the returned state: if state is not null AND state.status equals 'active', set the Resume Game button visibility to true; otherwise, ensure it remains hidden. Handle null states gracefully.",
            "status": "done",
            "testStrategy": "Unit test: Mock loadMatchState to return active state - verify button shows. Mock return null or finished status - verify button stays hidden.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:10.148Z"
          },
          {
            "id": 3,
            "title": "Implement Resume Game State Loading",
            "description": "Implement the logic to load the persisted match state into the global runtime match manager when Resume Game is clicked.",
            "dependencies": [
              2
            ],
            "details": "Create a click event handler for the Resume Game button. In the handler, call loadMatchState() to retrieve the current active state. Pass this state to the global runtime match manager's initialization/load function to restore the match state in memory. Add error handling for cases where state loading fails or returns invalid data.",
            "status": "done",
            "testStrategy": "Unit test: Verify the handler calls loadMatchState and passes the result to the match manager. Test error handling when state loading fails.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:11.751Z"
          },
          {
            "id": 4,
            "title": "Implement Resume Game Navigation",
            "description": "Implement navigation from Home Screen to Game Screen after state is successfully loaded.",
            "dependencies": [
              3
            ],
            "details": "After successfully loading the state into the match manager (in the Resume click handler), trigger navigation to the Game Screen using the app's navigation router. Ensure the navigation happens only after state loading is complete and successful. Add fallback error UI if navigation or state loading fails.",
            "status": "done",
            "testStrategy": "Integration test: Click Resume button and verify the navigation router is called with Game Screen route.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:15.280Z"
          },
          {
            "id": 5,
            "title": "Implement Game Screen UI State Restoration",
            "description": "Update the Game Screen UI to reflect the restored match state when opened via Resume functionality.",
            "dependencies": [
              4
            ],
            "details": "When the Game Screen initializes, check if a match state is already loaded in the global match manager. If present, update all UI elements (team scores, current set scores, games won, serve indicators, team names, set history) to display the values from the restored state. Ensure the game appears exactly as it was when the user exited.",
            "status": "done",
            "testStrategy": "Visual QA: Create a match with specific scores, exit, resume. Verify all UI elements show exact previous state including scores, serves, and history.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:17.184Z"
          },
          {
            "id": 6,
            "title": "Testing and Documentation for Resume Logic",
            "description": "Write comprehensive tests for the resume functionality and document the implementation details.",
            "dependencies": [
              5
            ],
            "details": "Write integration tests simulating the full resume flow: create a match, exit to home, verify Resume appears, click Resume, verify Game Screen opens with correct state. Add test for finished match not showing Resume. Document the resume feature behavior, edge cases handled, and integration points in the project README or technical documentation.",
            "status": "done",
            "testStrategy": "End-to-end test: Complete full user journey from creating match, exiting, resuming, and verifying state persistence. Verify 'Resume' does not appear for finished matches.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T19:48:19.358Z"
          }
        ],
        "updatedAt": "2026-02-21T19:48:19.358Z"
      },
      {
        "id": "18",
        "title": "Implement Match Summary Screen",
        "description": "Create the Summary Screen to display the match winner, final set points, and per-set breakdown.",
        "status": "done",
        "dependencies": [
          "11",
          "16"
        ],
        "priority": "medium",
        "details": "Build the 'Match Summary' view. Display: 'Team [A/B] Wins', Final Set Score (e.g., '2-1'), and a list of sets (e.g., 'Set 1: 6-4', 'Set 2: 4-6'). Iterate through the `setHistory` array from the `MatchState` to populate the list. Add 'Home' and 'Start New Game' buttons.",
        "testStrategy": "Visual QA: Complete a 3-set match. Verify summary shows the correct winner and all 3 set scores. Verify buttons are functional.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match Summary screen UI structure",
            "description": "Set up the basic screen layout container for the Match Summary view",
            "dependencies": [],
            "details": "Create the Match Summary screen component with Zepp OS configuration. Define the main layout structure including: header section for winner announcement, middle section for set breakdown list, and bottom section for action buttons. Configure proper screen dimensions and styling containers.",
            "status": "done",
            "testStrategy": "Verify the summary screen renders without errors when navigated to, displaying empty layout containers",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.854Z"
          },
          {
            "id": 2,
            "title": "Implement winner and final set score display",
            "description": "Add logic to determine and display the winning team and final match score",
            "dependencies": [
              1
            ],
            "details": "Extract the winning team from MatchState by comparing total sets won by Team A vs Team B. Display 'Team A Wins' or 'Team B Wins' in the header. Show the final set score (e.g., '2-1') based on the sets count from the state. Style the winner text prominently for visibility.",
            "status": "done",
            "testStrategy": "Test with both Team A and Team B winning scenarios; verify correct winner text and final score format displays accurately",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.857Z"
          },
          {
            "id": 3,
            "title": "Implement set history list rendering",
            "description": "Iterate through setHistory array and display each set's breakdown score",
            "dependencies": [
              2
            ],
            "details": "Map through the setHistory array from MatchState. For each set entry, create a list item showing 'Set N: X-Y' format where X is Team A's games and Y is Team B's games. Implement dynamic list rendering to handle variable number of sets (1-3+). Ensure proper spacing and formatting for readability.",
            "status": "done",
            "testStrategy": "Complete 2-set and 3-set matches; verify all sets display in correct order with accurate game scores (e.g., 'Set 1: 6-4', 'Set 2: 4-6', 'Set 3: 6-2')",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.858Z"
          },
          {
            "id": 4,
            "title": "Add Home and Start New Game buttons",
            "description": "Create and wire up navigation buttons at the bottom of the summary screen",
            "dependencies": [
              3
            ],
            "details": "Add two action buttons in the bottom section: 'Home' button navigates back to the Home screen using navigation API. 'Start New Game' button triggers the new match flow (integration point for Task 19). Configure proper button sizing, spacing, and touch targets for usability on the device.",
            "status": "done",
            "testStrategy": "Verify both buttons are tappable and responsive; test 'Home' navigates correctly; verify 'Start New Game' button is ready for Task 19 integration",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.860Z"
          },
          {
            "id": 5,
            "title": "Integrate summary screen into match completion flow",
            "description": "Connect Match Summary to trigger automatically when match ends and perform final testing",
            "dependencies": [
              4
            ],
            "details": "Update the scoring engine or state listener to detect when match status changes to 'finished'. Automatically navigate to Match Summary screen with the complete MatchState passed as parameter. Ensure the screen receives and displays the latest state data. Perform full end-to-end testing of the complete match-to-summary flow.",
            "status": "done",
            "testStrategy": "Visual QA: Complete a full 3-set match and verify summary shows correct winner and all 3 set scores. Test both navigation buttons. Verify edge case with 2-set finish.",
            "parentId": "undefined",
            "updatedAt": "2026-02-21T21:10:33.861Z"
          }
        ],
        "updatedAt": "2026-02-21T21:10:33.861Z"
      },
      {
        "id": "19",
        "title": "Implement New Match Reset and Cleanup",
        "description": "Ensure starting a new match clears the existing active session and history properly.",
        "status": "done",
        "dependencies": [
          "12",
          "13"
        ],
        "priority": "medium",
        "details": "Implement a `startNewMatchFlow` function. This should clear the persisted `ACTIVE_MATCH_SESSION` from storage (set to null or delete key). Reset the in-memory state manager. Then navigate to the Match Setup screen (Task 13). This must be triggered from the Summary screen 'Start New Game' button and potentially the Home screen if a hard reset is needed.",
        "testStrategy": "Functional test: Finish a match. Click 'Start New Game'. Check storage to ensure old 'finished' match is cleared or overwritten. Verify setup screen appears fresh.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create storage clearing utility function",
            "description": "Implement a utility function to clear the persisted active match session from storage.",
            "dependencies": [],
            "details": "Create a function `clearActiveMatchSession()` that uses the existing persistence API (from Task 12) to delete or set to null the `ACTIVE_MATCH_SESSION` key in local storage/settings storage. Ensure proper error handling is in place.",
            "status": "done",
            "testStrategy": "Unit test that verifies the storage key is removed or set to null after calling the function. Test with existing and non-existing session data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:37.458Z"
          },
          {
            "id": 2,
            "title": "Create state manager reset utility function",
            "description": "Implement a utility function to reset the in-memory match state manager to initial values.",
            "dependencies": [],
            "details": "Create a function `resetMatchStateManager()` that resets the global match state to its initial state: scores to 0-0, history stack empty, setHistory empty, status to 'idle', and any other relevant properties to default values. This will use the logic from Task 4's state structure.",
            "status": "done",
            "testStrategy": "Unit test that verifies state manager is reset to initial values after calling the function, even after a simulated active match state exists.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:38.430Z"
          },
          {
            "id": 3,
            "title": "Implement startNewMatchFlow main function",
            "description": "Implement the main startNewMatchFlow function that orchestrates cleanup and navigation.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create `startNewMatchFlow()` that: 1) calls `clearActiveMatchSession()` to remove persisted data, 2) calls `resetMatchStateManager()` to clear in-memory state, 3) navigates to the Match Setup screen (Task 13). Wrap in try-catch for graceful error handling and ensure the flow completes or fails safely.",
            "status": "done",
            "testStrategy": "Integration test: simulate an active match, call startNewMatchFlow, verify storage is cleared, state is reset, and navigation occurs to Match Setup screen.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:39.543Z"
          },
          {
            "id": 4,
            "title": "Connect Summary screen Start New Game button",
            "description": "Integrate the startNewMatchFlow function with the Summary screen's Start New Game button.",
            "dependencies": [
              3
            ],
            "details": "In the Summary Screen implementation (Task 18), locate the 'Start New Game' button and add a click event handler that calls `startNewMatchFlow()`. Ensure the handler provides visual feedback (e.g., loading state) if needed and prevents double-taps.",
            "status": "done",
            "testStrategy": "Functional test: Complete a match, view the Summary screen, click 'Start New Game', verify storage is cleared and Match Setup screen appears fresh without previous match data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:40.609Z"
          },
          {
            "id": 5,
            "title": "Add hard reset capability to Home screen",
            "description": "Add optional hard reset functionality to the Home screen for emergency reset scenarios.",
            "dependencies": [
              3
            ],
            "details": "On the Home Screen (Task 17), implement a hard reset mechanism - either a dedicated button (for debugging/admin) or a long-press gesture on a UI element. When triggered, call `startNewMatchFlow()`. Consider adding a confirmation dialog to prevent accidental resets. Document this feature appropriately.",
            "status": "done",
            "testStrategy": "Functional test: With an active match in progress, trigger the hard reset on Home screen, verify confirmation appears (if implemented), confirm action, and verify state is cleared and Match Setup screen appears.",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T09:27:41.728Z"
          }
        ],
        "updatedAt": "2026-02-22T09:27:41.728Z"
      },
      {
        "id": "20",
        "title": "Edge Case Handling and Data Validation",
        "description": "Robustness check to handle app interruptions before first point, corrupted data, and null reference safety.",
        "status": "done",
        "dependencies": [
          "12",
          "17"
        ],
        "priority": "medium",
        "details": "Add defensive coding in `loadMatchState` and state consumers. Scenario 1: User exits immediately after setup (0 points). Ensure state saves 'active' status and loads correctly. Scenario 2: Partial data in storage. Logic must default to 'no active game' (hide resume) rather than crashing. Add checks in Game screen to ensure state exists before rendering UI.",
        "testStrategy": "QA Scenarios: 1. Setup match -> Press Back -> Open App -> Verify Resume works. 2. Manually corrupt storage file -> Open App -> Verify app loads Home safely without 'Resume'.",
        "subtasks": [],
        "updatedAt": "2026-02-22T09:55:22.386Z"
      },
      {
        "id": "21",
        "title": "Increase Add Point Button Size for Game Screen (Accessibility)",
        "description": "Refactor the Game Screen UI to ensure Add Point buttons meet the 44x44 px touch target requirement, optimizing layout for round and square Zepp OS screens without breaking existing functionality.",
        "details": "Modify the `page/game` layout to increase the dimensions of Team A and Team B Add/Remove point controls to a minimum of 44x44 px. Adjust the Points Display and Set Points display areas (referencing Task 15) to be more compact or repositioned to accommodate larger controls. Reduce non-essential UI elements (padding, chrome) if necessary to maximize space. Ensure layout logic handles dynamic sizing for Round (designWidth 454) and Square (designWidth 390) screens. Maintain event bindings established in Task 8 and ensure visual separation between interactive elements to prevent accidental adjacent taps.",
        "testStrategy": "Visual QA on Zepp OS simulator (round 454, square 390) to verify 44px minimum touch targets and adequate spacing. Conduct manual on-device rapid tap tests to verify responsiveness and prevent accidental touches. Verify accessibility standards (contrast, separation). Run regression tests for scoring flows and save/restore functionality to ensure UI changes do not break existing logic.",
        "status": "cancelled",
        "dependencies": [
          "7",
          "8",
          "15",
          "2",
          "4"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T16:47:53.181Z"
      },
      {
        "id": "22",
        "title": "Redesign Game Screen UI for Enhanced Readability and Touch Interaction",
        "description": "Overhaul the Game Screen interface to improve readability by replacing the segmented card layout with a streamlined header for Sets and Games. Modify the scoring interaction to allow adding points by tapping the score display directly, with dedicated minus buttons positioned below.",
        "details": "Refactor the `page/game` layout to eliminate the segmented card style. Implement a new, cleaner header section that distinctly displays 'SETS' and 'GAMES' labels alongside the corresponding values for Team A and Team B. Apply design tokens to increase font sizes significantly across all text elements for better legibility. Redesign the central score area so that the Point Score (0, 15, 30, etc.) acts as a large, touch-sensitive button; tapping this area should trigger the `addPoint` logic. Place explicit, styled 'Minus' (-) buttons directly below the score displays to handle `removePoint` actions. Ensure the layout remains responsive for both Round (454px) and Square (390px) screens, adjusting padding and flex distribution to prevent overlap.",
        "testStrategy": "Visual QA: Verify the new header layout clearly separates 'SETS' and 'GAMES' and that font sizes are visibly larger than the previous implementation. Functional Test: Tap the main score display for a team; verify that the score increments correctly and the UI updates immediately. Functional Test: Tap the 'Minus' button below the score; verify the score decrements correctly. Layout Test: Run on Round and Square simulators to ensure the tappable score areas are large enough to be easily hit and do not overlap with other elements. Regression Test: Resume a match and verify the new UI correctly populates with the existing `MatchState` data.",
        "status": "done",
        "dependencies": [
          "7",
          "8",
          "15"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:04:07.334Z"
      },
      {
        "id": "23",
        "title": "Implement Scrollable Match History on Summary Screen",
        "description": "Replace static history text with a scrollable SCROLL_LIST widget to accommodate longer match histories, adjust font sizing, and remove the Start New Game button from the Summary Screen.",
        "details": "This task modifies the existing Match Summary Screen (Task 18) to enhance the match history display. Implementation steps:\n\n1. **Replace Static History with SCROLL_LIST**: Remove the current static text display for set history. Implement a SCROLL_LIST widget that dynamically populates with items from the `setHistory` array in the MatchState. Each list item should display a single set result (e.g., 'Set 1: 6-4'). Configure the scrollable list to handle histories longer than the screen viewport.\n\n2. **Increase Font Scale**: Update the body font scale property from 0.04 to 0.08 to improve text readability. This may require adjusting the scrollable list item height to prevent text clipping.\n\n3. **Remove Start New Game Button**: Delete the 'Start New Game' button from the Summary Screen UI. Ensure the 'Home' button remains and continues to navigate properly to the Home screen.\n\n4. **UI Adjustments**: Re-layout the Summary Screen components to accommodate the new scrollable list. The layout should flow: Winner announcement, final score, scrollable set history list, and Home button at the bottom.\n\nNote: The Start New Game functionality was already handled in Task 19, so removing this button is purely a UI change. The data source (setHistory from MatchState) remains unchanged from Task 16.",
        "testStrategy": "1. Visual QA with short match: Complete a 1-set match and verify the scrollable list displays 'Set 1: X-Y' correctly with the larger font size (0.08).\n\n2. Scroll functionality test: Complete a 3 or 5-set match where the history exceeds the screen height. Verify the list is scrollable and all sets are accessible.\n\n3. Button verification: Confirm only the Home button exists on the Summary screen. Clicking it should navigate to the Home screen.\n\n4. Text readability: Verify the increased font scale (0.08) renders clearly without overlapping other UI elements.\n\n5. Edge case: Test with a match that went to tie-breaks to ensure set history formatting remains correct in the scrollable list (e.g., 'Set 2: 7-6').",
        "status": "done",
        "dependencies": [
          "18",
          "16"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:23.415Z"
      },
      {
        "id": "24",
        "title": "Simplify New Game Start Flow on Home Screen",
        "description": "Remove the confirmation mechanism when starting a new game from the home screen to reduce friction and allow immediate game start without any intermediate confirmation step or timer logic.",
        "details": "Modify the Home Screen 'Start New Game' button behavior to eliminate the confirmation dialog flow. Remove any UI components related to the confirmation modal (dialog text, confirm/cancel buttons, backdrop). Delete state variables tracking confirmation visibility (e.g., `showConfirmDialog`, `isConfirming`). Remove any timer logic associated with auto-dismissing confirmation dialogs or countdown timers. Update the 'Start New Game' click event handler to directly execute the start sequence: 1) Call the match reset/cleanup function from Task 19 to clear existing session data, 2) Navigate immediately to the Match Setup screen. Ensure this simplification only affects the Home Screen start flow and does not impact other areas of the app that may use confirmation patterns. Clean up any unused CSS/styling and event listeners previously associated with the confirmation dialog.",
        "testStrategy": "Functional Test: Tap 'Start New Game' button on Home Screen and verify immediate navigation to Match Setup screen without any confirmation dialog appearing. Integration Test: With an active saved game, tap 'Start New Game' and verify storage is cleared (check for null ACTIVE_MATCH_SESSION) and Match Setup loads correctly. Regression Test: Verify 'Resume Game' button continues to work as expected and is unaffected by the start flow changes. Edge Case Test: Rapid successive taps on 'Start New Game' should not cause multiple navigation attempts or storage conflicts. Visual Inspection: Confirm no visual artifacts or unused UI elements remain from the removed confirmation dialog.",
        "status": "done",
        "dependencies": [
          "6",
          "19"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:28.916Z"
      },
      {
        "id": "25",
        "title": "Implement Screen Keep-Awake During Active Game",
        "description": "Implement screen keep-awake functionality to prevent the watch from returning to the watchface when the screen turns off during an active game, with maximum brightness setting and simulator compatibility handling.",
        "details": "Implement screen keep-awake functionality for the Game Screen to ensure continuous gameplay visibility during active matches. On `page/game` initialization or `onShow` lifecycle event, call the Zepp OS screen wake API (e.g., `wearable.keepScreenOn()` or `wakelock.acquire()`) to prevent the screen from turning off. Set the bright screen time to maximum using the appropriate brightness settings API (e.g., `setBrightScreenDuration(MAX)`). Store the reference to the wake lock or screen keep setting in a module-level variable for cleanup. On page exit (`onHide`, `onDestroy`, or navigation away), release the wake lock or cancel the keep-awake request to restore normal power behavior. Wrap all API calls in try-catch blocks with feature detection (check if APIs exist before calling) to handle the simulator environment where these APIs may be unavailable. Add a fallback mechanism or graceful degradation if the APIs are not present (e.g., log a warning to console but allow the app to continue functioning). Ensure the implementation does not cause memory leaks by properly cleaning up references and avoiding multiple wake lock acquisitions.",
        "testStrategy": "Functional Test: Deploy the app to a physical watch device. Navigate to the Game Screen and verify the screen does not turn off after the default timeout period (wait at least 1-2 minutes without interaction). Functional Test: Exit the Game Screen (navigate back or to another page) and verify that normal screen timeout behavior is restored. Simulator Test: Run the app in the Zepp simulator environment. Navigate to the Game Screen and verify the app does not crash or throw errors when keep-awake APIs are unavailable. Memory Test: Repeatedly enter and exit the Game Screen (10+ times) to verify there are no memory leaks or accumulating wake lock references. Integration Test: Play a full match from start to finish to ensure keep-awake functionality persists throughout the entire gameplay session and properly disengages upon match completion.",
        "status": "done",
        "dependencies": [
          "7"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:34.245Z"
      },
      {
        "id": "26",
        "title": "Update App Icons for GTR-3 and GTS-3 Devices",
        "description": "Replace the existing icon.png assets specifically for GTR-3 and GTS-3 device targets with updated versions. Additionally, update the project documentation to include a visual reference of the new sample icon.",
        "details": "Locate the asset directories specific to the GTR-3 and GTS-3 devices within the project structure (typically found under directories named or tagged with device identifiers). Replace the current `icon.png` files in these directories with the updated icon assets. Ensure that the new assets adhere to the specific resolution requirements for GTR-3 (usually 454x454 pixels) and GTS-3 (usually 390x390 pixels) and are in the supported format (e.g., PNG). Navigate to the project documentation file (e.g., README.md or docs folder) and insert the new sample icon image. Add a caption or label indicating it is the updated reference icon for the application.",
        "testStrategy": "Build the application specifically for GTR-3 and GTS-3 targets using the Zepp OS tooling. Deploy the built application to the respective simulators or physical devices. Visually inspect the app icon on the device home screen/app drawer to verify it matches the new design and is not distorted or pixelated. Review the documentation file to ensure the embedded sample icon renders correctly and is clearly visible.",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:46.760Z"
      },
      {
        "id": "27",
        "title": "Refactor Tests to Use Synchronous Storage APIs",
        "description": "Update all test files to replace asynchronous storage calls with synchronous adapter methods, aligning test patterns with the production Zepp OS `hmFS` file system APIs.",
        "details": "Locate all test files that utilize the storage layer (specifically those testing `saveState`, `loadState`, or persistence logic). Remove `async`/`await` keywords from test function definitions and within the test bodies where storage operations occur. Replace the asynchronous calls with the synchronous `hmFS.SysProSetChars` and `hmFS.SysProGetChars` methods (or their synchronous adapter wrappers) to match the production implementation. Delete any `setTimeout`, `waitFor`, or promise-based delay logic that was previously required to wait for asynchronous storage operations to complete. Simplify test assertions by removing `await` prefixes and validating the state immediately following the synchronous function call. Ensure mock implementations in the test environment are updated to return values directly instead of resolving Promises.",
        "testStrategy": "Run the full test suite to verify all storage-related tests pass without 'UnhandledPromiseRejection' errors or timeout failures. Verify that tests execute faster due to the removal of artificial delays. Confirm that tests for edge cases (e.g., reading empty storage, handling corrupted data) still function correctly with the synchronous read/write pattern.",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-22T17:35:46.764Z"
      },
      {
        "id": "28",
        "title": "Fix Game Screen Navigation to Home Screen",
        "description": "Correct the navigation logic for the Game Screen so that both the 'Return to Home' button and the swipe-back gesture route directly to the Home Screen instead of the Game Setup Screen.",
        "details": "Locate the 'Return to Home' button event handler within the `page/game` implementation. Update the routing logic to navigate directly to `page/index` (Home Screen) instead of the Setup Screen. Implement or modify the `onBack` lifecycle event handler for the Game Screen to intercept system swipe-back gestures. Inside the `onBack` handler, explicitly set the navigation path to `page/index` and prevent the default behavior which currently routes to the Setup Screen. Ensure that match state is handled appropriately (e.g., saving) before navigation if the game is active.",
        "testStrategy": "Functional Test: Start a new game from the Home Screen. Tap the 'Return to Home' button and verify the app navigates directly to the Home Screen without passing through the Setup Screen. Functional Test: Start a new game, perform a swipe-back gesture, and verify the app navigates directly to the Home Screen. Regression Test: Verify that starting a new game from the Home Screen still functions correctly and that the Resume Game button appears correctly when exiting an active match.",
        "status": "done",
        "dependencies": [
          "7",
          "22"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Reproduce and document current navigation behavior",
            "description": "Investigate and document the current buggy navigation flow from Game Screen to Setup Screen",
            "dependencies": [],
            "details": "Navigate to the Game Screen from Home Screen. Attempt to use both the 'Return to Home' button and swipe-back gesture. Document the actual routing behavior (routes to Setup Screen instead of Home). Capture screenshots or record the issue. Identify the exact location in the codebase where routing decisions are made (page/game implementation, button event handlers). Deliverables: Issue documentation with reproduction steps and code location analysis.\n<info added on 2026-02-22T18:19:59.378Z>\nInvestigation Complete - Current Navigation Behavior Documented:\n\nBUG #1 - Button Handler (page/game.js lines 581-593):\nnavigateToHomePage() uses goBack() as primary navigation, which navigates to Setup Screen (previous page in stack) instead of Home Screen.\n\nBUG #2 - Swipe-back Gesture (page/game.js):\nNo onBack() lifecycle handler implemented. Swipe-back defaults to goBack() behavior, going to Setup instead of Home.\n\nFiles to modify:\n1. page/game.js - Modify navigateToHomePage() to always use gotoPage to page/index\n2. page/game.js - Add onBack() lifecycle handler\n3. tests/game-screen-layout.test.js - Update tests to expect gotoPage instead of goBack\n\nState preservation via saveCurrentRuntimeState({ force: true }) is working correctly.\n</info added on 2026-02-22T18:19:59.378Z>",
            "status": "done",
            "testStrategy": "Manual testing on simulator/device to confirm the bug exists and document steps",
            "updatedAt": "2026-02-22T18:20:07.304Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Design routing changes and state-saving approach",
            "description": "Design the updated navigation flow and state preservation strategy for Game Screen",
            "dependencies": [
              1
            ],
            "details": "Design the new routing flow: both 'Return to Home' button and swipe-back should navigate directly to page/index (Home Screen). Determine when to save match state: always save before navigation, or only if match is active. Design confirm dialog behavior for matches in progress. Identify files to modify: page/game/index.js or similar, routing configuration, state management module. Deliverables: Updated routing flow diagram and state-saving logic specification.\n<info added on 2026-02-22T18:23:08.755Z>\nDesign Documentation Complete - Routing Changes and State-Saving Approach\n\n1. Updated Routing Flow Specification\nCurrent Buggy Behavior:\n- Home (page/index) -> Setup (page/setup) -> Game (page/game)\n- navigateToHomePage() uses goBack() which navigates to previous page in stack (Setup), not Home\n- No onBack() lifecycle handler exists, so swipe-back defaults to goBack() behavior\n\nNew Routing Flow (Both paths navigate directly to Home Screen):\nGame Screen -> [Button Tap OR Swipe-Back] -> Home Screen (page/index)\n\nImplementation:\n- Remove goBack() fallback from navigateToHomePage()\n- Always use direct navigation: hmApp.gotoPage({ url: 'page/index' })\n- Add onBack() lifecycle handler that returns true to prevent default back behavior\n\n2. State-Saving Logic Specification\nApproach: Save match state BEFORE navigation in all cases\n\nImplementation:\n- Reuse existing saveCurrentRuntimeState({ force: true }) method\n- Call this method in both navigateToHomePage() button handler AND the new onBack() handler\n- No confirm dialog needed (matches original behavior)\n- State is saved regardless of match status (active/inactive)\n\n3. Files to Modify\nFile: page/game.js\nChanges:\n1. Modify navigateToHomePage() - remove goBack(), always use gotoPage to page/index\n2. Add onBack() lifecycle handler after onDestroy()\n3. Both methods call saveCurrentRuntimeState({ force: true }) before navigation\n\nFile: tests/game-screen-layout.test.js\nChanges:\n1. Update \"game back-home control navigates back\" test to expect gotoPage instead of goBack\n2. Update \"game back-home control falls back...\" test description and remove goBack deletion logic\n3. Add new test: \"game onBack handler saves state and navigates to home\"\n\n4. Design Decisions Summary\n- Chosen Approach: Direct navigation with gotoPage + onBack handler (Simplest, minimal code change)\n- Rejected Approaches: Clear navigation stack (overengineered, limited Zepp OS APIs); Page replacement APIs (more complex without benefit)\n- Risk Level: Low - Both gotoPage and onBack are standard Zepp OS APIs\n- Backward Compatibility: Maintained - Resume Game functionality unchanged\n</info added on 2026-02-22T18:23:08.755Z>",
            "status": "done",
            "testStrategy": "Review design specification with team to ensure it handles all edge cases",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:23:16.028Z"
          },
          {
            "id": 3,
            "title": "Implement onBack handler for swipe-back interception",
            "description": "Implement the onBack lifecycle event handler to intercept system swipe-back gestures",
            "dependencies": [
              2
            ],
            "details": "In page/game implementation, add or modify the onBack lifecycle event handler. Intercept swipe-back gesture and prevent default behavior which routes to Setup Screen. Explicitly set navigation path to page/index (Home Screen). Call state saving logic before navigation if match is active. Return true to prevent default back behavior. Files to modify: page/game/index.js or page/game/page.js (main game screen file). Deliverables: Working onBack handler that routes to Home Screen.",
            "status": "done",
            "testStrategy": "Manual test: Start game, swipe back, verify direct navigation to Home Screen with state preserved",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:34:41.130Z"
          },
          {
            "id": 4,
            "title": "Implement Return to Home button handler with state saving",
            "description": "Update the Return to Home button event handler to route directly to Home Screen",
            "dependencies": [
              2
            ],
            "details": "Locate the 'Return to Home' button in page/game UI. Update its click event handler to navigate directly to page/index instead of Setup Screen. Implement state saving before navigation: save current match state to storage. Add confirm dialog (optional) if match is in progress to warn user. Debounce rapid clicks to prevent double navigation. Files to modify: page/game/index.js, page/game/game.view or similar UI file. Deliverables: Updated button handler with proper navigation and state preservation.\n<info added on 2026-02-22T18:33:22.842Z>\nImplementation update: Modified navigateToHomePage() in page/game.js (lines 952-964). The method now explicitly calls hmApp.gotoPage({ url: 'page/index' }) instead of goBack(). The goBack() fallback logic was removed entirely. Added try/catch block for error handling. This ensures the Return to Home button always navigates directly to Home Screen (page/index) regardless of navigation stack history.\n</info added on 2026-02-22T18:33:22.842Z>",
            "status": "done",
            "testStrategy": "Functional test: Click Return to Home, verify navigation to Home Screen with state saved",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:33:36.882Z"
          },
          {
            "id": 5,
            "title": "Add tests and perform QA verification",
            "description": "Implement unit/integration tests and conduct end-to-end QA for navigation fixes",
            "dependencies": [
              3,
              4
            ],
            "details": "Write unit tests for navigation logic and onBack handler. Write integration tests for complete flow from Game Screen to Home Screen. Create QA checklist: verify button navigation, verify swipe-back navigation, verify state preservation, verify 'Resume Game' appears after exit. Test edge cases: exit during active match, exit with no match in progress, rapid button clicks. Update documentation if needed. Deliverables: Test suite code, QA checklist with pass/fail results.\n<info added on 2026-02-22T18:37:50.890Z>\nQA Verification Complete - All tests pass (191/191)\n\nTests Added for onBack Handler:\n1. \"game onBack handler returns true to prevent default back behavior\" - PASS\n2. \"game onBack handler saves state before navigation\" - PASS\n3. \"game onBack handler navigates to home screen\" - PASS\n4. \"game onBack handler does not throw when hmApp is unavailable\" - PASS\n5. \"game onBack handler does not throw when gotoPage throws\" - PASS\n\nExisting Tests Verified:\n- \"game back-home control navigates directly to home screen\" - PASS\n- \"game back-home control navigates to home screen when gotoPage is available\" - PASS\n\nQA Checklist Results:\n Button navigation works - Return to Home button navigates directly to page/index\n Swipe-back navigation works - onBack() handler intercepts and navigates to page/index\n State preservation works - saveCurrentRuntimeState({ force: true }) called before navigation\n Resume Game functionality - State is saved before navigation, allowing resume\n\nQA Gate Result: PASS (191/191 tests passed)\n</info added on 2026-02-22T18:37:50.890Z>",
            "status": "done",
            "testStrategy": "Execute QA checklist on simulator and physical device; verify all test cases pass",
            "parentId": "undefined",
            "updatedAt": "2026-02-22T18:38:01.379Z"
          }
        ],
        "updatedAt": "2026-02-22T18:38:01.379Z"
      },
      {
        "id": "29",
        "title": "Implement Match History Storage and Viewing",
        "description": "Implement persistent match history storage using Zepp OS hmFS and add a Previous Matches feature to the home screen for reviewing completed matches.",
        "details": "Implement a new history storage service using `hmFS` API to persist completed match results. Create a data structure for match history entries including: matchId (unique identifier), timestamp, date, time, finalScore, setsWon for both teams, setHistory array, matchDuration (in minutes), and setsToPlay format. Implement `saveMatchToHistory(matchState)` that generates a unique ID using timestamp, extracts relevant data, calculates match duration, and saves to hmFS with filename pattern `match_<timestamp>.json` or maintains a history index file. Implement `loadMatchHistory()` to read all stored matches and `loadMatchById(matchId)` for specific matches. Update Home Screen (Task 17) to add 'Previous Matches' button alongside Start and Resume. Create a new Match History screen with SCROLL_LIST displaying previous matches with date/time as primary label (e.g., '2024-01-15 14:30') and optional brief summary like 'Team A won 2-1'. Implement navigation so tapping a history item loads the match data and navigates to Summary Screen (Task 18) for display. Ensure Summary Screen can handle both active completed matches and historical matches. Handle edge cases: empty history, corrupted files, storage limits. Consider implementing a limit (e.g., last 50 matches) with cleanup logic.",
        "testStrategy": "1. Functional test: Complete a match and verify it's saved to hmFS by checking file existence or listing history. 2. Persistence test: Save a match, restart watch/app, verify match appears in history list. 3. UI test: Navigate to home screen, verify 'Previous Matches' button appears. 4. Navigation test: Tap 'Previous Matches', verify history screen appears with list. 5. Detail test: Tap on a history item, verify summary screen displays correct match data. 6. Data integrity test: Verify stored data includes all required fields (date, time, scores, sets won, duration). 7. Multiple matches test: Complete multiple matches, verify all appear in history in chronological order. 8. Edge case test: Test with empty history (first install), verify graceful handling. 9. Display test: Verify date/time format is readable on watch screen. 10. Scroll test: With many matches in history, verify scrolling works correctly.",
        "status": "done",
        "dependencies": [
          "16",
          "17",
          "18"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Match History Data Structure and Storage Service",
            "description": "Define the data structure for match history entries and initialize the history storage service using hmFS API for persistent storage.",
            "dependencies": [],
            "details": "Create a new MatchHistoryService module using hmFS API. Define the MatchHistoryEntry interface with fields: matchId (string, unique timestamp), timestamp (number), date (string 'YYYY-MM-DD'), time (string 'HH:mm'), finalScore (string), setsWon (object with teamA and teamB), setHistory (array), matchDuration (number in minutes), setsToPlay (number). Implement the storage directory initialization and helper functions for file path construction using pattern 'match_<timestamp>.json'. Create an index file to track all stored match IDs for efficient listing.",
            "status": "done",
            "testStrategy": "Verify the data structure is correctly typed. Test that the storage directory is created on initialization. Validate that file paths are generated correctly using the match_<timestamp>.json pattern.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.553Z"
          },
          {
            "id": 2,
            "title": "Implement saveMatchToHistory Function",
            "description": "Implement the function to save completed match data to hmFS with unique ID generation, duration calculation, and storage limits enforcement.",
            "dependencies": [
              1
            ],
            "details": "Implement saveMatchToHistory(matchState) function that extracts relevant data from completed MatchState. Generate unique matchId using Date.now() timestamp. Calculate matchDuration by subtracting startTime from endTime (stored in matchState or derived from state timestamps). Create MatchHistoryEntry object and serialize to JSON. Save to hmFS using the filename pattern. Implement storage limit check (max 50 matches) - if limit exceeded, delete oldest match file and update index. Include error handling for write failures and disk full scenarios. Update the history index file with the new match ID.",
            "status": "done",
            "testStrategy": "Complete a match and verify file is created with correct filename pattern. Check that matchDuration is calculated correctly. Test that exceeding 50 matches triggers cleanup of oldest entry. Verify corrupted state doesn't crash the app.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.558Z"
          },
          {
            "id": 3,
            "title": "Implement loadMatchHistory and loadMatchById Functions",
            "description": "Implement functions to retrieve all stored matches from hmFS and load a specific match by its unique identifier with error handling.",
            "dependencies": [
              1
            ],
            "details": "Implement loadMatchHistory() that reads the index file to get all match IDs, then iterates through each ID to read individual match files. Return array of MatchHistoryEntry objects sorted by timestamp (newest first). Handle missing index file by returning empty array. Implement loadMatchById(matchId) that constructs the file path and reads the specific match JSON file. Both functions must include try-catch blocks to handle corrupted JSON files - skip corrupted entries in loadMatchHistory and return null for loadMatchById on errors. Handle file not found gracefully.",
            "status": "done",
            "testStrategy": "Test loading history with multiple matches saved. Verify sorting is correct (newest first). Test loading by specific matchId returns correct data. Test with corrupted file ensures it's skipped or returns null. Test empty history returns empty array.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.561Z"
          },
          {
            "id": 4,
            "title": "Update Home Screen with Previous Matches Button",
            "description": "Add a 'Previous Matches' button to the Home Screen alongside existing Start and Resume buttons to enable navigation to match history.",
            "dependencies": [],
            "details": "Modify the Home Screen component (from Task 17) to add a new 'Previous Matches' button positioned below or alongside the existing Start and Resume buttons. Style the button consistently with existing UI. Implement the button's onClick handler to navigate to the new Match History screen (using hmUI.push or similar navigation API). Ensure the button is always visible regardless of whether there's an active match session. Consider adding a small indicator (badge) showing the count of saved matches if desired.",
            "status": "done",
            "testStrategy": "Verify the 'Previous Matches' button appears on Home Screen. Confirm button styling matches existing buttons. Test clicking the button navigates to Match History screen. Verify button works both with and without active match sessions.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.565Z"
          },
          {
            "id": 5,
            "title": "Create Match History Screen with SCROLL_LIST and Navigation",
            "description": "Build the Match History screen displaying all stored matches in a scrollable list with tap-to-view navigation to Summary Screen.",
            "dependencies": [
              3,
              4
            ],
            "details": "Create new Match History screen component using Zepp OS SCROLL_LIST widget. On screen load, call loadMatchHistory() to retrieve all matches. Configure SCROLL_LIST with custom list item template showing date/time as primary label (e.g., '2024-01-15 14:30') and brief summary as secondary label (e.g., 'Team A won 2-1, 45 min'). Handle empty history case by displaying 'No matches played yet' message. Implement onTap handler for list items that calls loadMatchById(matchId), stores the loaded match data (possibly in a global or navigation context), and navigates to Summary Screen. Modify Summary Screen (Task 18) to accept and display historical match data - distinguish between active completed matches and historical matches using a flag or data source check. Edge cases: gracefully handle navigation with no matches selected, display error for corrupted entries on tap.",
            "status": "done",
            "testStrategy": "Verify scrollable list displays all matches with correct format. Test tapping an item loads the match and navigates to Summary Screen. Verify Summary Screen correctly displays historical match data. Test empty history shows appropriate message. Test tapping corrupted entry shows error or is handled gracefully.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T12:25:29.568Z"
          },
          {
            "id": 6,
            "title": "Improve History List UI - Larger fonts and 2 items per view",
            "description": "Modify the SCROLL_LIST to show only 2 matches at a time; increase font size for better readability; display format: datetime + final score on single line (e.g., 23/02 14:30 - 2-1).",
            "dependencies": [],
            "details": "Update the SCROLL_LIST configuration and item template in page/history.js so the list shows two items per viewport (configure item height or viewport settings as needed). Increase font sizes for primary label and secondary label to improve readability on watch displays. Ensure each item shows single-line label combining date/time and final score as 'DD/MM HH:mm - finalScore'. Preserve existing onTap/navigation behavior.",
            "status": "done",
            "testStrategy": "verify two items visible, fonts larger, formatting correct",
            "updatedAt": "2026-02-23T13:43:14.678Z",
            "parentId": "undefined"
          },
          {
            "id": 7,
            "title": "Research Zepp OS v1.0 Modal/Popup and Enhance Detail View",
            "description": "Research if Zepp OS v1.0 provides modal/popup functionality; if not present, enhance existing history-detail.js page to show full set-by-set scores (games in each set).",
            "dependencies": [],
            "details": "Perform research and document whether Zepp OS v1.0 supports modal/popup widgets or overlays. If modal/popup is available, note the recommended widget and implementation notes. If not available, implement improvements in page/history-detail.js to present a detailed match view showing full setHistory including games and points per set, arranged clearly for small-screen watches. Include UI/UX notes for readability and navigation (back/close).",
            "status": "done",
            "testStrategy": "verify detail view shows all games per set and is navigable",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T13:45:37.542Z"
          },
          {
            "id": 8,
            "title": "Integration - Connect history list to detail view",
            "description": "When clicking a match in history list, navigate to detail view with full data. Pass match data (including setHistory) to show detailed scores.",
            "dependencies": [],
            "details": "Implement or update the onTap handler in page/history.js to pass the selected match's full data (including setHistory and match metadata) to history-detail.js. Use navigation context or parameters supported by the app framework (e.g., push page with params or shared state). Ensure history-detail.js receives and renders the passed data; fall back to loading by matchId when full data isn't passed.",
            "status": "done",
            "testStrategy": "verify tapping list item opens detail view with full set-by-set scores displayed",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T13:46:46.158Z"
          }
        ],
        "updatedAt": "2026-02-23T13:46:46.158Z"
      },
      {
        "id": "30",
        "title": "Add QA Controls with Husky, Biome, and Commitlint",
        "description": "Set up code quality tooling for the project, including git hooks for pre-commit and commit-msg validation, automated linting with Biome, and test execution on pre-push.",
        "details": "1. **Install Dependencies**: Run package manager commands to install `husky`, `@commitlint/cli`, `@commitlint/config-conventional`, `@biomejs/biome`, and `lint-staged` as dev dependencies.\n2. **Initialize Husky**: Run `npx husky install` to set up the git hooks infrastructure and configure the `prepare` script in `package.json` to ensure hooks are installed after `npm install`.\n3. **Configure Commitlint**: Create a `commitlint.config.js` file extending `@commitlint/config-conventional` to enforce commit message standards.\n4. **Configure Biome**: Create a `biome.json` configuration file to define linting and formatting rules for JavaScript and JSON files.\n5. **Configure lint-staged**: Create a `.lintstagedrc.json` file to map file extensions (`.js`, `.json`, `.ts`) to the Biome lint command.\n6. **Create Git Hooks**:\n   - **Pre-commit**: Create `.husky/pre-commit` containing `npx lint-staged` to run linters only on staged files.\n   - **Commit-msg**: Create `.husky/commit-msg` containing `npx commitlint --edit $1` to validate messages.\n   - **Pre-push**: Create `.husky/pre-push` containing `npm test` to ensure the test suite passes before pushing.\n7. **Update package.json Scripts**: Add scripts for `\"lint\"`, `\"format\"`, and `\"lint:fix\"` using Biome CLI commands (`biome check .`, `biome format --write .`, `biome check --write .`).",
        "testStrategy": "1. **Pre-commit Verification**: Intentionally introduce a linting error (e.g., unused variable) in a JavaScript file, stage it, and attempt to commit. Verify that the commit is blocked by the pre-commit hook and the Biome error is displayed in the console.\n2. **Linting Fix**: Run the `npm run lint:fix` command, stage the changes, and verify the commit now succeeds.\n3. **Commit-msg Verification**: Attempt to commit with a message like 'bad message' and verify the commit-msg hook blocks it. Retry with a conventional commit like 'feat: add qa controls' and verify success.\n4. **Pre-push Verification**: Temporarily break a unit test, then attempt to `git push`. Verify that the pre-push hook blocks the push due to the test failure. Fix the test and verify the push succeeds.",
        "status": "done",
        "dependencies": [
          "1",
          "3"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Install Dependencies and Initialize Husky",
            "description": "Install all required development dependencies and set up the Husky git hooks infrastructure for the project.",
            "dependencies": [],
            "details": "Run package manager commands to install husky, @commitlint/cli, @commitlint/config-conventional, @biomejs/biome, and lint-staged as dev dependencies. Then run `npx husky install` to set up the git hooks infrastructure. Finally, configure the `prepare` script in package.json to ensure hooks are installed automatically after `npm install`.",
            "status": "done",
            "testStrategy": "Verify the Husky .husky directory is created and the prepare script exists in package.json. Run `npm run prepare` and confirm no errors occur.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:52:36.704Z"
          },
          {
            "id": 2,
            "title": "Configure Biome and Add Package Scripts",
            "description": "Create the Biome configuration file and add linting and formatting scripts to package.json.",
            "dependencies": [
              1
            ],
            "details": "Create a `biome.json` configuration file in the project root to define linting and formatting rules for JavaScript and JSON files. Update package.json to add the following scripts: \"lint\" using `biome check .`, \"format\" using `biome format --write .`, and \"lint:fix\" using `biome check --write .`.",
            "status": "done",
            "testStrategy": "Run `npm run lint` to verify Biome checks files without errors. Run `npm run lint:fix` to ensure auto-fixing works correctly. Verify the biome.json file is valid JSON.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:54:10.892Z"
          },
          {
            "id": 3,
            "title": "Configure Commitlint and Create Commit-msg Hook",
            "description": "Set up commit message validation using Commitlint and create the git hook for message checking.",
            "dependencies": [
              1
            ],
            "details": "Create a `commitlint.config.js` file in the project root that extends `@commitlint/config-conventional` to enforce conventional commit message standards. Create the `.husky/commit-msg` hook file containing the command `npx commitlint --edit $1` to validate commit messages before they are accepted.",
            "status": "done",
            "testStrategy": "Attempt to commit with an invalid message (e.g., 'bad commit') and verify the commit is rejected. Commit with a valid message (e.g., 'feat: add new feature') and verify it succeeds.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:54:30.937Z"
          },
          {
            "id": 4,
            "title": "Configure Lint-staged and Create Pre-commit Hook",
            "description": "Set up lint-staged to run linters only on staged files and create the pre-commit git hook.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a `.lintstagedrc.json` configuration file in the project root that maps file extensions (`.js`, `.json`, `.ts`) to the appropriate Biome lint command. Create the `.husky/pre-commit` hook file containing `npx lint-staged` to run linters automatically on staged files before each commit.",
            "status": "done",
            "testStrategy": "Intentionally introduce a linting error (e.g., unused variable or trailing whitespace) in a JavaScript file, stage it, and attempt to commit. Verify that the commit is blocked and the Biome error is displayed. Fix the error and confirm the commit succeeds.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:54:50.648Z"
          },
          {
            "id": 5,
            "title": "Create Pre-push Hook and Verify All Quality Controls",
            "description": "Create the pre-push git hook for test execution and perform end-to-end testing of all quality controls.",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Create the `.husky/pre-push` hook file containing `npm test` to ensure the test suite passes before pushing changes to remote. Perform comprehensive testing of all three hooks: verify pre-commit blocks commits with linting errors, verify commit-msg rejects non-conventional messages, and verify pre-push blocks pushes when tests fail.",
            "status": "done",
            "testStrategy": "Make a test fail temporarily and attempt to push - verify the push is blocked. Fix the test and verify push succeeds. Run through a full workflow: create a change, fix any linting issues, write a proper commit message, and push to confirm all quality gates work together.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T17:55:23.366Z"
          }
        ],
        "updatedAt": "2026-02-23T17:55:23.366Z"
      },
      {
        "id": "31",
        "title": "Set up GitHub Actions CI/CD Workflow",
        "description": "Create a GitHub Actions workflow to validate Pull Requests and pushes to the main branch, implementing quality gates, Node.js matrix testing, build verification, and security checks.",
        "details": "1. Create the workflow file at `.github/workflows/ci.yml`.\n2. Configure triggers for `push` on `main` branch and `pull_request` events.\n3. Define a strategy matrix to test against Node.js versions `18.x` and `20.x` to ensure compatibility.\n4. Implement caching for `node_modules` using `actions/cache` keyed on `package-lock.json` to optimize build times.\n5. Add sequential job steps to:\n   - Checkout code using `actions/checkout`.\n   - Setup Node.js using `actions/setup-node`.\n   - Restore cache and install dependencies (`npm ci`).\n   - Run code quality checks: `npm run lint` (Biome) and `npm run format -- --check`.\n   - Check for dependency vulnerabilities: `npm audit`.\n   - Verify the build process: `zeus build` (if applicable to the Zepp OS project structure).\n   - Execute the test suite: `npm run test`.\n6. Ensure the workflow is configured to fail the status check if any of the quality gates or tests fail.",
        "testStrategy": "1. Trigger the workflow by pushing a commit to the main branch and verify it initializes automatically in the Actions tab.\n2. Open a test Pull Request and confirm the workflow runs against the proposed changes.\n3. Verify the matrix strategy executes jobs for both Node.js 18.x and 20.x versions.\n4. Inspect workflow logs to confirm `node_modules` caching is working (cache hit/restored) on subsequent runs.\n5. Intentionally break the build configuration (e.g., add a linting error) in a PR to verify that the CI status fails and correctly prevents merging.\n6. Ensure `npm audit` and format checks run successfully on clean code.",
        "status": "done",
        "dependencies": [
          "30"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create GitHub Actions workflow file and configure triggers",
            "description": "Initialize the CI workflow file with proper event triggers for push and pull request events",
            "dependencies": [],
            "details": "Create `.github/workflows/ci.yml` file with basic workflow structure. Configure triggers for `push` events on the `main` branch and `pull_request` events for all branches to ensure validation on all proposed changes.",
            "status": "done",
            "testStrategy": "Push a commit to main branch and verify workflow appears in Actions tab. Open a test PR and confirm workflow triggers automatically.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:10.965Z"
          },
          {
            "id": 2,
            "title": "Configure Node.js matrix testing strategy",
            "description": "Set up multi-version Node.js testing using GitHub Actions matrix strategy",
            "dependencies": [
              1
            ],
            "details": "Define a job strategy with a matrix to test against Node.js versions `18.x` and `20.x`. This ensures compatibility across supported Node.js versions and validates the application works in both environments.",
            "status": "done",
            "testStrategy": "Verify workflow executes 2 parallel jobs, one for each Node.js version. Check job names reflect the matrix versions.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:12.365Z"
          },
          {
            "id": 3,
            "title": "Implement dependency caching and installation",
            "description": "Set up node_modules caching and install project dependencies",
            "dependencies": [
              2
            ],
            "details": "Use `actions/cache` with key based on `package-lock.json` to cache `node_modules` directory. Configure the job to restore cache before installation. Add `npm ci` step to install dependencies cleanly, which uses the lockfile for reproducible builds.",
            "status": "done",
            "testStrategy": "Run workflow twice and verify second run uses cache (check for 'Cache restored' message in logs). Confirm dependencies install without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:13.730Z"
          },
          {
            "id": 4,
            "title": "Add code quality and security verification steps",
            "description": "Implement linting, formatting checks, and dependency vulnerability scanning",
            "dependencies": [
              3
            ],
            "details": "Add sequential steps for code quality checks: `npm run lint` using Biome for linting, `npm run format -- --check` to verify code formatting compliance, and `npm audit` to check for known security vulnerabilities in dependencies.",
            "status": "done",
            "testStrategy": "Intentionally introduce a linting error and verify workflow fails. Run on clean codebase and confirm all quality checks pass.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:15.180Z"
          },
          {
            "id": 5,
            "title": "Add build verification and test execution",
            "description": "Implement build process validation and automated test suite execution",
            "dependencies": [
              4
            ],
            "details": "Add build verification step using `zeus build` command to validate the Zepp OS project structure compiles correctly. Add test execution step using `npm run test` to run the full test suite. Configure workflow to fail status check if any step fails.",
            "status": "done",
            "testStrategy": "Verify build completes successfully and tests execute. Break a test and confirm workflow fails the status check, blocking PR merge.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T18:50:16.540Z"
          }
        ],
        "updatedAt": "2026-02-23T18:50:16.540Z"
      },
      {
        "id": "32",
        "title": "Audit & Fix Zepp OS v1.0 Lifecycle API Usage",
        "description": "Find and fix usages of Zepp OS lifecycle methods (onShow, onHide, onResume, onPause) that are invalid for API v1.0 in the codebase, replacing them with v1.0-compatible alternatives.",
        "details": "Perform a comprehensive audit of lifecycle API usage across the codebase to ensure compatibility with Zepp OS v1.0. Steps: 1) Search the repository for all occurrences of onShow, onHide, onResume, and onPause methods. 2) Verify and document usage in reporter-listed files: page/index.js, page/summary.js, page/setup.js, page/game.js, page/history-detail.js, page/history.js, identifying any additional occurrences. 3) For each occurrence, create a detailed documentation entry including: file path, exact code snippet, explanation of why it's invalid in v1.0, recommended v1.0 alternative approach, and proposed fix strategy. 4) Implement straightforward fixes by replacing onShow/onHide with v1.0 entry points (e.g., page initialization, event-based approaches) or creating feature-detection wrapper functions. 5) For complex or risky changes, document the recommended approach and create follow-up subtasks instead of implementing immediately. 6) Replace deprecated lifecycle methods with appropriate v1.0 equivalents such as using page initialization callbacks, app event listeners, or manual state management. 7) Update documentation in .taskmaster/notes with audit findings and modifications made. Deliverables include: complete audit findings list, summary of modified files, list of follow-up subtasks for risky fixes, and updated documentation.",
        "testStrategy": "1) Code review: Verify no instances of onShow/onHide/onResume/onPause remain in the codebase after fixes. 2) Functional testing for each modified page: index - verify page loads correctly and state initializes; game - confirm keep-awake functionality works and scoring persists on background; summary - validate match results display correctly after page navigation; setup - ensure match configuration initializes properly; history/history-detail - verify match history loads and displays; all pages - test navigation flow (forward and back) to ensure no state loss or crashes occur. 3) Lifecycle testing: Background the app during different states (game active, on setup screen, viewing history) and foreground to verify persistence works correctly. 4) Regression testing: Confirm that functionality from related tasks (screen keep-awake, auto-save on lifecycle events, match history storage) still operates as expected.",
        "status": "done",
        "dependencies": [
          "9",
          "14",
          "25",
          "12"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Search and Catalog All Lifecycle API Usage",
            "description": "Perform a comprehensive repository-wide search for deprecated Zepp OS lifecycle methods and catalog all findings.",
            "dependencies": [],
            "details": "Execute a code search across the entire repository for all occurrences of onShow, onHide, onResume, and onPause methods. Use grep or IDE search functionality to find all instances. Create a preliminary catalog listing file paths, line numbers, and exact method signatures for each occurrence. Pay special attention to the reporter-listed files: page/index.js, page/summary.js, page/setup.js, page/game.js, page/history-detail.js, and page/history.js, while also scanning the entire codebase for any additional occurrences in utility files or other components.",
            "status": "done",
            "testStrategy": "Verify the search results by manually checking the catalog against the known file list and randomly sampling entries to ensure accuracy.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:24.876Z"
          },
          {
            "id": 2,
            "title": "Analyze and Document Incompatibility Issues",
            "description": "Analyze each discovered lifecycle API usage and create detailed documentation explaining why it's incompatible with Zepp OS v1.0.",
            "dependencies": [
              1
            ],
            "details": "For each occurrence catalogued in the previous task, create a detailed documentation entry including: complete file path, exact code snippet context, explanation of why the method is invalid in v1.0 API, recommended v1.0 alternative approach (e.g., page initialization callbacks, app event listeners, or manual state management), and a specific proposed fix strategy. Categorize occurrences by complexity level: straightforward (simple replacement needed), moderate (requires refactoring logic), or complex/risky (requires significant architectural changes). Store this analysis in .taskmaster/notes/audit-findings.md.",
            "status": "done",
            "testStrategy": "Review documentation for completeness and technical accuracy. Ensure every occurrence has a clear recommended alternative documented.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:27.335Z"
          },
          {
            "id": 3,
            "title": "Implement Straightforward Page Initialization Fixes",
            "description": "Replace onShow/onHide methods with v1.0-compatible page initialization approaches for pages with simple requirements.",
            "dependencies": [
              2
            ],
            "details": "Implement fixes for pages categorized as straightforward in the audit. Replace onShow calls with page initialization logic placed directly in the page constructor or init function. For onHide calls that only need to save state, replace with explicit save calls before navigation. Focus on pages like page/index.js, page/summary.js, and page/setup.js where the lifecycle is simple. Create feature-detection wrapper functions if needed to maintain compatibility during transition. Ensure all state initialization happens synchronously during page load rather than waiting for show events.",
            "status": "done",
            "testStrategy": "Test each modified page by navigating to it and verifying it loads correctly with proper initialization. Verify no onShow/onHide methods remain in these files.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:29.983Z"
          },
          {
            "id": 4,
            "title": "Implement Event-Based Lifecycle Replacements",
            "description": "Replace deprecated lifecycle methods with v1.0 event listeners and manual state management for complex pages.",
            "dependencies": [
              2
            ],
            "details": "Implement fixes for complex pages like page/game.js, page/history-detail.js, and page/history.js. Replace onShow/onHide/onResume/onPause with app-level event listeners using app.on('pause') and app.on('resume') where appropriate. For page-specific visibility changes, implement manual state management using boolean flags or state objects that track visibility. Integrate these fixes with the existing saveMatchState functionality from Task 14. Ensure keep-awake functionality from the game page is preserved through alternative mechanisms such as wake-lock API calls on page load.",
            "status": "done",
            "testStrategy": "Functional testing: simulate backgrounding/foregrounding events and verify state persists correctly. Test game page to ensure scoring survives background transitions and keep-awake works as expected.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:32.574Z"
          },
          {
            "id": 5,
            "title": "Document Complex or Risky Changes for Follow-up",
            "description": "Create detailed documentation and recommendations for any lifecycle fixes that are too complex or risky to implement immediately.",
            "dependencies": [
              2
            ],
            "details": "For any occurrences categorized as complex or risky, do not implement the fix directly. Instead, create comprehensive documentation in .taskmaster/notes/risky-fixes.md that includes: the specific code that needs changing, why the change is risky (potential side effects, performance impact, architectural concerns), detailed step-by-step recommended approach for implementation, potential migration path or phased rollout strategy, and any additional dependencies or prerequisite work needed. This documentation will serve as the basis for future follow-up tasks.",
            "status": "done",
            "testStrategy": "Peer review of the documentation to ensure technical accuracy and that the proposed approach is feasible and well-documented.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:35.016Z"
          },
          {
            "id": 6,
            "title": "Final Verification and Documentation Update",
            "description": "Complete the audit by verifying all deprecated lifecycle methods are addressed and updating project documentation with findings.",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Perform a final code review to verify no instances of onShow, onHide, onResume, or onPause remain in the codebase except in the risky-fixes documentation. Update .taskmaster/notes with the complete audit findings summary including: total occurrences found, files modified, fixes implemented, and list of follow-up subtasks created for risky fixes. Create a summary document .taskmaster/notes/lifecycle-audit-summary.md with deliverables: complete audit findings list, summary of modified files, list of follow-up subtasks for risky fixes, and updated documentation. Ensure all changes are committed with appropriate commit messages referencing Task 32.",
            "status": "done",
            "testStrategy": "Code review: search codebase one final time for any remaining deprecated lifecycle methods. Verify documentation is complete and accurate. Build project to ensure no syntax errors were introduced.",
            "parentId": "undefined",
            "updatedAt": "2026-02-23T16:00:37.823Z"
          }
        ],
        "updatedAt": "2026-02-23T16:00:37.823Z"
      },
      {
        "id": "33",
        "title": "Create Settings Page with Scroll List",
        "description": "Implement a new Settings page featuring a SCROLL_LIST widget with navigation to match history and functionality to clear all app data, while removing these actions from the Home Screen.",
        "details": "Implementation Steps:\n\n1. **Create Settings Page Structure**: Create a new page at `page/settings` using Zepp UI components. Implement the page layout with a SCROLL_LIST (try to reproduce the same as the list example in here: https://docs.zepp.com/docs/1.0/designs/template/list/, with the text and the chevron, using the chevron-icon.png) widget as the primary container, following the Zepp SCROLL_LIST API documentation (https://docs.zepp.com/docs/1.0/reference/device-app-api/hmUI/widget/SCROLL_LIST/).\n\n2. **Implement SCROLL_LIST Items**: Configure the scrollable list with the following menu items:\n   - 'Previous Matches' item: Displayed text label with navigation indicator\n   - 'Clear App Data' item: Displayed text label with appropriate icon (delete-icon.png)\n\n3. **Implement 'Previous Matches' Navigation**: Add click event handler for the 'Previous Matches' list item that navigates to the match history view. This should use `hmUI.gotoPage()` or appropriate navigation method to navigate to the page that displays match history (likely the Match Summary screen or a dedicated history view).\n\n4. **Implement 'Clear App Data' Functionality**: Create a comprehensive `clearAllAppData()` function that:\n   - Reviews all storage keys used by the application (including 'ACTIVE_MATCH_SESSION', any history storage, settings preferences)\n   - Clears in-memory data structures and state variables\n   - Removes all files from the filesystem if any are persisted\n   - Uses `hmFS.remove()` or similar APIs to delete files\n   - Uses storage clearing methods (e.g., `localStorage.removeItem()` or device-specific APIs)\n   - Logs confirmation of cleared data for debugging\n   - Returns to Home Screen after clearing\n   Add this function as the click handler for the 'Clear App Data' list item.",
        "testStrategy": "1. **Settings Page Display Test**: Launch the app and navigate to the Settings page. Verify the SCROLL_LIST widget displays correctly with both 'Previous Matches' and 'Clear App Data' items visible. Test scrolling behavior if the list is longer than the viewport.\n\n2. **Previous Matches Navigation Test**: Tap 'Previous Matches' in the Settings list. Verify the app navigates successfully to the history/match summary view. Confirm the correct history data is displayed. Test navigation back to Settings.\n\n3. **Clear App Data Functionality Test**:\n   - Start a new game and record some scores to ensure data exists in storage\n   - Navigate to Settings and tap 'Clear App Data'\n   - Verify that the action completes without errors\n   - Check that all app data has been cleared:\n     * Navigate to Home Screen - verify 'Resume Game' button is not shown (no saved match)\n     * Navigate to Previous Matches - verify no history is displayed\n     * If the app has settings/preferences, verify they are reset to defaults\n   - Attempt to navigate to game - verify the app requires new match setup\n\n4. **Home Screen Integration Test**: Verify the Home Screen no longer displays 'Previous Matches' and 'Clear App Data' buttons. Confirm the 'Settings' button is present and functional. Test that the Home Screen layout is balanced and no empty space or layout issues exist.\n\n5. **Edge Case Test**: Try to clear app data when the app is already empty. Verify no errors occur and the app remains stable.\n\n6. **Round and Square Screen Testing**: Verify the Settings page SCROLL_LIST displays correctly on both screen types, ensuring items are properly aligned and readable.",
        "status": "done",
        "dependencies": [
          "6",
          "11"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Settings page structure with SCROLL_LIST widget",
            "description": "Create the new Settings page directory and main page file with the SCROLL_LIST widget as the primary container, following Zepp UI design patterns.",
            "dependencies": [],
            "details": "Create a new page directory at `page/settings`. Create the `page/settings/index.js` file implementing the page lifecycle hooks (onInit, onReady, onDestroy). Add a SCROLL_LIST widget using hmUI.createWidget() following the Zepp SCROLL_LIST API documentation. Configure the list to display items with text labels and chevron indicators. Import the chevron-icon.png asset and ensure proper positioning. Test the page renders correctly on both round and square screen resolutions.",
            "status": "done",
            "testStrategy": "Launch the app and navigate to the Settings page. Verify the SCROLL_LIST widget displays correctly with the expected layout. Test scrolling behavior if the list exceeds viewport height.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:16.079Z"
          },
          {
            "id": 2,
            "title": "Implement SCROLL_LIST items for Previous Matches and Clear App Data",
            "description": "Configure the scrollable list with two menu items: Previous Matches with chevron icon, and Clear App Data with delete icon.",
            "dependencies": [
              1
            ],
            "details": "Define an array of list item objects containing text labels and icon paths for 'Previous Matches' (with chevron-icon.png) and 'Clear App Data' (with delete-icon.png). Use hmUI.createWidget() to add TEXT widgets for the labels and IMAGE widgets for the icons within each list item. Position elements to match the Zepp list template design with consistent padding and alignment. Ensure both items are properly clickable and have visual feedback when pressed.",
            "status": "done",
            "testStrategy": "Verify both 'Previous Matches' and 'Clear App Data' items are visible and correctly styled with their respective icons. Confirm items are visually distinct and aligned properly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.274Z"
          },
          {
            "id": 3,
            "title": "Implement Previous Matches navigation handler",
            "description": "Add click event handler for the Previous Matches list item that navigates to the match history view using hmUI.gotoPage().",
            "dependencies": [
              2
            ],
            "details": "Attach an event listener to the 'Previous Matches' list item widget using the click_event property. Implement the handler function to call hmUI.gotoPage() with the appropriate route to the match history page (likely 'page/match-summary' or similar). Ensure the navigation passes any necessary parameters such as the history data reference. Add logging for debugging to confirm navigation triggers correctly when the item is clicked.",
            "status": "done",
            "testStrategy": "Click the 'Previous Matches' item and verify it navigates to the match history view. Confirm the destination page loads correctly and displays expected data.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.280Z"
          },
          {
            "id": 4,
            "title": "Implement clearAllAppData() function",
            "description": "Create a comprehensive function to clear all application data including storage, in-memory state, and persisted files.",
            "dependencies": [
              2
            ],
            "details": "Create the clearAllAppData() function that: 1) Identifies all storage keys used (ACTIVE_MATCH_SESSION, history storage, settings preferences), 2) Clears in-memory data structures and state variables by resetting them to initial values, 3) Iterates through persisted files and removes them using hmFS.remove(), 4) Uses localStorage.clear() or storage-specific APIs to clear all stored data, 5) Adds console.log statements to confirm each step completes successfully, 6) Returns true or false indicating success/failure. Place this function in a utils file or within the Settings page module.",
            "status": "done",
            "testStrategy": "Call clearAllAppData() and verify all storage keys are removed, state is reset, and files are deleted. Check console logs for confirmation messages.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.283Z"
          },
          {
            "id": 5,
            "title": "Connect Clear App Data click handler and navigate home",
            "description": "Attach the clearAllAppData() function to the Clear App Data list item and implement navigation back to Home Screen after clearing.",
            "dependencies": [
              4
            ],
            "details": "Attach an event listener to the 'Clear App Data' list item widget. Implement the click handler to call clearAllAppData() function. After successful data clearing, call hmUI.gotoPage() to navigate back to the Home Screen ('page/index'). Add a short delay or confirmation before navigation if needed. Include error handling to display an error message if clearing fails. Add visual feedback during the clearing operation if possible.",
            "status": "done",
            "testStrategy": "Click 'Clear App Data' and verify all app data is cleared. Confirm the app navigates back to the Home Screen automatically. Test error handling by simulating clearing failures.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.294Z"
          },
          {
            "id": 6,
            "title": "Remove Previous Matches and Clear App Data from Home Screen",
            "description": "Remove the navigation buttons and actions for Previous Matches and Clear App Data from the Home Screen since they are now in Settings.",
            "dependencies": [
              5
            ],
            "details": "Open the Home Screen file ('page/index.js'). Locate and remove the widgets or buttons that provide navigation to 'Previous Matches' and 'Clear App Data' functionality. Delete any associated event handlers for these removed buttons. Clean up any unused imports or variables related to these features. Ensure the Home Screen layout adjusts properly after removal (e.g., remaining buttons are centered or fill the space appropriately). Update any UI text or labels that reference these removed features.",
            "status": "done",
            "testStrategy": "Launch the app and verify the Home Screen no longer displays Previous Matches or Clear App Data buttons. Confirm the Home Screen layout remains clean and functional. Navigate to Settings to confirm these features are accessible from there.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.297Z"
          },
          {
            "id": 7,
            "title": "Add navigation entry point to Settings from Home Screen",
            "description": "Add a Settings button or menu item on the Home Screen to allow users to navigate to the new Settings page.",
            "dependencies": [
              1
            ],
            "details": "Add a Settings button or menu item to the Home Screen layout. This could be a small icon button (settings-icon.png), a text menu item, or integrated into an existing menu. Position the button appropriately (e.g., top corner, bottom area, or in a hamburger menu). Attach a click event handler that calls hmUI.gotoPage('page/settings') to navigate to the Settings page. Ensure the button is accessible and clearly labeled. Test the positioning on both round and square screen layouts.",
            "status": "done",
            "testStrategy": "Verify the Settings button is visible and accessible on the Home Screen. Click the button and confirm it navigates to the Settings page. Test positioning on both round and square screens.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T00:57:21.299Z"
          }
        ],
        "updatedAt": "2026-02-24T00:57:21.299Z"
      },
      {
        "id": "34",
        "title": "Home Screen UI Enhancements",
        "description": "Refine the Home Screen UI by removing unnecessary buttons, standardizing the size of action buttons, and adding a settings access button.",
        "details": "Update the Home Screen layout in `page/index` to remove the 'Previous Matches' and 'Clear App Data' buttons. Resize the 'Start New Game' and 'Resume Game' buttons to make them larger (increase height and padding) and ensure they have identical dimensions for visual consistency. Add a gear icon button positioned after the two main buttons. Implement click handler for the gear icon to navigate to the Settings page (`page/settings`). Apply design tokens for consistent spacing, colors, and icon sizing. Ensure the layout remains responsive and properly aligned on both Round and Square screen types. Maintain all existing functionality for the Start and Resume buttons.",
        "testStrategy": "Visual QA: Verify 'Previous Matches' and 'Clear App Data' buttons are completely removed from the Home Screen. Visual QA: Confirm 'Start New Game' and 'Resume Game' buttons are visibly larger than the previous implementation and have exactly matching dimensions. Functional Test: Tap the gear icon button and verify it successfully navigates to the Settings page. Visual QA: Verify the gear icon is properly positioned after the two main buttons with appropriate spacing. Responsive Test: Test on both Round and Square simulators to ensure buttons and icon do not overlap or get cut off. Regression Test: Verify 'Start New Game' clears storage and navigates correctly; verify 'Resume Game' restores state and navigates correctly. Verify conditional display of 'Resume Game' button still works based on saved match state.",
        "status": "done",
        "dependencies": [
          "6"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-24T00:31:18.393Z"
      },
      {
        "id": "35",
        "title": "General UI Enhancements - Navigation Icons and Background Refinements",
        "description": "Remove gray backgrounds from all page containers and update navigation buttons with appropriate icons across multiple screens. Implement swipe-right-to-close behavior on the home screen.",
        "details": "This task involves multiple UI refinements across different screens:\n\n1. **Remove Gray Backgrounds from All Pages**:\n   - Update `page/index` (Home Screen), `page/game` (Game Play Screen), Match Summary Screen, and Match History pages\n   - Locate container boxes/cards with gray background properties and remove or set to transparent\n   - Ensure text contrast and readability remains acceptable after background removal\n   - Apply consistent background styling across all screens\n\n2. **Replace Back to Home Buttons with House Icon Buttons (home-icon.png)**:\n   - In Game Play screen (`page/game`): Locate the 'Back to Home' button element and replace its text content with a house icon asset (home-icon.png)\n   - In Match Summary screen: Replace any 'Back to Home' text button with a house icon button\n   - Ensure both buttons maintain existing click handlers that navigate to home screen\n   - Style icon buttons with appropriate touch target sizes for usability\n\n3. **Implement Swipe Right to Close on Home Screen**:\n   - Add gesture event listener to `page/index` for swipe right detection\n   - On swipe right event, call Zepp OS app exit API (e.g., `app.exit()` or `wx.exitApp()`)\n   - Ensure this gesture only triggers on home screen and doesn't interfere with other screen interactions\n   - Test that app properly closes and returns to watchface\n\n4. **Testing and Verification**:\n   - Perform visual inspection on all affected screens\n   - Verify all navigation flows remain intact after button changes\n   - Test touch responsiveness of new icon buttons",
        "testStrategy": "1. Visual Test: Navigate to Home Screen and verify all gray backgrounds have been removed from containers\n2. Visual Test: Navigate to Game Play Screen and verify gray backgrounds are removed\n3. Functional Test: Tap the house icon button on Game Play Screen and verify it navigates to Home Screen\n4. Visual Test: Navigate to Match Summary Screen and verify gray backgrounds are removed\n5. Functional Test: Tap the house icon button on Match Summary Screen and verify it navigates to Home Screen\n6. Visual Test: Navigate to Match History List and verify back arrow icon is displayed instead of text\n7. Functional Test: Tap the return icon on Match History pages and verify it returns to the previous page\n8. Functional Test: On Home Screen, perform a swipe right gesture and verify the app closes and returns to watchface\n9. Regression Test: Verify scoring functionality and game flow still works correctly after UI changes\n10. Touch Target Test: Ensure all new icon buttons are easily tappable with appropriate touch response",
        "status": "done",
        "dependencies": [
          "6",
          "7",
          "18",
          "22",
          "23"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove gray backgrounds from all page containers",
            "description": "Update all screen pages to remove gray background properties from container boxes/cards, setting them to transparent or removing the background property entirely.",
            "dependencies": [],
            "details": "Update page/index (Home Screen), page/game (Game Play Screen), Match Summary Screen, and Match History pages. Locate container boxes/cards with gray background properties and remove or set to transparent. Ensure text contrast and readability remains acceptable after background removal. Apply consistent background styling across all screens.",
            "status": "done",
            "testStrategy": "Visual inspection of all screens to confirm gray backgrounds are removed and text remains readable.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T10:47:07.546Z"
          },
          {
            "id": 2,
            "title": "Replace Back to Home button with house icon in Game Play screen",
            "description": "Locate the 'Back to Home' button element in the Game Play screen (page/game) and replace its text content with a house icon asset (home-icon.png).",
            "dependencies": [
              1
            ],
            "details": "In page/game, find the 'Back to Home' button element and replace text content with home-icon.png. Ensure the button maintains existing click handlers that navigate to home screen. Style icon button with appropriate touch target sizes (minimum 44x44px) for usability.",
            "status": "done",
            "testStrategy": "Tap the house icon button and verify it navigates to Home Screen with proper responsiveness.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T11:01:15.139Z"
          },
          {
            "id": 3,
            "title": "Replace Back to Home button with house icon in Match Summary screen",
            "description": "Locate and replace the 'Back to Home' text button in the Match Summary screen with a house icon button using the home-icon.png asset.",
            "dependencies": [
              2
            ],
            "details": "In Match Summary screen, find the 'Back to Home' text button and replace with home-icon.png. Ensure the button maintains existing click handlers that navigate to home screen. Apply consistent styling with the Game Play screen icon button (same touch target size and visual treatment).",
            "status": "done",
            "testStrategy": "Tap the house icon button on Match Summary screen and verify it navigates to Home Screen correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T11:10:56.974Z"
          },
          {
            "id": 4,
            "title": "Implement swipe-right-to-close gesture on Home Screen",
            "description": "Add gesture event listener to the Home Screen (page/index) for swipe right detection that calls the app exit API when triggered.",
            "dependencies": [
              3
            ],
            "details": "Add gesture event listener to page/index for swipe right detection. On swipe right event, call Zepp OS app exit API (app.exit() or wx.exitApp()). Ensure this gesture only triggers on home screen and doesn't interfere with other screen interactions. Set appropriate swipe threshold (e.g., minimum 100px distance) to prevent accidental triggers.",
            "status": "done",
            "testStrategy": "Swipe right on the Home Screen and verify the app properly closes and returns to the watchface. Verify other screens are not affected.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T11:15:04.179Z"
          },
          {
            "id": 5,
            "title": "Testing and verification of all UI enhancements",
            "description": "Perform comprehensive testing of all UI changes including background removal, icon button functionality, and swipe gesture behavior across all affected screens.",
            "dependencies": [
              4
            ],
            "details": "Perform visual inspection on all affected screens (Home, Game Play, Match Summary, Match History) to verify consistent styling. Verify all navigation flows remain intact after button changes. Test touch responsiveness of new icon buttons on both screens. Verify swipe-right-to-close only works on Home Screen. Check text contrast and readability after background removal.",
            "status": "done",
            "testStrategy": "Complete visual and functional test suite including navigation tests, touch target tests, gesture tests, and accessibility checks for text contrast.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T11:18:49.274Z"
          }
        ],
        "updatedAt": "2026-02-24T11:18:49.274Z"
      },
      {
        "id": "36",
        "title": "Delete Match from History",
        "description": "Implement functionality to delete individual matches from the match history by adding a bin icon alongside each history match entry in the match list.",
        "details": "Implement a delete mechanism for match history entries that allows users to remove specific completed matches. The implementation should:\n\n1. **UI Update - Add Delete Icon (delete-icon.png) to Match List**: Modify the existing match history list view (from Task 29) to include a trash/bin icon (delete-icon.png) button next to each match entry. The icon should be positioned on the right side of each history item and be easily tappable. (similar to this lists example: https://docs.zepp.com/docs/1.0/designs/template/list/ where the trash icon would be in the right side, in the place of the chevron)\n\n2. **Implement Delete Function**: Create a `deleteMatchFromHistory(matchId)` function that:\n   - Accepts the unique matchId of the match to delete\n   - Constructs the correct filename using the established pattern: `match_<matchId>.json`\n   - Uses the Zepp OS `hmFS` API to delete the file (e.g., `hmFS.removeAsset(path)`)\n   - Returns a boolean indicating success/failure\n   - Handles cases where the file doesn't exist gracefully\n\n3. **Handle Delete Action**: Add an event handler for the bin icon that:\n   - Calls `deleteMatchFromHistory()` with the appropriate matchId\n   - Shows a confirmation dialog (optional but recommended) before deletion to prevent accidental deletion\n   - Removes the item from the UI and refreshes the match history list\n   - Provides user feedback (e.g., toast message) confirming the deletion\n\n4. **Error Handling**: Implement proper error handling for:\n   - File system deletion failures\n   - Corrupted or missing history files\n   - Race conditions (if multiple deletions are triggered quickly)\n\n5. **UI Considerations**: Ensure the bin icon:\n   - Has adequate touch target size (at least 44x44 pixels)\n   - Uses appropriate styling (red color for delete action)\n   - Doesn't interfere with navigation to match details (if clicking on the match itself views details)",
        "testStrategy": "1. UI Visibility Test: Navigate to the match history list and verify that a bin icon appears next to each match entry.\n\n2. Delete Functionality Test: Click the bin icon on a history item, confirm the deletion (if confirmation dialog exists), and verify the match is immediately removed from the list.\n\n3. Persistence Test: Delete a match, then restart the watch/app and navigate back to match history. Verify the deleted match no longer appears in the list.\n\n4. File System Verification Test: After deleting a match through the UI, programmatically check the file system to ensure the corresponding `match_<id>.json` file has been removed.\n\n5. Multiple Deletion Test: Delete several matches in succession and verify the UI updates correctly after each deletion without crashes or glitches.\n\n6. Edge Case Test: Attempt to delete the last remaining match in history and verify the UI handles the empty state gracefully (e.g., shows 'No matches' message).\n\n7. Error Handling Test: Mock a file system deletion failure and verify appropriate user feedback is displayed without crashing the app.",
        "status": "done",
        "dependencies": [
          "29"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Delete Icon to Match History List UI",
            "description": "Modify the existing match history list view from Task 29 to include a trash/bin icon (delete-icon.png) button next to each match entry positioned on the right side.",
            "dependencies": [],
            "details": "Update the match history list UI component to add a delete icon button to each list item. Position the icon on the right side where the chevron would typically be in Zepp OS list templates. Use the delete-icon.png resource file and ensure the icon is clearly visible against the list item background. Apply red color styling to indicate destructive action. Set minimum touch target size of 44x44 pixels for accessibility.",
            "status": "done",
            "testStrategy": "Navigate to match history list and verify that a bin icon appears next to each match entry. Verify icon positioning is on the right side of each item. Check that icon styling uses appropriate red color.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T15:00:47.022Z"
          },
          {
            "id": 2,
            "title": "Implement deleteMatchFromHistory Function",
            "description": "Create the core deleteMatchFromHistory(matchId) function that uses Zepp OS hmFS API to delete match files by matchId.",
            "dependencies": [],
            "details": "Implement deleteMatchFromHistory(matchId) function in the storage service. The function should: accept a unique matchId parameter, construct the filename using pattern 'match_<matchId>.json', use hmFS.removeAsset(path) or appropriate hmFS API to delete the file, return true on successful deletion or false on failure, gracefully handle cases where the file doesn't exist by returning false rather than throwing an error, and log any unexpected errors for debugging.",
            "status": "done",
            "testStrategy": "Unit test the function with valid matchId to verify file deletion. Test with non-existent matchId to verify graceful handling. Test return values for both success and failure scenarios.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T15:00:47.026Z"
          },
          {
            "id": 3,
            "title": "Implement Delete Confirmation Dialog",
            "description": "Add a confirmation dialog that appears before deletion to prevent accidental deletion of match history entries.",
            "dependencies": [
              1
            ],
            "details": "Create a confirmation dialog component using Zepp OS dialog APIs. The dialog should display when a user taps the delete icon, showing a clear message like 'Delete this match?' with 'Cancel' and 'Delete' buttons. The dialog should be modal and capture user focus. On 'Delete', proceed with the deletion action. On 'Cancel', close the dialog without any changes. Style the Delete button in red to reinforce destructive action intent.",
            "status": "done",
            "testStrategy": "Tap delete icon and verify confirmation dialog appears. Test both Cancel and Delete button behaviors. Verify dialog is modal and blocks other interactions. Verify Cancel closes dialog without deletion.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T15:00:47.036Z"
          },
          {
            "id": 4,
            "title": "Wire Delete Icon Click Event Handler",
            "description": "Add event listeners to delete icons that trigger the confirmation dialog and handle the deletion flow.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement click/tap event handlers for the delete icon buttons in the match history list. Each handler should: retrieve the associated matchId from the list item data, trigger the confirmation dialog, wait for user confirmation, on confirmation call deleteMatchFromHistory(matchId), and prepare for UI refresh. Ensure the matchId is correctly extracted from each list item's context. Store reference to the list item being deleted for later UI removal.",
            "status": "done",
            "testStrategy": "Click delete icon on various match entries and verify correct matchId is passed. Verify confirmation appears before any deletion action. Test tapping multiple delete icons to ensure correct data association.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T15:00:47.039Z"
          },
          {
            "id": 5,
            "title": "Refresh UI After Successful Deletion",
            "description": "Implement UI update logic to remove deleted items from the match history list and refresh the display.",
            "dependencies": [
              2,
              4
            ],
            "details": "After successful deletion, update the match history list UI to remove the deleted item. Options include: removing the specific list item element from the DOM with animation, or reloading the entire match history list from storage. Prefer removing the item directly for better performance and user experience. Add a fade-out or slide animation for smooth deletion. Ensure the list layout adjusts properly after item removal. Update any match count displays if present.",
            "status": "done",
            "testStrategy": "Delete a match and verify it immediately disappears from the UI. Verify remaining items shift up correctly. Test deleting multiple items sequentially. Test deleting the last item in list.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T15:00:47.041Z"
          },
          {
            "id": 6,
            "title": "Implement Error Handling and User Feedback",
            "description": "Add comprehensive error handling for deletion failures and provide user feedback via toast messages.",
            "dependencies": [
              2,
              5
            ],
            "details": "Implement error handling for: file system deletion failures, corrupted or missing history files, and race conditions from rapid deletions. Show toast messages for user feedback: 'Match deleted' on success, 'Failed to delete match' on failure, and 'Match not found' for non-existent files. Prevent multiple simultaneous deletion attempts on the same item by disabling the delete button during active deletion. Ensure toast messages are displayed with appropriate duration and styling.",
            "status": "done",
            "testStrategy": "Simulate file system errors and verify error toast appears. Test rapid tapping of delete icon to verify race condition prevention. Verify success toast appears after successful deletion.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T15:00:47.043Z"
          },
          {
            "id": 7,
            "title": "Testing and Documentation Updates",
            "description": "Write comprehensive tests for the delete functionality and update project documentation.",
            "dependencies": [
              5,
              6
            ],
            "details": "Write unit tests for deleteMatchFromHistory function covering success, failure, and edge cases. Create integration tests for the complete delete flow from UI click to file removal. Perform manual UI testing on device/simulator to verify touch target sizes, icon positioning, and overall usability. Update README.md to document the new delete match history feature, including how to use it and any limitations. Add the delete-icon.png to assets documentation if applicable.",
            "status": "done",
            "testStrategy": "Run full test suite including unit and integration tests. Perform manual testing on actual device or emulator. Verify documentation accurately describes the feature and usage.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T15:00:47.044Z"
          }
        ],
        "updatedAt": "2026-02-24T15:00:47.044Z"
      },
      {
        "id": "37",
        "title": "Cancel Ongoing Game",
        "description": "Implement a cancel game feature on the game play screen with a bin icon button that deletes the current active match state and navigates back to the home screen.",
        "details": "1. **UI Update - Add Cancel Button to Game Screen**: Modify the Game Screen to include a bin/trash icon button positioned alongside the existing home icon button. The icon should be clearly visible and tappable, using a standard trash icon asset.\n\n2. **Implement Cancel Handler**: Create an `cancelCurrentMatch()` function that handles the cancellation flow:\n   - Optionally display a confirmation dialog (e.g., 'Are you sure you want to cancel this match?') to prevent accidental cancellations\n   - Delete the persisted match state from storage by removing the 'ACTIVE_MATCH_SESSION' key using the persistence service (Task 12)\n   - Clear any in-memory state manager references to the active match\n   - Navigate to the Home Screen\n\n3. **Reuse Cleanup Logic**: Leverage or reference the cleanup pattern established in Task 19 (New Match Reset and Cleanup) to ensure consistency in how active sessions are terminated.\n\n4. **Error Handling**: Implement graceful handling for edge cases such as:\n   - Storage deletion failures\n   - Missing or corrupted match state\n   - Navigation errors\n\n5. **State Verification**: Ensure that after cancellation, the Home Screen properly recognizes that no active match exists and does not display the 'Resume Game' button.",
        "testStrategy": "1. **UI Visibility Test**: Navigate to the Game Screen and verify that a bin icon appears alongside the home icon button.\n\n2. **Basic Cancellation Test**: Start a new match, score a few points, then click the bin icon. Verify the game is cancelled and you are returned to the Home Screen.\n\n3. **State Cleanup Test**: After cancelling, verify that the 'Resume Game' button does NOT appear on the Home Screen, confirming the active match state was properly deleted.\n\n4. **Fresh Start Test**: Cancel an active game, then immediately start a new match. Verify the match starts fresh with scores at 0-0 and no data from the cancelled game.\n\n5. **Confirmation Dialog Test**: If a confirmation dialog is implemented, verify that clicking 'Cancel' or 'No' keeps the game running, while clicking 'Confirm' or 'Yes' proceeds with cancellation.\n\n6. **Edge Case Test**: Attempt to cancel at different game stages (just started, mid-match, near completion) and verify consistent behavior.\n\n7. **Storage Verification Test**: Use storage inspection tools to verify that the 'ACTIVE_MATCH_SESSION' key is removed after cancellation.",
        "status": "cancelled",
        "dependencies": [
          "12",
          "19"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-24T21:59:58.589Z"
      },
      {
        "id": "38",
        "title": "Implement Multi-Language Support for Portuguese and Spanish",
        "description": "Add comprehensive multi-language support for Portuguese and Spanish with automatic device language detection and English fallback, including translation of all UI text strings across the application.",
        "details": "Implement a localization system for the Padel scoring app with the following components:\n\n1. **Translation Infrastructure**: Create a `LocalizationService` module that manages language resources. Define a translation dictionary structure containing key-value pairs for all UI text in the app (English, Portuguese, Spanish). Store translations in JSON files or objects organized by language code (en, pt, es).\n\n2. **Language Detection**: Implement automatic language detection using Zepp OS device settings API (e.g., `hmSystem.getDeviceInfo().language` or similar). Parse the device language code and map it to supported languages:\n   - 'pt' or 'pt-PT' or 'pt-BR'  Portuguese\n   - 'es' or 'es-ES'  Spanish\n   - Any other  English (default/fallback)\n\n3. **Translation Keys**: Identify all text strings in the application that need translation:\n   - Home Screen: 'Resume Game', 'New Game', 'Previous Matches'\n   - Setup Screen: 'Match Setup', '1 Set', '3 Sets', '5 Sets', instructions\n   - Game Screen: Score labels, team names, 'Undo' button\n   - Summary Screen: 'Team A Wins', 'Set 1:', 'Home', 'Start New Game'\n   - History Screen: 'Previous Matches', date/time formats, delete confirmation\n   - General: 'Confirm', 'Cancel', 'Back', any toast messages or alerts\n\n4. **Translation Function**: Create a `t(key, params)` function that:\n   - Takes a translation key and optional parameters for dynamic values\n   - Returns the translated string based on current language\n   - Falls back to English if key is missing in target language\n   - Handles parameter interpolation (e.g., 'Team {name} Wins')\n\n5. **Language Persistence**: Store the selected/detected language in settings storage using the persistence service from Task 12. This allows manual language override (if needed) and consistent behavior across app restarts.\n\n6. **UI Integration**: Update all UI components to use the translation function instead of hardcoded strings. This includes:\n   - Screen titles and labels\n   - Button text\n   - Status messages and toasts\n   - Date/time formatting (may need locale-specific formatting)\n\n7. **Implementation Structure**:\n   ```javascript\n   // translations/en.json, translations/pt.json, translations/es.json\n   {\n     \"home.resumeGame\": \"Resume Game\",\n     \"home.newGame\": \"New Game\",\n     \"setup.title\": \"Match Setup\",\n     \"setup.sets\": \"Sets\",\n     \"summary.teamWins\": \"Team {team} Wins\",\n     ...\n   }\n   \n   // LocalizationService.js\n   class LocalizationService {\n     constructor() {\n       this.currentLang = this.detectLanguage();\n       this.translations = this.loadTranslations(this.currentLang);\n     }\n     \n     detectLanguage() {\n       const deviceLang = hmSystem.getDeviceInfo().language || 'en';\n       if (deviceLang.startsWith('pt')) return 'pt';\n       if (deviceLang.startsWith('es')) return 'es';\n       return 'en';\n     }\n     \n     t(key, params = {}) {\n       let text = this.translations[key] || this.english[key] || key;\n       Object.keys(params).forEach(param => {\n         text = text.replace(`{${param}}`, params[param]);\n       });\n       return text;\n     }\n   }\n   ```",
        "testStrategy": "1. **Language Detection Test**: Change device language settings to Portuguese and launch the app. Verify all UI text displays in Portuguese. Repeat for Spanish. Test with unsupported languages (e.g., German, French) and verify English is used as fallback.\n\n2. **Translation Coverage Test**: Navigate through all screens (Home, Setup, Game, Summary, History) and verify every text element is properly translated. Check for any missing translations or English fallbacks where they shouldn't be.\n\n3. **Persistence Test**: Set device language to Spanish, launch the app, then restart. Verify Spanish is maintained after restart. Change device language to Portuguese and verify the app updates on next launch.\n\n4. **Parameter Interpolation Test**: Complete a match and verify dynamic text like 'Team A Wins' displays correctly in all three languages. Check date/time formatting in the history list for proper locale formatting.\n\n5. **Edge Case Test**: Test with partial locale codes (e.g., 'pt' without country) and verify it correctly maps to Portuguese. Ensure no crashes or errors occur if translation files are missing keys.\n\n6. **Visual QA**: Take screenshots of all screens in English, Portuguese, and Spanish to verify text fits properly within UI elements and doesn't cause layout issues or text overflow.",
        "status": "done",
        "dependencies": [
          "13",
          "17",
          "18",
          "29"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Translation Dictionary Structure and JSON Files",
            "description": "Define the translation dictionary structure and create JSON files for English, Portuguese, and Spanish containing all UI text keys.",
            "dependencies": [],
            "details": "Create three JSON files (translations/en.json, translations/pt.json, translations/es.json) with key-value pairs for all UI text strings. Organize keys by screen/feature using dot notation (e.g., 'home.resumeGame', 'setup.title'). Include translations for: Home Screen (Resume Game, New Game, Previous Matches), Setup Screen (Match Setup, 1 Set, 3 Sets, 5 Sets, instructions), Game Screen (score labels, team names, Undo), Summary Screen (Team A Wins, Set 1:, Home, Start New Game), History Screen (Previous Matches, delete confirmation), and General UI elements (Confirm, Cancel, Back, toast messages).",
            "status": "done",
            "testStrategy": "Verify JSON files are valid and contain all required translation keys. Check that each language file has matching keys.",
            "updatedAt": "2026-02-24T22:25:20.338Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement LocalizationService with Automatic Language Detection",
            "description": "Create the LocalizationService class that manages language resources and implements automatic device language detection using Zepp OS API.",
            "dependencies": [],
            "details": "Create LocalizationService.js class with constructor that initializes currentLang by calling detectLanguage(). Implement detectLanguage() method using hmSystem.getDeviceInfo().language API to retrieve device language. Parse the language code and map: 'pt', 'pt-PT', 'pt-BR' to 'pt'; 'es', 'es-ES' to 'es'; any other value defaults to 'en'. Add loadTranslations(langCode) method to load the appropriate JSON file. Store English translations as fallback reference.",
            "status": "done",
            "testStrategy": "Test with device set to Portuguese, Spanish, and unsupported languages. Verify correct language detection and default to English for unsupported languages.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T22:31:17.727Z"
          },
          {
            "id": 3,
            "title": "Implement Translation Function with Parameter Interpolation",
            "description": "Create the t() translation function that supports parameter interpolation and falls back to English for missing translation keys.",
            "dependencies": [
              2
            ],
            "details": "Implement t(key, params = {}) method in LocalizationService that takes a translation key and optional parameters object. The function should first look up the key in current language translations, then fall back to English translations, then return the key itself if not found. For parameter interpolation, replace placeholders like {team} or {name} with corresponding values from params object using string replacement. Example: 'Team {team} Wins' with params {team: 'A'} returns 'Team A Wins'.",
            "status": "done",
            "testStrategy": "Test t() function with valid keys, missing keys, and parameter interpolation. Verify English fallback works for missing translations in pt/es.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T22:38:18.202Z"
          },
          {
            "id": 4,
            "title": "Implement Language Persistence in Settings Storage",
            "description": "Store the detected or selected language in persistent storage to maintain language preference across app restarts and enable manual override.",
            "dependencies": [
              2
            ],
            "details": "Using the persistence service from Task 12, implement language storage functionality. Add methods to LocalizationService: saveLanguagePreference(langCode) that stores the language code in settingsStorage, loadLanguagePreference() that retrieves stored language, and setLanguage(langCode) for manual override. Modify detectLanguage() to check stored preference first before falling back to device language. This allows users to override automatic detection if desired and ensures consistent language selection across app sessions.",
            "status": "done",
            "testStrategy": "Test that language preference persists after app restart. Verify manual override takes precedence over device language detection.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T22:50:12.378Z"
          },
          {
            "id": 5,
            "title": "Update UI Components to Use Translation Function",
            "description": "Replace all hardcoded text strings across the application with calls to the translation function for dynamic multi-language support.",
            "dependencies": [
              3
            ],
            "details": "Update all UI components in the following screens: Home Screen - replace 'Resume Game', 'New Game', 'Previous Matches' with t('home.resumeGame'), etc.; Setup Screen - update 'Match Setup', set options (1 Set, 3 Sets, 5 Sets), and instructions; Game Screen - update score labels, team names, 'Undo' button; Summary Screen - update winner message, set labels, 'Home', 'Start New Game' buttons; History Screen - update title, date/time formats, delete confirmation; General elements - update 'Confirm', 'Cancel', 'Back' buttons, all toast messages and alerts. Also update date/time formatting to use locale-specific formats where applicable.",
            "status": "done",
            "testStrategy": "Manually review each screen to ensure all text is dynamically translated. Test that UI updates correctly when language changes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T22:50:14.096Z"
          },
          {
            "id": 6,
            "title": "Test Multi-Language Functionality and Coverage",
            "description": "Comprehensive testing of the multi-language implementation including language detection, translation coverage, and fallback behavior.",
            "dependencies": [
              4,
              5
            ],
            "details": "Perform language detection test: Change device language to Portuguese and launch app, verify all UI displays in Portuguese. Repeat for Spanish. Test with unsupported languages (German, French) and verify English is used as fallback. Perform translation coverage test: Navigate through all screens (Home, Setup, Game, Summary, History) and verify no hardcoded text remains visible. Test all buttons, labels, and messages. Verify parameter interpolation works correctly for dynamic text like 'Team {team} Wins'. Test toast messages and alerts display correctly in each language. Verify language persistence works by restarting the app after setting a specific language.",
            "status": "done",
            "testStrategy": "Systematic testing across all three supported languages and unsupported languages with English fallback. Document any missing translations or display issues.",
            "parentId": "undefined",
            "updatedAt": "2026-02-24T22:50:16.032Z"
          }
        ],
        "updatedAt": "2026-02-24T22:50:16.032Z"
      },
      {
        "id": "39",
        "title": "Implement Release and Changelog Generation with GitHub Actions",
        "description": "Research and implement an automated release and changelog generation system using GitHub Actions with semantic-release and conventional commits. This task enables automated versioning, changelog creation, and GitHub releases triggered by the npm run release command.",
        "details": "Implement a comprehensive release automation system using the conventional-commits and semantic-release approach, similar to the reference implementation at https://github.com/trystan2k/publish-blog-post/. The implementation includes:\n\n1. **Install and Configure Dependencies**:\n   - Install `semantic-release` and related plugins (`@semantic-release/git`, `@semantic-release/changelog`, `@semantic-release/npm`, `@semantic-release/github`)\n   - Configure `.releaserc` or `release.config.js` with appropriate settings for the Zepp OS/JavaScript project\n\n2. **Configure package.json Scripts**:\n   - Add `\"release\": \"semantic-release\"` script to package.json\n   - Ensure `version` field is managed by semantic-release (set to a placeholder like `0.0.0-semantically-released`)\n\n3. **Create GitHub Actions Workflow**:\n   - Create `.github/workflows/release.yml` workflow file\n   - Configure trigger: `on:\n  push:\n    tags:\n      - 'v*'`\n   - Set up job steps:\n     - Checkout code\n     - Setup Node.js environment\n     - Install dependencies\n     - Run semantic-release (which will create the GitHub release)\n\n4. **Configure Conventional Commits**:\n   - Add `commitlint` configuration to enforce conventional commit format\n   - Configure supported commit types: `feat`, `fix`, `docs`, `style`, `refactor`, `perf`, `test`, `chore`, `revert`\n   - Set up pre-commit hooks or CI checks to validate commit messages\n\n5. **Release Process Flow**:\n   - Developer runs `npm run release` locally or pushes commits with conventional commit messages\n   - Semantic-release analyzes commit history since last release\n   - Determines next version number based on commit types (major for breaking changes, minor for features, patch for fixes)\n   - Generates changelog from commit messages\n   - Creates git tag with version number\n   - Pushes changes to repository\n   - GitHub Actions workflow detects new tag and creates GitHub release with changelog\n\n6. **Changelog Configuration**:\n   - Configure changelog format and sections\n   - Include link to commit comparison in generated changelog\n   - Store changelog in `CHANGELOG.md` file\n\n7. **Branch Protection (Recommended)**:\n   - Configure main branch to require pull request reviews\n   - Enable status checks for conventional commit validation. It is also important that it updates not only the version in package.json, but also in the app.json and in utils/version.js",
        "testStrategy": "1. **Local Script Test**: Run `npm run release` locally on the main branch. Verify the script executes without errors and provides appropriate output (e.g., 'no release needed' if no changes).\n\n2. **Conventional Commit Validation Test**: Create commits with various formats:\n   - Valid: `feat: add new scoring logic`\n   - Valid: `fix: resolve crash on game start`\n   - Valid: `feat(match-history): implement storage`\n   - Invalid: `add new feature` (should fail validation if commitlint is configured)\n   Verify that valid commits pass and invalid commits are rejected.\n\n3. **Version Bump Test**: Create a series of commits:\n   - `feat: add feature A`\n   - `fix: minor bug fix`\n   Push to main and trigger release. Verify version increments to `1.0.0` (from initial). Then:\n   - `feat: add feature B`  verify version bumps to `1.1.0`\n   - `fix: resolve bug`  verify version bumps to `1.1.1`\n   - `feat!: breaking change`  verify version bumps to `2.0.0`\n\n4. **Changelog Generation Test**: After triggering a release, verify that:\n   - `CHANGELOG.md` is updated with new version section\n   - Changelog includes proper categorization (Features, Bug Fixes, etc.)\n   - Commit messages are properly formatted in the changelog\n   - Links to commits and comparisons are included\n\n5. **GitHub Release Test**: Verify that:\n   - Git tags are created with correct version format (v1.0.0)\n   - GitHub Actions workflow triggers on tag push\n   - GitHub Release is created with:\n     - Correct version tag\n     - Changelog as release notes\n     - Proper release title\n\n6. **No Release Scenario Test**: Make a commit with type `chore:` or `docs:` that doesn't trigger a release. Run `npm run release` and verify no new release is created and the version remains unchanged.\n\n7. **End-to-End Integration Test**: Complete the full flow:\n   - Create a feature branch with a conventional commit\n   - Create PR and merge to main\n   - Run `npm run release` locally or via CI\n   - Verify tag is pushed and GitHub Release is created automatically\n   - Verify project version in package.json is updated",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Install and Configure Semantic Release Dependencies",
            "description": "Install semantic-release and required plugins for automated versioning and changelog generation",
            "dependencies": [],
            "details": "Install semantic-release package along with @semantic-release/git, @semantic-release/changelog, @semantic-release/npm, and @semantic-release/github plugins using npm or yarn. Configure the plugins to work together for automated releases, changelog generation, and git operations.",
            "status": "done",
            "testStrategy": "Verify all packages are installed correctly by checking package.json devDependencies. Run npm list to confirm no peer dependency conflicts.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T01:28:50.088Z"
          },
          {
            "id": 2,
            "title": "Configure package.json and Release Config",
            "description": "Set up package.json scripts and create semantic-release configuration file with version management for multiple files",
            "dependencies": [
              1
            ],
            "details": "Update package.json to include 'release': 'semantic-release' script and set version to '0.0.0-semantically-released'. Create release.config.js or .releaserc configuring plugins to update versions in package.json, app.json, and utils/version.js files. Configure branch settings, tag format, and commit message conventions for the Zepp OS project.",
            "status": "done",
            "testStrategy": "Validate package.json JSON syntax. Verify release script exists. Confirm configuration file is valid JSON and contains proper plugin settings for all three versioned files.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T01:28:50.092Z"
          },
          {
            "id": 3,
            "title": "Create GitHub Actions Workflow for Release",
            "description": "Implement a GitHub Actions workflow that triggers on version tags and executes the release process",
            "dependencies": [
              2
            ],
            "details": "Create .github/workflows/release.yml with a single job triggered by push to tags matching 'v*'. Configure steps: checkout code with fetch-depth: 0, setup Node.js, install dependencies, run npm run release. Set GITHUB_TOKEN permissions for creating releases and managing repository contents. Ensure workflow runs on semantic-release tags only.",
            "status": "done",
            "testStrategy": "Validate workflow YAML syntax. Manually trigger workflow with a test tag to verify all steps execute without errors. Check workflow logs for successful completion and proper token authentication.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T01:28:50.094Z"
          },
          {
            "id": 4,
            "title": "Configure Conventional Commits Validation",
            "description": "Set up commitlint and commit message validation to enforce conventional commits format across the project",
            "dependencies": [],
            "details": "Install @commitlint/cli and @commitlint/config-conventional packages. Create commitlint.config.js defining supported commit types: feat, fix, docs, style, refactor, perf, test, chore, revert. Configure husky for pre-commit hooks or add CI check to validate commit messages. Ensure enforcement prevents non-conventional commits from being merged.",
            "status": "done",
            "testStrategy": "Create valid and invalid commit messages locally to verify validation works correctly. Test pre-commit hooks by attempting to commit non-conventional messages and confirming they're rejected. Verify CI check fails on invalid commits.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T01:28:50.096Z"
          },
          {
            "id": 5,
            "title": "Test and Verify Release Automation Flow",
            "description": "End-to-end testing of the release automation to ensure proper version updates, changelog generation, and GitHub releases",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Execute a test release by creating conventional commits on a feature branch, merging to main, and running npm run release locally in dry-run mode first. Then perform actual release with minor version bump. Verify versions update in package.json, app.json, and utils/version.js. Confirm CHANGELOG.md is generated/updated with proper format, commit comparison links, and git tags are created correctly.",
            "status": "done",
            "testStrategy": "Run npm run release --dry-run to preview changes without committing. Perform actual release and verify: all three version files updated, CHANGELOG.md contains correct entries with links, git tag created in correct format, and GitHub release includes changelog content.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T01:28:50.098Z"
          }
        ],
        "updatedAt": "2026-02-25T01:28:50.098Z"
      },
      {
        "id": "40",
        "title": "Create Centralized Design Tokens Utility",
        "description": "Implement utils/design-tokens.js with centralized design tokens for colors, typography, spacing, and sizing, along with helper functions to access tokens dynamically.",
        "details": "Create a new file at `utils/design-tokens.js` that exports a TOKENS object and helper functions. The TOKENS object must contain the following categories:\n\n**colors:** background, text, mutedText, accent, danger, primaryButton, secondaryButton, disabled, divider\n\n**typography:** pageTitle (0.0825), sectionTitle (0.068), body (0.055), bodyLarge (0.08), score (0.11), scoreDisplay (0.28), caption (0.036), button (0.05), buttonLarge (0.055)\n\n**spacing:** pageTop (0.05), pageBottom (0.06), pageSide (0.07), pageSideRound (0.12), sectionGap (0.02), headerTop (0.04), headerToContent (0.06), footerBottom (0.07)\n\n**sizing:** iconSmall (24), iconMedium (32), iconLarge (48), buttonHeight (0.105), buttonHeightLarge (0.15), buttonRadiusRatio (0.5), minTouchTarget (48)\n\nAll values should be standardized across the applicationdo not preserve page-specific differences. Use a flat object structure to prepare for future theming capabilities (document that theming is planned but not implemented yet).\n\n**Helper Functions to Implement:**\n1. `getColor(path)` - Accepts a dot-notation path string (e.g., 'colors.accent') and returns the corresponding token value. Include error handling for invalid paths.\n\n2. `getFontSize(typographyKey, screenWidth)` - Accepts a typography key (e.g., 'pageTitle') and screenWidth value, returns the calculated pixel value by multiplying the typography ratio by screenWidth.",
        "testStrategy": "No QA validation required as this is a foundation file with no pages consuming it yet. Verify the file compiles without syntax errors and that the TOKENS object structure matches the requirements exactly. Manual verification can be done by importing the file in a test script and calling the helper functions with valid inputs to ensure they return expected values.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create design-tokens.js file structure",
            "description": "Initialize the utils/design-tokens.js file with the base TOKENS object structure containing empty categories",
            "dependencies": [],
            "details": "Create a new JavaScript file at utils/design-tokens.js. Define a TOKENS constant object with four category keys: colors, typography, spacing, and sizing. Each category should be an empty object. Add a comment at the top indicating that theming capabilities are planned but not yet implemented. Export the TOKENS object for use in other modules.",
            "status": "done",
            "testStrategy": "Verify the file compiles without syntax errors and that TOKENS object exists with four empty category properties when imported.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T14:37:52.868Z"
          },
          {
            "id": 2,
            "title": "Implement color tokens in TOKENS object",
            "description": "Add all color token values to the TOKENS.colors category with standardized values",
            "dependencies": [
              1
            ],
            "details": "Populate TOKENS.colors with the following properties and their corresponding color values: background, text, mutedText, accent, danger, primaryButton, secondaryButton, disabled, divider. Use standardized color values that will be consistent across the application. The actual color values should be determined based on the application's design system requirements.",
            "status": "done",
            "testStrategy": "Verify that all 9 color properties exist in TOKENS.colors and each property has a valid string color value.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T14:37:52.881Z"
          },
          {
            "id": 3,
            "title": "Implement typography tokens in TOKENS object",
            "description": "Add all typography ratio tokens to the TOKENS.typography category",
            "dependencies": [
              1
            ],
            "details": "Populate TOKENS.typography with the following properties and ratio values: pageTitle (0.0825), sectionTitle (0.068), body (0.055), bodyLarge (0.08), score (0.11), scoreDisplay (0.28), caption (0.036), button (0.05), buttonLarge (0.055). These values represent ratios used to calculate font sizes relative to screen width.",
            "status": "done",
            "testStrategy": "Verify that all 9 typography properties exist in TOKENS.typography with the exact specified ratio values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T14:37:52.885Z"
          },
          {
            "id": 4,
            "title": "Implement spacing and sizing tokens in TOKENS object",
            "description": "Add spacing ratio tokens and sizing dimension tokens to their respective categories",
            "dependencies": [
              1
            ],
            "details": "Populate TOKENS.spacing with: pageTop (0.05), pageBottom (0.06), pageSide (0.07), pageSideRound (0.12), sectionGap (0.02), headerTop (0.04), headerToContent (0.06), footerBottom (0.07). Populate TOKENS.sizing with: iconSmall (24), iconMedium (32), iconLarge (48), buttonHeight (0.105), buttonHeightLarge (0.15), buttonRadiusRatio (0.5), minTouchTarget (48). These represent dimension ratios and pixel values.",
            "status": "done",
            "testStrategy": "Verify that all 8 spacing properties and 7 sizing properties exist with the exact specified values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T14:37:52.887Z"
          },
          {
            "id": 5,
            "title": "Implement helper functions getColor and getFontSize",
            "description": "Create helper functions to dynamically access design tokens with error handling",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Implement getColor(path) function that accepts dot-notation string (e.g., 'colors.accent') and returns the corresponding token value. Include error handling that throws or returns undefined for invalid paths. Implement getFontSize(typographyKey, screenWidth) that accepts a typography key and screen width, then returns the calculated pixel value by multiplying the typography ratio by screenWidth. Export both functions.",
            "status": "done",
            "testStrategy": "Test getColor with valid paths returns correct values and invalid paths handles gracefully. Test getFontSize with various typography keys and screen widths to verify correct pixel calculations.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T14:37:52.890Z"
          }
        ],
        "updatedAt": "2026-02-25T14:37:52.890Z"
      },
      {
        "id": "41",
        "title": "Create Screen Utilities with Round Screen Handling",
        "description": "Implement utils/screen-utils.js providing essential screen measurement utilities and round screen geometry calculations to support adaptive layouts across different device shapes.",
        "details": "Create a new file at `utils/screen-utils.js` with the following utility functions:\n\n1. **getScreenMetrics()**: Returns an object with screen properties:\n   - `width`: Screen width from hmUI.getScreenMetrics()\n   - `height`: Screen height from hmUI.getScreenMetrics()\n   - `isRound`: Boolean calculated as `Math.abs(width - height) <= Math.round(width * 0.04)`\n\n2. **clamp(value, min, max)**: Constrains a value within a specified range.\n   - Return `Math.max(min, Math.min(max, value))`\n   - Useful for keeping positions within screen bounds\n\n3. **ensureNumber(value, fallback)**: Validates that a value is a valid number.\n   - Return `value` if typeof is 'number' and not NaN\n   - Otherwise return `fallback` (default to 0 if not provided)\n\n4. **pct(screenDimension, percentage)**: Converts percentage to pixels.\n   - Calculate `screenDimension * percentage`\n   - `percentage` can be 0-1 or 0-100 (handle both)\n\n5. **getRoundSafeInset(width, height, y, padding)**: Calculates safe inset for round screens at specific Y position.\n   - Use circle geometry to find chord at Y position\n   - Algorithm: \n     - `centerX = width / 2`\n     - `radius = width / 2`\n     - `yFromCenter = y - (height / 2)`\n     - `halfChord = Math.sqrt(radius * radius - yFromCenter * yFromCenter)`\n     - Return `Math.max(0, centerX - halfChord + padding)`\n\n6. **getRoundSafeSectionInset(width, height, sectionTop, sectionHeight, padding)**: Calculates safe inset for an entire section.\n   - Call getRoundSafeInset for both top and bottom of section\n   - Return the maximum inset value to ensure full section fits\n\nAll functions should be exported for use in pages and other utility files.",
        "testStrategy": "As a foundation utility file, verify:\n1. The file compiles without syntax errors using Node.js or the Zepp build system\n2. Import the file in a test script and verify all exported functions exist\n3. Test getScreenMetrics() returns valid numbers and correct isRound detection\n4. Verify clamp() handles edge cases (value below min, above max, within range)\n5. Test ensureNumber() with NaN, undefined, strings, and valid numbers\n6. Verify pct() correctly converts percentages (both 0-1 and 0-100 formats)\n7. Validate getRoundSafeInset() returns 0 for square screens and positive values for round screens\n8. Confirm getRoundSafeSectionInset() returns the maximum inset across the section bounds\nNo full UI QA required as this is a standalone utility with no direct user interface.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create screen-utils.js file with basic utility functions",
            "description": "Create the utils/screen-utils.js file and implement the three foundational utility functions: clamp(), ensureNumber(), and pct(). These are independent helper functions that don't depend on screen metrics or round screen logic.",
            "dependencies": [],
            "details": "Create utils/screen-utils.js file. Implement clamp(value, min, max) returning Math.max(min, Math.min(max, value)). Implement ensureNumber(value, fallback) returning value if typeof is 'number' and not NaN, otherwise return fallback (default 0). Implement pct(screenDimension, percentage) calculating screenDimension * percentage, handling both 0-1 and 0-100 ranges. Export all three functions.",
            "status": "done",
            "testStrategy": "Test clamp() with values below min, above max, and within range. Test ensureNumber() with valid numbers, NaN, strings, and undefined to verify fallback behavior. Test pct() with both decimal (0.5) and percentage (50) formats to confirm they produce the same pixel result.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T15:35:04.549Z"
          },
          {
            "id": 2,
            "title": "Implement getScreenMetrics function",
            "description": "Implement the getScreenMetrics() function that retrieves screen dimensions from the Zepp OS API and determines whether the screen is round based on the aspect ratio tolerance formula.",
            "dependencies": [],
            "details": "Add getScreenMetrics() function to screen-utils.js. Call hmUI.getScreenMetrics() to retrieve width and height. Calculate isRound as Math.abs(width - height) <= Math.round(width * 0.04). Return object with width, height, and isRound properties. Export the function.",
            "status": "done",
            "testStrategy": "Verify function returns object with width, height (numbers), and isRound (boolean). Test with round screen dimensions (equal width/height) expecting isRound=true. Test with square rectangular screens expecting isRound=false when difference exceeds 4% threshold.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T15:35:04.553Z"
          },
          {
            "id": 3,
            "title": "Implement getRoundSafeInset function",
            "description": "Implement the getRoundSafeInset() function using circle geometry to calculate the horizontal inset needed at a specific Y position on a round screen to prevent content from being clipped.",
            "dependencies": [],
            "details": "Add getRoundSafeInset(width, height, y, padding) function. Calculate centerX = width / 2, radius = width / 2, yFromCenter = y - (height / 2). Calculate halfChord = Math.sqrt(radius * radius - yFromCenter * yFromCenter). Return Math.max(0, centerX - halfChord + padding). Export the function.",
            "status": "done",
            "testStrategy": "Test at y=0 (top edge) expecting minimum inset. Test at y=height/2 (center) expecting inset=padding or 0. Test at y=height (bottom edge) expecting minimum inset. Verify negative values are never returned (Math.max(0, ...)).",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T15:35:04.555Z"
          },
          {
            "id": 4,
            "title": "Implement getRoundSafeSectionInset function",
            "description": "Implement getRoundSafeSectionInset() function that calculates the maximum safe inset needed for an entire vertical section on a round screen by checking both top and bottom boundaries.",
            "dependencies": [],
            "details": "Add getRoundSafeSectionInset(width, height, sectionTop, sectionHeight, padding) function. Call getRoundSafeInset(width, height, sectionTop, padding) for top edge. Call getRoundSafeInset(width, height, sectionTop + sectionHeight, padding) for bottom edge. Return Math.max(topInset, bottomInset) to ensure entire section fits. Export the function.",
            "status": "done",
            "testStrategy": "Test with sections at top of screen expecting larger inset. Test with sections at center expecting smaller inset. Test with full-height section expecting inset based on most constrained edge (top or bottom). Verify returned value is never negative.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T15:35:04.557Z"
          },
          {
            "id": 5,
            "title": "Test and validate all screen utility functions",
            "description": "Perform comprehensive testing of the screen-utils.js module to ensure all functions work correctly together, the file compiles without errors, and all exports are properly accessible.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Import all functions from screen-utils.js in a test script. Verify file compiles using Node.js or Zepp build system. Confirm all 6 functions are exported and callable. Test getScreenMetrics() with mock hmUI.getScreenMetrics() return values. Test round screen calculations with various screen dimensions. Validate edge cases for all utility functions including boundary values and invalid inputs.",
            "status": "done",
            "testStrategy": "1. Syntax verification: ensure no compilation errors. 2. Export verification: confirm getScreenMetrics, clamp, ensureNumber, pct, getRoundSafeInset, getRoundSafeSectionInset are all exported. 3. Integration test: call getRoundSafeSectionInset which internally uses getRoundSafeInset to verify function interaction works correctly. 4. Test with real hmUI.getScreenMetrics() if available in simulator.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T15:35:04.560Z"
          }
        ],
        "updatedAt": "2026-02-25T15:35:04.560Z"
      },
      {
        "id": "42",
        "title": "Create Layout Engine with Declarative Resolution",
        "description": "Implement utils/layout-engine.js with a declarative layout system that resolves schemas to pixel coordinates, supporting sections and elements with percentage, pixel, and reference-based positioning.",
        "details": "Create a new file at `utils/layout-engine.js` that exports the following functionality:\n\n**Main Function**:\n- `resolveLayout(schema, metrics)` - Takes a schema object and screen metrics, returns resolved coordinates\n\n**Input Schema Structure**:\n```javascript\n{\n  sections: {\n    [sectionName]: {\n      top: string | number,      // '10%', 'header.bottom', 'header.bottom + 2%', 50\n      bottom: string | number,   // percentage from bottom (optional)\n      after: string,             // section name to position after (optional)\n      gap: number,               // gap after previous section in pixels (optional)\n      height: string | number,   // '10%', 'fill', or pixels (optional)\n      sideInset: string | number, // percentage or pixels (optional)\n      roundSafeInset: boolean    // default true (optional)\n    }\n  },\n  elements: {\n    [elementName]: {\n      section: string,           // parent section name\n      x: string | number,        // percentage or pixels (optional)\n      y: string | number,        // percentage or pixels (optional)\n      width: string | number,    // percentage or pixels (optional)\n      height: string | number,   // percentage or pixels (optional)\n      align: 'center' | 'left' | 'right' (optional)\n    }\n  }\n}\n```\n\n**Return Structure**:\n```javascript\n{\n  sections: {\n    [sectionName]: { x, y, w, h }\n  },\n  elements: {\n    [elementName]: { x, y, w, h }\n  }\n}\n```\n\n**Position Resolution Logic**:\n- Parse string values ending with '%' and convert using: `Math.round(dimension * percentage / 100)`\n- Parse section references (e.g., 'header.bottom'): `sections.header.y + sections.header.h`\n- Parse expressions with references and offsets (e.g., 'header.bottom + 2%')\n- Handle 'fill' height by calculating remaining space to next section or bottom\n- Literal numbers are treated as pixel values\n\n**Element Alignment**:\n- 'center': center horizontally within section bounds\n- 'left': position at section x (default)\n- 'right': position at `section.x + section.w - element.w`\n\n**Error Handling (Graceful Fallbacks)**:\n- Invalid section references: fallback to 0\n- Missing sections in element properties: use full screen bounds\n- Invalid percentage values: clamp to 0-100% range\n- Any parsing errors: default to sensible defaults, never throw\n\n**Implementation Steps**:\n1. Import screen utilities from `utils/screen-utils.js` (getScreenMetrics, clamp)\n2. Create helper function `parseValue(value, dimension, sections)` to parse positioning values\n3. Create helper function `parsePercentage(value)` to extract numeric percentage\n4. Create helper function `resolveSectionRef(ref, sections)` to get referenced section bounds\n5. Implement section resolution pass: calculate all section positions first\n6. Implement element resolution pass: calculate element positions within their sections\n7. Apply roundSafeInset: round coordinates if true and screen is round\n8. Export the `resolveLayout` function\n\n**Code Example**:\n```javascript\nimport { getScreenMetrics, clamp } from './screen-utils.js';\n\nexport function resolveLayout(schema, metrics = getScreenMetrics()) {\n  const { width, height } = metrics;\n  const resolved = { sections: {}, elements: {} };\n  \n  // Resolve sections first\n  for (const [name, section] of Object.entries(schema.sections || {})) {\n    // ... section resolution logic\n  }\n  \n  // Then resolve elements\n  for (const [name, element] of Object.entries(schema.elements || {})) {\n    // ... element resolution logic\n  }\n  \n  return resolved;\n}\n```",
        "testStrategy": "1. **Syntax Verification**: Ensure the file compiles without syntax errors using Node.js or the Zepp build system.\n\n2. **Basic Resolution Test**: Import the file and test with a simple schema:\n   ```javascript\n   const schema = {\n     sections: {\n       header: { top: '0%', height: '10%' },\n       content: { after: 'header', gap: 5, height: 'fill' }\n     },\n     elements: {\n       title: { section: 'header', x: '50%', y: '0%', width: '50%', height: '100%', align: 'center' }\n     }\n   };\n   const result = resolveLayout(schema, { width: 400, height: 400, isRound: false });\n   ```\n   Verify result contains proper x, y, w, h values.\n\n3. **Reference Resolution Test**: Test that section references like 'header.bottom' correctly resolve to the bottom coordinate of the referenced section.\n\n4. **Fill Height Test**: Verify that 'fill' height correctly calculates remaining space between sections.\n\n5. **Error Handling Test**:\n   - Test with invalid section references - verify graceful fallback to 0\n   - Test with invalid percentages ('120%', '-5%') - verify clamping to 0-100%\n   - Test with missing parent sections - verify elements use full screen bounds\n\n6. **Expression Parsing Test**: Verify expressions like 'header.bottom + 2%' correctly calculate coordinates.\n\n7. **Alignment Test**: Test element alignment ('center', 'left', 'right') to ensure proper positioning within sections.",
        "status": "done",
        "dependencies": [
          "41"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create file structure and main function skeleton",
            "description": "Initialize utils/layout-engine.js with imports from screen-utils.js and set up the basic resolveLayout function structure that returns empty sections and elements objects.",
            "dependencies": [],
            "details": "Create the file utils/layout-engine.js and import getScreenMetrics and clamp from './screen-utils.js'. Define the resolveLayout function that accepts schema and metrics parameters. Extract width and height from metrics. Initialize and return a resolved object with empty sections and elements properties. Set up placeholder loops for sections and elements iteration.",
            "status": "done",
            "testStrategy": "Verify the file compiles without syntax errors and that calling resolveLayout({}, {}) returns { sections: {}, elements: {} }",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T16:41:28.787Z"
          },
          {
            "id": 2,
            "title": "Implement value parsing helper functions",
            "description": "Create parsePercentage, resolveSectionRef, and parseValue helper functions to handle percentage strings, section references, and complex positioning expressions.",
            "dependencies": [
              1
            ],
            "details": "Implement parsePercentage(value) to extract numeric values from strings ending with '%'. Implement resolveSectionRef(ref, sections) to parse references like 'header.bottom' and return the coordinate from resolved sections. Implement parseValue(value, dimension, sections) to handle: numeric pixel values, percentage strings (e.g., '10%'), section references (e.g., 'header.bottom'), and combined expressions (e.g., 'header.bottom + 2%'). All helpers should return 0 on parsing errors.",
            "status": "done",
            "testStrategy": "Test parsePercentage('10%') returns 10, parsePercentage('invalid') returns null. Test parseValue('50%', 100, {}) returns 50. Test resolveSectionRef('header.bottom', {header: {y: 0, h: 20}}) returns 20.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T16:41:30.170Z"
          },
          {
            "id": 3,
            "title": "Implement section resolution pass",
            "description": "Calculate all section positions by processing top, bottom, after, gap, and height properties, including support for 'fill' height and percentage-based positioning.",
            "dependencies": [
              2
            ],
            "details": "Iterate through schema.sections using Object.entries. For each section, calculate y position using parseValue on the 'top' property, or use the referenced section's bottom + gap if 'after' is specified. Calculate height using parseValue on 'height' property. Handle 'fill' height by calculating remaining space to the next section or screen bottom. Set x, w using sideInset if provided, defaulting to full width. Store resolved x, y, w, h in resolved.sections.",
            "status": "done",
            "testStrategy": "Test schema with header section {top: '0%', height: '10%'} resolves to correct pixel coordinates. Test 'after' property positions sections correctly with gaps. Test 'fill' height calculates remaining space correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T16:41:31.474Z"
          },
          {
            "id": 4,
            "title": "Implement element resolution pass",
            "description": "Calculate element positions within their parent sections, handling x, y, width, height properties and horizontal alignment (center, left, right).",
            "dependencies": [
              3
            ],
            "details": "Iterate through schema.elements using Object.entries. For each element, find its parent section from resolved.sections, defaulting to full screen bounds if missing. Calculate x using parseValue or section.x, y using parseValue or section.y. Calculate w and h using parseValue on width/height properties. Apply alignment: 'center' sets x to section.x + (section.w - w) / 2, 'right' sets x to section.x + section.w - w, 'left' uses section.x. Store resolved x, y, w, h in resolved.elements.",
            "status": "done",
            "testStrategy": "Test element with {section: 'header', width: '50%', align: 'center'} centers correctly within header. Test missing section defaults to full screen. Test all three alignment options produce correct positions.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T16:41:32.801Z"
          },
          {
            "id": 5,
            "title": "Add roundSafeInset handling and error fallbacks",
            "description": "Implement roundSafeInset rounding for round screens, add graceful fallbacks for invalid references, clamp percentage values, and finalize the module export.",
            "dependencies": [
              4
            ],
            "details": "Check metrics.isRound or similar to detect round screens. When roundSafeInset is true (default), apply Math.round to section coordinates. Add error handling: invalid section references fallback to 0, missing sections default to full screen bounds, invalid percentage values clamp to 0-100 using the imported clamp function. Ensure no parsing errors throw exceptions - all fallback to sensible defaults. Return the fully resolved object.",
            "status": "done",
            "testStrategy": "Test with round screen metrics verifies coordinates are rounded. Test invalid section reference 'nonexistent.top' defaults to 0. Test percentage '150%' clamps to 100%, '-10%' clamps to 0%. Test malformed strings like 'abc%' don't throw errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T16:41:34.136Z"
          }
        ],
        "updatedAt": "2026-02-25T16:41:34.136Z"
      },
      {
        "id": "43",
        "title": "Create Layout Presets Utility with Common Page Structure Schemas",
        "description": "Implement utils/layout-presets.js containing factory functions that return layout schemas for common page patterns following a strict 3-section structure (header, body, footer) with consistent spacing and round-safe inset handling.",
        "details": "Create a new file at `utils/layout-presets.js` that exports the following factory functions:\n\n**1. createStandardPageLayout(options)**\n- Returns a layout schema with header, body, and footer sections\n- Options parameter:\n  - hasHeader (default: true)\n  - hasFooter (default: true)\n  - headerHeight (default: TOKENS.typography.pageTitle * 2)\n  - footerHeight (default: TOKENS.typography.button * 2)\n- Header section: top='pageTop', height=headerHeight or 'auto', roundSafeInset=true\n- Body section: after='header', gap=TOKENS.spacing.headerToContent, height='fill', roundSafeInset=true\n- Footer section: bottom='footerBottom', height=footerHeight, roundSafeInset=false\n\n**2. createPageWithFooterButton(options)**\n- Returns standard layout with an icon button in the footer\n- Options parameter:\n  - icon (default: 'home-icon.png')\n  - onClick (function callback)\n- Extends createStandardPageLayout with additional footer element for the button\n- Button should be centered in footer area\n\n**3. createTwoColumnLayout(parentSection)**\n- Returns a schema with leftColumn and rightColumn sections nested under parentSection\n- Each column: width='50%', height='100%'\n- Used for game page score area display\n- Sets roundSafeInset: true for both columns\n\n**All presets must:**\n- Import and use TOKENS.spacing values (pageTop, pageBottom, headerToContent) from design-tokens.js\n- Set roundSafeInset: true for body sections to ensure content doesn't overlap bezel on round screens\n- Set roundSafeInset: false for footer sections (icon centering handles positioning)\n- Return schemas compatible with the layout-engine.js resolveLayout function",
        "testStrategy": "1. **Syntax Verification**: Ensure the file compiles without syntax errors using Node.js or the Zepp build system.\n\n2. **Schema Structure Test**: Import the file and verify each factory function returns a valid schema object that can be consumed by layout-engine.js:\n   - Test createStandardPageLayout() returns sections: header, body, footer\n   - Test createStandardPageLayout({hasHeader: false}) excludes header\n   - Test createStandardPageLayout({hasFooter: false}) excludes footer\n   - Test createPageWithFooterButton() includes all standard sections plus footer button\n   - Test createTwoColumnLayout('body') returns leftColumn and rightColumn nested under body\n\n3. **Token Integration Test**: Verify all schemas reference TOKENS.spacing values correctly:\n   ```javascript\n   import { TOKENS } from './design-tokens.js';\n   const schema = createStandardPageLayout();\n   // Verify spacing values from TOKENS are used\n   ```\n\n4. **Resolution Test**: Pass schemas to layout-engine.resolveLayout() with mock metrics to ensure they resolve without errors.",
        "status": "done",
        "dependencies": [
          "40",
          "42"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create layout-presets.js file with base imports and structure",
            "description": "Initialize the utils/layout-presets.js file with proper imports from design-tokens.js and set up the module export structure for all factory functions.",
            "dependencies": [],
            "details": "Create utils/layout-presets.js file at the root of utils directory. Import TOKENS object from '../utils/design-tokens.js'. Set up an empty exports object or module.exports that will contain createStandardPageLayout, createPageWithFooterButton, and createTwoColumnLayout functions. Add JSDoc comments at the top of the file explaining the utility's purpose and the strict 3-section structure requirement.",
            "status": "done",
            "testStrategy": "Verify the file compiles without syntax errors using Node.js or the Zepp build system. Confirm that the TOKENS import is successful by logging TOKENS.spacing values in a test import.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T23:44:27.521Z"
          },
          {
            "id": 2,
            "title": "Implement createStandardPageLayout factory function",
            "description": "Implement the core factory function that returns a layout schema with header, body, and footer sections based on the provided options.",
            "dependencies": [
              1
            ],
            "details": "Implement createStandardPageLayout(options) function with parameter destructuring for hasHeader (default: true), hasFooter (default: true), headerHeight (default: TOKENS.typography.pageTitle * 2), and footerHeight (default: TOKENS.typography.button * 2). Conditionally include header and footer sections based on hasHeader and hasFooter flags. Header: { top: TOKENS.spacing.pageTop, height: headerHeight or 'auto', roundSafeInset: true }. Body: { after: 'header', gap: TOKENS.spacing.headerToContent, height: 'fill', roundSafeInset: true }. Footer: { bottom: TOKENS.spacing.pageBottom, height: footerHeight, roundSafeInset: false }. Return schema object with sections property containing all configured sections.",
            "status": "done",
            "testStrategy": "Test with default options, hasHeader: false, and hasFooter: false combinations. Verify returned schema structure matches expected format with correct TOKENS values. Confirm body section always has roundSafeInset: true.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T23:44:30.687Z"
          },
          {
            "id": 3,
            "title": "Implement createPageWithFooterButton factory function",
            "description": "Extend the standard layout with an icon button element positioned in the footer area, centered horizontally.",
            "dependencies": [
              2
            ],
            "details": "Implement createPageWithFooterButton(options) function with parameter destructuring for icon (default: 'home-icon.png') and onClick (function callback). Call createStandardPageLayout internally to get the base schema. Add an elements property to the returned schema containing a footerButton object. Position the button in the footer section with horizontal centering using the layout engine's positioning capabilities. Ensure the button element references the footer section properly and includes the icon path and onClick handler in its metadata.",
            "status": "done",
            "testStrategy": "Verify the schema includes all standard layout sections plus the footer button element. Test that button positioning references footer section correctly and icon/onClick properties are passed through.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T23:44:33.813Z"
          },
          {
            "id": 4,
            "title": "Implement createTwoColumnLayout factory function",
            "description": "Create a layout schema with two nested columns (leftColumn and rightColumn) under a specified parent section, each at 50% width.",
            "dependencies": [
              1
            ],
            "details": "Implement createTwoColumnLayout(parentSection) function that accepts a parent section identifier string. Return a schema with leftColumn and rightColumn sections nested under the parent. Each column should have: width: '50%', height: '100%', roundSafeInset: true. The columns should be positioned relative to the parent section using the layout engine's parent-child syntax. Left column positioned at left edge, right column positioned at 50% or after leftColumn.",
            "status": "done",
            "testStrategy": "Verify both columns have identical width/height values and roundSafeInset: true. Test that columns position correctly when resolved under various parent section sizes using layout-engine.js.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T23:44:36.954Z"
          },
          {
            "id": 5,
            "title": "Create validation test suite for all layout presets",
            "description": "Create a comprehensive test script that validates all factory functions return schemas compatible with layout-engine.js and meet all specification requirements.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create tests/layout-presets.test.js file that imports all three factory functions and the layout-engine's resolveLayout function. Test cases: 1) Verify createStandardPageLayout returns valid schema structure, 2) Test all option variations (hasHeader/hasFooter false), 3) Verify createPageWithFooterButton extends standard correctly with button element, 4) Verify createTwoColumnLayout creates properly sized columns, 5) Test roundSafeInset values are correct (true for body/columns, false for footer), 6) Validate all schemas can be successfully resolved by resolveLayout with mock screen metrics. Log all test results.",
            "status": "done",
            "testStrategy": "Run the test suite and verify all tests pass. Ensure schemas resolve without errors using mock metrics for both round and square screen types. Manually inspect console output for any anomalies in spacing calculations.",
            "parentId": "undefined",
            "updatedAt": "2026-02-25T23:44:40.102Z"
          }
        ],
        "updatedAt": "2026-02-25T23:44:40.102Z"
      },
      {
        "id": "44",
        "title": "Create UI Components Utility with Reusable Widget Factories",
        "description": "Implement utils/ui-components.js containing reusable widget factory functions for common UI elements including backgrounds, cards, buttons, dividers, and text components, all using design tokens for consistent styling.",
        "details": "Create a new file at `utils/ui-components.js` that exports the following widget factory functions. All components must use TOKENS from utils/design-tokens.js for styling, accept standardized parameters (widget, bounds, options), and return the created widget.\n\n**1. createBackground(widget, metrics, color?)**\n- Creates a full-screen FILL_RECT widget\n- Default color: TOKENS.colors.background\n- Uses metrics.width and metrics.height for bounds\n\n**2. createCard(widget, bounds, options?)**\n- Creates a rounded FILL_RECT container\n- Default color: TOKENS.colors.cardBackground or TOKENS.colors.background\n- Options: color (default cardBackground), radiusRatio (default 0.07)\n- Radius calculation: bounds.h * radiusRatio\n\n**3. createDivider(widget, bounds, color?)**\n- Creates a FILL_RECT for horizontal or vertical dividers\n- Default color: TOKENS.colors.divider\n- Bounds determine orientation (width > height = horizontal, else vertical)\n\n**4. createButton(widget, bounds, options)**\n- Unified button factory supporting multiple variants\n- Required options: text, onClick\n- Optional options: variant ('primary', 'secondary', 'icon', 'danger'), visible (default true), disabled (default false), icon\n- Variant styling:\n  - Primary: color=TOKENS.colors.primaryButton, press_color=TOKENS.colors.primaryButtonPressed\n  - Secondary: color=TOKENS.colors.secondaryButton, press_color=TOKENS.colors.secondaryButtonPressed\n  - Icon: uses normal_src/press_src with icon option, no text\n  - Danger: color=TOKENS.colors.dangerButton, press_color=TOKENS.colors.dangerButtonPressed\n- Text size: getFontSize('buttonLarge', bounds.w)\n- Radius: bounds.h * TOKENS.sizing.buttonRadiusRatio (or default 0.2 if not in tokens)\n- Handle disabled state with grayed-out appearance\n\n**5. createText(widget, bounds, options)**\n- Generic text element factory\n- Required options: text\n- Optional options: style (typography key), color, align (default CENTER_H)\n- Uses getFontSize(style, bounds.w) for text_size\n- Default color: TOKENS.colors.text\n\n**6. createPageTitle(widget, bounds, text, options?)**\n- Helper for page-level titles\n- Style: 'pageTitle'\n- Default color: TOKENS.colors.text\n- Wraps createText with predefined style\n\n**7. createSectionTitle(widget, bounds, text, options?)**\n- Helper for section headers\n- Style: 'sectionTitle'\n- Default color: TOKENS.colors.mutedText\n- Wraps createText with predefined style\n\n**8. createBodyText(widget, bounds, text, options?)**\n- Helper for body paragraph text\n- Style: 'body'\n- Default color: TOKENS.colors.text\n- Wraps createText with predefined style\n\nAll functions must:\n- Import TOKENS from '../utils/design-tokens.js'\n- Use hmUI widget creation API\n- Return the created widget for chaining or reference\n- Validate required parameters",
        "testStrategy": "1. **Syntax Verification**: Ensure the file compiles without syntax errors using Node.js or the Zepp build system.\n\n2. **Import Test**: Create a test script that imports all 8 factory functions and verifies they exist.\n\n3. **TOKENS Integration**: Mock TOKENS object and verify each component correctly references TOKENS values for colors and typography.\n\n4. **Parameter Validation Test**: For each factory, test:\n   - Minimal required parameters work correctly\n   - Optional parameters properly apply defaults\n   - Missing required parameters throw appropriate errors\n\n5. **Component Output Test**: Mock hmUI.createWidget to verify:\n   - createBackground creates FILL_RECT with full-screen bounds\n   - createCard creates FILL_RECT with correct radius\n   - createButton creates TEXT widget with correct variant colors\n   - createText and helpers create TEXT widgets with proper styling\n\n6. **Button Variants Test**: Test all four button variants (primary, secondary, icon, danger) produce correct color configurations.\n\n7. **Helper Function Test**: Verify createPageTitle, createSectionTitle, and createBodyText call createText with correct style presets.",
        "status": "done",
        "dependencies": [
          "40"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up ui-components.js file structure and imports",
            "description": "Create the utils/ui-components.js file with proper imports from design tokens and module export structure",
            "dependencies": [],
            "details": "Create new file at utils/ui-components.js. Import TOKENS from ../utils/design-tokens.js. Set up ES module export structure to export all factory functions. Include any necessary helper functions like getFontSize if not already imported.",
            "status": "done",
            "testStrategy": "Verify file compiles without syntax errors and TOKENS imports correctly",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T00:04:41.559Z"
          },
          {
            "id": 2,
            "title": "Implement basic shape widget factories",
            "description": "Implement createBackground, createCard, and createDivider functions for simple FILL_RECT widgets",
            "dependencies": [
              1
            ],
            "details": "Create three factory functions: createBackground uses metrics.width/height for full-screen fill; createCard creates rounded containers with configurable radiusRatio defaulting to 0.07; createDivider creates horizontal or vertical lines based on bounds dimensions. All must use TOKENS colors as defaults.",
            "status": "done",
            "testStrategy": "Test each function creates correct hmUI.FILL_RECT widget with expected bounds and colors from TOKENS",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T00:04:42.908Z"
          },
          {
            "id": 3,
            "title": "Implement createText generic factory function",
            "description": "Implement the foundational text element factory with dynamic styling and alignment support",
            "dependencies": [
              1
            ],
            "details": "Create createText function accepting text (required), style (typography key), color, and align options (default CENTER_H). Use getFontSize(style, bounds.w) for responsive sizing. Default color to TOKENS.colors.text. Validate required text parameter and return created widget.",
            "status": "done",
            "testStrategy": "Verify text renders correctly with different styles, colors, alignments, and responsive sizing",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T00:04:44.254Z"
          },
          {
            "id": 4,
            "title": "Implement text helper wrapper functions",
            "description": "Implement createPageTitle, createSectionTitle, and createBodyText as convenience wrappers around createText",
            "dependencies": [
              3
            ],
            "details": "Create three helper functions: createPageTitle uses 'pageTitle' style with TOKENS.colors.text; createSectionTitle uses 'sectionTitle' style with TOKENS.colors.mutedText; createBodyText uses 'body' style with TOKENS.colors.text. Each wraps createText with predefined style and color values.",
            "status": "done",
            "testStrategy": "Test each helper produces correctly styled text elements matching their intended use case",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T00:04:45.654Z"
          },
          {
            "id": 5,
            "title": "Implement createButton factory with variant support",
            "description": "Implement unified button factory supporting primary, secondary, icon, and danger variants with press states",
            "dependencies": [
              1
            ],
            "details": "Create createButton function requiring text and onClick options. Support variant types: primary (TOKENS.colors.primaryButton), secondary, icon (uses icon option with normal_src/press_src), danger. Each variant has press_color state. Handle disabled state with grayed appearance. Text size from getFontSize('buttonLarge', bounds.w). Radius from bounds.h * TOKENS.sizing.buttonRadiusRatio (default 0.2).",
            "status": "done",
            "testStrategy": "Test all button variants with correct colors, press states, disabled appearance, and icon rendering",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T00:04:46.987Z"
          }
        ],
        "updatedAt": "2026-02-26T00:04:46.987Z"
      },
      {
        "id": "45",
        "title": "Migrate Home Screen to New Layout System",
        "description": "Refactor page/index.js to use the new declarative layout system, replacing HOME_TOKENS and inline position calculations with design tokens, layout engine resolution, and reusable UI components.",
        "details": "Migrate the Home Screen (page/index.js) from the legacy token-based positioning system to the new layout architecture defined in the PRD. This task is part of Phase 4 of the migration plan.\n\n**Implementation Steps:**\n\n1. **Remove Legacy Dependencies:**\n   - Delete the HOME_TOKENS constant from page/index.js\n   - Remove all inline position calculations from renderHomeScreen()\n\n2. **Add New Imports:**\n   ```javascript\n   import { TOKENS, getFontSize } from '../utils/design-tokens.js';\n   import { getScreenMetrics } from '../utils/screen-utils.js';\n   import { resolveLayout } from '../utils/layout-engine.js';\n   import { createBackground, createButton, createText } from '../utils/ui-components.js';\n   ```\n\n3. **Define INDEX_LAYOUT Schema:**\n   - Create a layout schema with three sections: header, body, footer\n   - Header section: Contains logo and pageTitle elements\n   - Body section: Contains primaryButton and secondaryButton (conditional)\n   - Footer section: Contains settingsButton icon\n\n4. **Implement Layout Elements:**\n   - **logo**: TEXT element with style 'pageTitle', color TOKENS.colors.accent\n   - **pageTitle**: TEXT element with style 'pageTitle'\n   - **primaryButton**: BUTTON variant 'primary' for 'Start New Game'\n   - **secondaryButton**: BUTTON variant 'secondary' for 'Resume Game', visible only when hasSavedGame is true\n   - **settingsButton**: BUTTON variant 'icon' with icon='setting-icon.png'\n\n5. **Refactor renderHomeScreen():**\n   - Call getScreenMetrics() to obtain screen dimensions\n   - Use resolveLayout(INDEX_LAYOUT, metrics) to calculate positions\n   - Replace inline math with layout engine results\n   - Use createBackground(), createButton(), and createText() factory functions\n\n6. **Preserve Existing Functionality:**\n   - Maintain click handlers for Start New Game and Resume Game\n   - Keep the conditional display logic for Resume Game (based on hasSavedGame)\n   - Preserve settings icon navigation to Settings page\n   - Ensure all navigation logic remains intact\n\n7. **Reference Implementations:**\n   - Follow the pattern established in Task 34 for button sizing and placement\n   - Use design tokens from Task 40 for consistent styling\n   - Apply round-safe positioning from Task 41\n\n**Technical Considerations:**\n- The settings icon button was added in Task 34; ensure it's properly positioned in the footer section\n- The Resume Game button conditionality from Task 17 must be preserved\n- Visual appearance should match the current implementation exactly\n- All spacing and sizing should derive from TOKENS constants",
        "testStrategy": "1. **Build Verification:** Run npm run complete-check after migration to ensure no compilation errors\n\n2. **Visual QA:**\n   - Compare the migrated Home Screen with the current implementation side-by-side\n   - Verify logo position and accent color match exactly\n   - Confirm pageTitle text styling is unchanged\n   - Check that Start New Game button appears in the correct position with primary styling\n   - Verify Resume Game button appears (with saved data) and matches secondary button styling\n   - Confirm settings icon button is positioned in footer area\n   - Test on both round and square screen simulators\n\n3. **Functional Tests:**\n   - Tap 'Start New Game' and verify it clears storage and navigates to Game Screen\n   - With no saved data, verify only 'Start New Game' button is visible\n   - With saved data, verify both 'Start New Game' and 'Resume Game' buttons appear\n   - Tap 'Resume Game' and verify it navigates to Game Screen without clearing state\n   - Tap settings icon and verify it navigates to Settings page\n   - Verify restored game state matches expected values when resuming\n\n4. **Regression Tests:**\n   - Complete a match, return to home, and verify 'Resume Game' button is hidden\n   - Test button tap responsiveness (should complete action within 100ms)\n   - Verify no console errors during page load and interaction",
        "status": "done",
        "dependencies": [
          "40",
          "41",
          "42",
          "44"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove Legacy Dependencies and Add New Imports",
            "description": "Delete HOME_TOKENS constant and inline position calculations, then import new layout system dependencies",
            "dependencies": [],
            "details": "Remove the HOME_TOKENS constant from page/index.js and delete all inline position calculations from renderHomeScreen(). Add new imports: TOKENS and getFontSize from '../utils/design-tokens.js', getScreenMetrics from '../utils/screen-utils.js', resolveLayout from '../utils/layout-engine.js', and createBackground, createButton, createText from '../utils/ui-components.js'.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-26T11:57:09.753Z"
          },
          {
            "id": 2,
            "title": "Define INDEX_LAYOUT Schema Structure",
            "description": "Create declarative layout schema with header, body, and footer sections",
            "dependencies": [
              1
            ],
            "details": "Define the INDEX_LAYOUT constant with three sections: header (contains logo and pageTitle elements), body (contains primaryButton and secondaryButton elements), and footer (contains settingsButton element). Follow the schema pattern established in reference implementations.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-26T11:57:24.990Z"
          },
          {
            "id": 3,
            "title": "Implement Layout Elements Configuration",
            "description": "Configure all UI elements with proper styles, variants, and design tokens",
            "dependencies": [
              2
            ],
            "details": "Implement logo as TEXT element with style 'pageTitle' and color TOKENS.colors.accent. pageTitle as TEXT element with style 'pageTitle'. primaryButton as BUTTON variant 'primary' for 'Start New Game'. secondaryButton as BUTTON variant 'secondary' for 'Resume Game' with conditional visibility based on hasSavedGame. settingsButton as BUTTON variant 'icon' with icon='setting-icon.png'.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-26T11:57:32.746Z"
          },
          {
            "id": 4,
            "title": "Refactor renderHomeScreen() Function",
            "description": "Replace inline math with layout engine resolution and UI component factories",
            "dependencies": [
              3
            ],
            "details": "Refactor renderHomeScreen() to call getScreenMetrics() for screen dimensions, use resolveLayout(INDEX_LAYOUT, metrics) to calculate positions, and replace all inline positioning math with layout engine results. Use createBackground(), createButton(), and createText() factory functions to build UI elements based on resolved layout positions.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-26T11:57:45.626Z"
          },
          {
            "id": 5,
            "title": "Preserve Functionality and Verify Visual Consistency",
            "description": "Maintain existing behavior, click handlers, and ensure visual appearance matches current implementation",
            "dependencies": [
              4
            ],
            "details": "Maintain all click handlers for Start New Game and Resume Game. Keep conditional display logic for Resume Game based on hasSavedGame. Preserve settings icon navigation to Settings page. Verify visual appearance matches current implementation exactly: logo position and accent color, pageTitle text styling, button sizing and placement following Task 34 patterns, spacing derived from TOKENS constants, and round-safe positioning from Task 41.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-26T11:57:51.466Z"
          }
        ],
        "updatedAt": "2026-02-26T11:57:51.466Z"
      },
      {
        "id": "46",
        "title": "Migrate Setup Screen to New Layout System",
        "description": "Refactor page/setup.js to use the new declarative layout system, replacing SETUP_TOKENS and inline position calculations with design tokens, layout engine resolution, and reusable UI components.",
        "details": "Migrate the Setup Screen (page/setup.js) from the legacy token-based positioning system to the new layout architecture defined in the PRD (Section 9: Migration Plan, Phase 5).\n\n**Implementation Steps:**\n\n1. **Remove Legacy Dependencies:**\n   - Delete the SETUP_TOKENS constant from page/setup.js\n   - Remove all inline position calculations from renderSetupScreen()\n\n2. **Add New Imports:**\n   ```javascript\n   import { TOKENS, getFontSize } from '../utils/design-tokens.js';\n   import { getScreenMetrics } from '../utils/screen-utils.js';\n   import { resolveLayout } from '../utils/layout-engine.js';\n   import {\n     createCard,\n     createSectionTitle,\n     createBodyText,\n     createButton\n   } from '../utils/ui-components.js';\n   ```\n\n3. **Define Layout Schema:**\n   ```javascript\n   const SETUP_LAYOUT = {\n     sections: {\n       header: { top: '5%', height: '10%' },\n       body: { top: 'header.bottom', bottom: '0%' }\n     }\n   };\n   ```\n\n4. **Refactor renderSetupScreen():**\n   - Get screen metrics using getScreenMetrics()\n   - Call resolveLayout(SETUP_LAYOUT, metrics) to get resolved bounds\n   - Create card container inside body section using createCard()\n   - Add title to card using createSectionTitle()\n   - Add helper text using createBodyText() with TOKENS.colors.mutedText\n   - Create 3 option buttons (1, 3, 5 sets) using createButton()\n     - Use variant 'secondary' for unselected, 'primary' for selected\n   - Create start button using createButton() variant 'primary'\n     - Apply disabled styling when no selection is made\n   - Add error message using createBodyText() with TOKENS.colors.danger (conditional)\n\n5. **Update State Management:**\n   - Maintain selectedOption state (1, 3, or 5)\n   - Pass selected state to button variant logic\n   - Pass disabled state to start button\n\n6. **Constants:**\n   - Define MATCH_SET_OPTIONS = [1, 3, 5] for option button generation\n\n**Layout Structure:**\n- Header section: Empty spacer (title moves inside card)\n- Body section: Contains the card element\n  - Card contains: title, helperText, 3 option buttons, start button, errorMessage\n- Footer: None (no footer buttons on this page)",
        "testStrategy": "1. **Build Verification:** Run npm run complete-check after migration to ensure no compilation errors\n\n2. **Visual QA:**\n   - Compare the migrated Setup Screen with the current implementation side-by-side\n   - Verify card styling (rounded corners, padding) matches exactly\n   - Confirm title, helper text, and buttons are positioned correctly\n   - Verify spacing between elements is consistent\n\n3. **Functional Tests:**\n   - Tap each option button (1, 3, 5 sets) and verify selected state changes button variant to 'primary'\n   - Verify only one option can be selected at a time\n   - Verify start button is disabled when no option is selected\n   - Verify start button becomes enabled after selecting an option\n   - Test error message display condition and styling\n\n4. **Cross-Device Validation:**\n   - Test on both round and square screen simulators\n   - Verify layout adapts correctly to different screen shapes\n\n5. **Regression Test:**\n   - Ensure all existing Setup Screen functionality is preserved\n   - Verify navigation and state management work as expected",
        "status": "done",
        "dependencies": [
          "40",
          "41",
          "42",
          "44"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove Legacy Dependencies from Setup Screen",
            "description": "Delete the legacy SETUP_TOKENS constant and remove all inline position calculations from the renderSetupScreen() function in page/setup.js",
            "dependencies": [],
            "details": "Locate and delete the SETUP_TOKENS constant definition from page/setup.js. Remove all inline position calculations (e.g., manual top/left/width/height calculations) from within the renderSetupScreen() function to prepare for the new layout system integration.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-26T13:49:34.235Z"
          },
          {
            "id": 2,
            "title": "Add New Layout System Imports",
            "description": "Import design tokens, screen utilities, layout engine, and reusable UI component functions at the top of page/setup.js",
            "dependencies": [
              1
            ],
            "details": "Add the following import statements at the top of page/setup.js: import { TOKENS, getFontSize } from '../utils/design-tokens.js'; import { getScreenMetrics } from '../utils/screen-utils.js'; import { resolveLayout } from '../utils/layout-engine.js'; import { createCard, createSectionTitle, createBodyText, createButton } from '../utils/ui-components.js';",
            "status": "done",
            "testStrategy": "Verify no compilation errors after adding imports using npm run complete-check",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T13:49:35.525Z"
          },
          {
            "id": 3,
            "title": "Define SETUP_LAYOUT Schema Constant",
            "description": "Create the SETUP_LAYOUT constant with declarative section definitions for header and body areas",
            "dependencies": [
              2
            ],
            "details": "Define the SETUP_LAYOUT constant object with a sections property containing header (top: '5%', height: '10%') and body (top: 'header.bottom', bottom: '0%') configurations. This schema will be used by the layout engine to calculate resolved bounds.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-26T13:49:36.816Z"
          },
          {
            "id": 4,
            "title": "Refactor renderSetupScreen() Function",
            "description": "Rewrite renderSetupScreen() to use the layout engine, screen metrics, and reusable UI components",
            "dependencies": [
              2,
              3
            ],
            "details": "Update renderSetupScreen() to call getScreenMetrics(), pass metrics to resolveLayout(SETUP_LAYOUT, metrics), use createCard() for the container, createSectionTitle() for the title, createBodyText() for helper text, createButton() for 3 option buttons (1, 3, 5 sets) with appropriate variants, and createButton() for the start button with disabled state handling. Add conditional error message using createBodyText() with TOKENS.colors.danger.",
            "status": "done",
            "testStrategy": "Run npm run complete-check to verify build, then perform visual QA comparing migrated screen with original implementation",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T13:49:38.094Z"
          },
          {
            "id": 5,
            "title": "Update State Management for Option Selection",
            "description": "Implement selectedOption state management and integrate with button variant and disabled state logic",
            "dependencies": [
              4
            ],
            "details": "Define MATCH_SET_OPTIONS = [1, 3, 5] constant. Maintain selectedOption state variable that tracks whether 1, 3, or 5 sets is selected. Pass the selected state to determine button variant logic ('primary' for selected, 'secondary' for unselected). Pass disabled state to the start button based on whether a selection has been made.",
            "status": "done",
            "testStrategy": "Test option button selection behavior, verify primary/secondary variant switching, and confirm start button enables/disables correctly",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T13:49:39.388Z"
          }
        ],
        "updatedAt": "2026-02-26T13:49:39.388Z"
      },
      {
        "id": "47",
        "title": "Migrate Game Screen to New Layout System",
        "description": "Refactor page/game.js to use the new declarative layout system, replacing GAME_TOKENS and complex inline position calculations with design tokens, layout engine resolution, and reusable UI components. This is the most complex page migration involving two-column layouts and dynamic match state handling.",
        "details": "Migrate the Game Screen (page/game.js) from the legacy token-based positioning system to the new layout architecture defined in the PRD (Section 9: Migration Plan, Phase 6). The Game Screen is the most complex page requiring special handling for round screens, two-column team layouts, and dynamic finished state UI.\n\n**Implementation Steps:**\n\n1. **Remove Legacy Dependencies:**\n   - Delete the GAME_TOKENS constant from page/game.js\n   - Remove calculateRoundSafeSideInset() and calculateRoundSafeSectionSideInset() functions (now in screen-utils.js)\n   - Remove all inline position calculations from renderGameScreen()\n\n2. **Add New Imports:**\n   ```javascript\n   import { TOKENS, getFontSize } from '../utils/design-tokens.js';\n   import { getScreenMetrics, calculateRoundSafeSideInset, calculateRoundSafeSectionSideInset } from '../utils/screen-utils.js';\n   import { resolveLayout, createTwoColumnLayout } from '../utils/layout-engine.js';\n   import { createBackground, createText, createButton, createDivider, createIcon } from '../utils/ui-components.js';\n   ```\n\n3. **Define GAME_LAYOUT Schema:**\n   ```javascript\n   const GAME_LAYOUT = {\n     sections: {\n       header: {\n         top: 'headerTop',\n         height: '11%',\n         roundSafeInset: true\n       },\n       scoreArea: {\n         after: 'header',\n         gap: 'headerToContent',\n         height: 'fill',\n         roundSafeInset: false\n       },\n       footer: {\n         bottom: 'footerBottom',\n         height: '15%'\n       }\n     },\n     elements: {\n       // Header elements: setsLabel, setsValue, gamesLabel, gamesValue\n       // Score area elements with two-column: teamALabel, teamAScore, teamAMinusButton, teamBLabel, teamBScore, teamBMinusButton, divider\n       // Footer element: homeButton\n     }\n   };\n   ```\n\n4. **Refactor renderGameScreen():**\n   - Get screen metrics using getScreenMetrics()\n   - Resolve layout using resolveLayout(GAME_LAYOUT, metrics)\n   - Use createTwoColumnLayout for the score area section\n   - Create UI elements using ui-components factories\n   - Apply scoreDisplay typography to score buttons using getFontSize('scoreDisplay')\n   - Handle isMatchFinished state to show finishedLabel + winner message instead of active game UI\n\n5. **Round Screen Handling:**\n   - Header section uses roundSafeInset: true (automatically applies calculateRoundSafeSectionSideInset)\n   - Score area uses roundSafeInset: false for full-width content\n   - Ensure divider positioning respects round screen geometry\n\n6. **Two-Column Score Area Pattern:**\n   ```javascript\n   const columns = createTwoColumnLayout({\n     left: { width: '45%', elements: [teamALabel, teamAScore, teamAMinusButton] },\n     right: { width: '45%', elements: [teamBLabel, teamBScore, teamBMinusButton] },\n     divider: { width: '10%' }\n   }, scoreAreaBounds);\n   ```\n\n7. **Button Handling:**\n   - teamAScore and teamBScore remain buttons for incrementing scores\n   - teamAMinusButton and teamBMinusButton for decrementing\n   - homeButton in footer uses icon factory\n   - Preserve all existing click handlers and event bindings\n\n8. **Dynamic UI State:**\n   - If isMatchFinished is true: render finishedLabel with winner message\n   - If isMatchFinished is false: render standard score UI with buttons\n   - Ensure UI state updates immediately when match state changes",
        "testStrategy": "1. **Build Verification:** Run npm run complete-check after migration to ensure no compilation errors.\n\n2. **Visual QA - Round Screen:**\n   - Test on round simulator, verify header elements (sets/games) are not cut off by screen edges\n   - Confirm two-column layout maintains proper spacing in the score area\n   - Verify divider is centered and visible\n\n3. **Visual QA - Square Screen:**\n   - Test on square simulator, verify layout fills available space appropriately\n   - Confirm header, score area, and footer proportions are correct\n\n4. **Functionality Verification:**\n   - Tap teamAScore/teamBScore buttons - verify score increments and UI updates\n   - Tap teamAMinusButton/teamBMinusButton buttons - verify score decrements\n   - Tap homeButton - verify navigation to home screen works\n   - Complete a match and verify isMatchFinished UI appears with winner message\n\n5. **Typography Verification:**\n   - Confirm score buttons use scoreDisplay typography (largest font)\n   - Verify sets/games labels use appropriate font sizes\n   - Check all text is readable and properly aligned\n\n6. **Round Screen Edge Cases:**\n   - Verify safe insets prevent header text clipping on smallest round screens\n   - Confirm footer home button icon is fully visible and tappable\n\n7. **State Preservation:**\n   - Navigate away and back to game screen - verify score state persists\n   - Resume a game - verify UI correctly displays saved state\n\n8. **Regression Test:**\n   - Compare visual appearance with pre-migration implementation\n   - Ensure all existing functionality (scoring, set tracking, match completion) works identically",
        "status": "done",
        "dependencies": [
          "40",
          "41",
          "42",
          "44"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove legacy dependencies and add new imports",
            "description": "Clean up legacy code and import new layout system utilities for the Game Screen migration.",
            "dependencies": [],
            "details": "Delete the GAME_TOKENS constant from page/game.js. Remove calculateRoundSafeSideInset() and calculateRoundSafeSectionSideInset() functions (now in screen-utils.js). Remove all inline position calculations from renderGameScreen(). Add new imports: TOKENS and getFontSize from design-tokens.js; getScreenMetrics, calculateRoundSafeSideInset, calculateRoundSafeSectionSideInset from screen-utils.js; resolveLayout, createTwoColumnLayout from layout-engine.js; createBackground, createText, createButton, createDivider, createIcon from ui-components.js.",
            "status": "done",
            "testStrategy": "Verify file compiles without errors after removing legacy code and adding new imports. Run npm run build to confirm no import errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T19:40:13.880Z"
          },
          {
            "id": 2,
            "title": "Define GAME_LAYOUT declarative schema",
            "description": "Create the layout schema defining sections and elements for the Game Screen using the new declarative format.",
            "dependencies": [
              1
            ],
            "details": "Define GAME_LAYOUT constant with sections object containing header (top: 'headerTop', height: '11%', roundSafeInset: true), scoreArea (after: 'header', gap: 'headerToContent', height: 'fill', roundSafeInset: false), and footer (bottom: 'footerBottom', height: '15%'). Define elements object with header elements (setsLabel, setsValue, gamesLabel, gamesValue), score area elements (teamALabel, teamAScore, teamAMinusButton, teamBLabel, teamBScore, teamBMinusButton, divider), and footer element (homeButton).",
            "status": "done",
            "testStrategy": "Verify GAME_LAYOUT schema structure is valid and contains all required sections and element definitions.",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T19:40:17.166Z"
          },
          {
            "id": 3,
            "title": "Refactor renderGameScreen() with layout resolution",
            "description": "Update the main render function to use the new layout engine and UI component factories.",
            "dependencies": [
              2
            ],
            "details": "Modify renderGameScreen() to get screen metrics using getScreenMetrics(). Resolve layout using resolveLayout(GAME_LAYOUT, metrics). Create background using createBackground factory. Create UI elements using ui-components factories (createText for labels, createButton for score buttons). Apply scoreDisplay typography to score buttons using getFontSize('scoreDisplay'). Create homeButton in footer using createIcon factory. Replace all inline positioning with layout-resolved bounds.",
            "status": "done",
            "testStrategy": "Test basic rendering on both rectangular and round screens. Verify all elements appear and are positioned correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T19:40:20.396Z"
          },
          {
            "id": 4,
            "title": "Implement two-column score area layout",
            "description": "Implement the two-column layout pattern for team scores with proper divider and element positioning.",
            "dependencies": [
              3
            ],
            "details": "Within the score area section, implement createTwoColumnLayout with configuration: left column (width: '45%', elements: [teamALabel, teamAScore, teamAMinusButton]), right column (width: '45%', elements: [teamBLabel, teamBScore, teamBMinusButton]), and divider (width: '10%'). Pass scoreAreaBounds from resolved layout. Ensure vertical stacking within each column and proper spacing between elements.",
            "status": "done",
            "testStrategy": "Verify two-column layout displays correctly with proper alignment, spacing, and divider positioning on both screen types.",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T19:40:23.873Z"
          },
          {
            "id": 5,
            "title": "Handle round screen geometry, dynamic state, and button events",
            "description": "Implement round-safe insets, match finished state handling, and preserve all interactive button functionality.",
            "dependencies": [
              4
            ],
            "details": "Ensure header section uses roundSafeInset: true (automatically applies calculateRoundSafeSectionSideInset). Verify score area uses roundSafeInset: false for full-width content. Handle isMatchFinished state: if true, render finishedLabel with winner message instead of active game UI; if false, render standard score UI with buttons. Preserve all existing click handlers for teamAScore, teamBScore (increment), teamAMinusButton, teamBMinusButton (decrement), and homeButton. Ensure UI state updates immediately when match state changes.",
            "status": "done",
            "testStrategy": "Run npm run complete-check to ensure no compilation errors. Test on round simulator verifying header elements are not cut off. Test both active and finished match states. Verify all buttons retain functionality and score updates work correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T19:40:27.861Z"
          }
        ],
        "updatedAt": "2026-02-26T19:40:27.861Z"
      },
      {
        "id": "48",
        "title": "Migrate Summary Screen to New Layout System",
        "description": "Refactor page/summary.js to use the new declarative layout system, replacing SUMMARY_TOKENS and inline position calculations with design tokens, layout engine resolution, and reusable UI components while maintaining scrollable set history functionality.",
        "details": "Migrate the Summary Screen (page/summary.js) from the legacy token-based positioning system to the new layout architecture defined in the PRD (Section 9: Migration Plan, Phase 7). This migration involves removing the SUMMARY_TOKENS constant, eliminating inline round screen calculation functions (calculateRoundSafeSideInset, calculateRoundSafeSectionSideInset), and implementing a declarative layout schema with header, body, and footer sections.\n\n**Implementation Steps:**\n\n1. **Remove Legacy Dependencies:**\n   - Delete the SUMMARY_TOKENS constant from page/summary.js\n   - Remove calculateRoundSafeSideInset() function\n   - Remove calculateRoundSafeSectionSideInset() function\n   - Remove all inline position calculations from renderSummaryScreen()\n\n2. **Add New Imports:**\n   ```javascript\n   import { TOKENS, getFontSize } from '../utils/design-tokens.js';\n   import { getScreenMetrics } from '../utils/screen-utils.js';\n   import { resolveLayout } from '../utils/layout-engine.js';\n   import { createBackground, createCard, createText, createButton } from '../utils/ui-components.js';\n   ```\n\n3. **Define SUMMARY_LAYOUT Schema:**\n   ```javascript\n   const SUMMARY_LAYOUT = {\n     sections: {\n       header: {\n         top: 'pageTop',\n         height: 'auto',\n         sideInset: 'roundSafe'\n       },\n       body: {\n         after: 'header',\n         height: 'fill'\n       },\n       footer: {\n         bottom: 'footerBottom',\n         height: '15%'\n       }\n     },\n     elements: {\n       headerCard: { section: 'header', type: 'card' },\n       title: { parent: 'headerCard', position: 'top' },\n       winnerText: { parent: 'headerCard', position: 'middleTop' },\n       finalScoreLabel: { parent: 'headerCard', position: 'middleBottom' },\n       finalScoreValue: { parent: 'headerCard', position: 'bottom' },\n       historyCard: { section: 'body', type: 'card' },\n       setHistoryTitle: { parent: 'historyCard', position: 'top' },\n       homeButton: { section: 'footer', type: 'button' }\n     }\n   };\n   ```\n\n4. **Refactor SCROLL_LIST Logic:**\n   - Keep SCROLL_LIST implementation in the page (not moved to utilities)\n   - Update scroll list styling to use design tokens:\n     - itemHeight: calculate based on typography.bodyLarge\n     - text_size: getFontSize('bodyLarge', width)\n     - color: TOKENS.colors.text\n   - Ensure scroll list is positioned within the historyCard bounds\n\n5. **Update renderSummaryScreen() Function:**\n   - Get screen metrics using getScreenMetrics()\n   - Resolve layout using resolveLayout(SUMMARY_LAYOUT, metrics)\n   - Create background using createBackground()\n   - Create header card with winner info and final score using createCard() and createText()\n   - Create history card container using createCard()\n   - Render setHistoryTitle using createText()\n   - Render SCROLL_LIST with token-based styling within historyCard bounds\n   - Create footer home button using createButton() with icon\n   - Apply round-safe side insets through layout engine\n\n6. **Handle Navigation:**\n   - Update homeButton click handler to navigate to page/index using the page router",
        "testStrategy": "1. **Build Verification:** Run npm run complete-check after migration to ensure no compilation errors.\n\n2. **Visual QA - Round Screen:**\n   - Test on round simulator, verify header elements (title, winner text, final score) are not cut off by screen edges\n   - Confirm round-safe side insets work correctly for both header and body sections\n   - Verify the history card maintains proper spacing from screen edges\n\n3. **Visual QA - Square Screen:**\n   - Test on square simulator, verify layout proportions are correct\n   - Confirm header, body, and footer sections are properly sized\n   - Verify home button is centered and properly positioned at bottom\n\n4. **Functional Testing - Scroll List:**\n   - Complete a multi-set match (at least 3 sets) and navigate to Summary Screen\n   - Verify all set results are displayed in the scrollable history list\n   - Test scrolling functionality - ensure all sets are accessible through scroll\n   - Verify text styling (size, color) matches design tokens\n\n5. **Functional Testing - Display Data:**\n   - Verify winnerText displays the correct winning team\n   - Verify final score shows the accurate set count (e.g., '2-1')\n   - Verify each set entry shows correct format (e.g., 'Set 1: 6-4')\n\n6. **Functional Testing - Navigation:**\n   - Tap home button and verify navigation to Home Screen works correctly\n   - Confirm no visual artifacts or layout shifts when navigating\n\n7. **Regression Testing:**\n   - Complete a match, view summary, return home, and start a new match\n   - Verify all match states reset correctly",
        "status": "cancelled",
        "dependencies": [
          "40",
          "41",
          "42",
          "44",
          "47"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-26T22:03:56.251Z"
      },
      {
        "id": "49",
        "title": "Migrate Summary Screen to New Layout System",
        "description": "Refactor page/summary.js to use the new declarative layout system, replacing SUMMARY_TOKENS and inline position calculations with design tokens, layout engine resolution, and reusable UI components while maintaining scrollable set history functionality.",
        "details": "Migrate the Summary Screen (page/summary.js) from the legacy token-based positioning system to the new layout architecture defined in the PRD (Section 9: Migration Plan, Phase 7). This migration involves removing the SUMMARY_TOKENS constant, eliminating inline round screen calculation functions (calculateRoundSafeSideInset, calculateRoundSafeSectionSideInset), and implementing a declarative layout schema with header, body, and footer sections.\n\n**Implementation Steps:**\n\n1. **Remove Legacy Dependencies:**\n   - Delete the SUMMARY_TOKENS constant from page/summary.js\n   - Remove all round screen calculation functions: calculateRoundSafeSideInset() and calculateRoundSafeSectionSideInset()\n   - Remove inline position calculations from renderSummaryScreen()\n\n2. **Add New Imports:**\n   ```javascript\n   import { TOKENS, getFontSize } from '../utils/design-tokens.js';\n   import { getScreenMetrics, getRoundSafeInsets, applyRoundSafeInset } from '../utils/screen-utils.js';\n   import { resolveLayout } from '../utils/layout-engine.js';\n   import { createCard, createButton, createText } from '../utils/ui-components.js';\n   import { createStandardPageLayout } from '../utils/layout-presets.js';\n   ```\n\n3. **Define SUMMARY_LAYOUT Schema:**\n   ```javascript\n   const SUMMARY_LAYOUT = {\n     sections: {\n       header: {\n         top: 'pageTop',\n         height: 'auto',\n         roundSafeInset: true\n       },\n       body: {\n         top: 'header.bottom',\n         bottom: 'footer.top',\n         roundSafeInset: true\n       },\n       footer: {\n         bottom: 'pageBottom',\n         height: TOKENS.typography.button * 2.5,\n         roundSafeInset: true\n       }\n     },\n     elements: {\n       headerCard: {\n         section: 'header',\n         top: 0,\n         height: '100%',\n         padding: TOKENS.spacing.md\n       },\n       titleText: {\n         section: 'header',\n         top: TOKENS.spacing.xs,\n         height: getFontSize('pageTitle')\n       },\n       winnerText: {\n         section: 'header',\n         top: 'titleText.bottom',\n         height: getFontSize('bodyLarge')\n       },\n       scoreText: {\n         section: 'header',\n         top: 'winnerText.bottom',\n         height: getFontSize('scoreDisplay')\n       },\n       historyCard: {\n         section: 'body',\n         top: 0,\n         height: '100%',\n         roundSafeInset: true\n       },\n       scrollList: {\n         section: 'body',\n         top: 0,\n         height: '100%'\n       },\n       homeButton: {\n         section: 'footer',\n         bottom: TOKENS.spacing.md,\n         height: TOKENS.typography.button,\n         width: 100\n       }\n     }\n   };\n   ```\n\n4. **Refactor renderSummaryScreen():**\n   - Get screen metrics: `const metrics = getScreenMetrics();`\n   - Resolve layout: `const layout = resolveLayout(SUMMARY_LAYOUT, metrics);`\n   - Create header section using createCard() with title, winnerText, and score elements\n   - Create body section with historyCard containing SCROLL_LIST for set history\n   - Keep existing SCROLL_LIST logic (params, callback for set items) but use layout bounds\n   - Create footer section with homeButton using createButton()\n   - Use TOKENS for all styling (colors, typography, spacing)\n   - Apply roundSafeInsets from layout engine for element positioning\n\n5. **Token Integration:**\n   - Replace all hardcoded colors with TOKENS.colors (text, accent, background, etc.)\n   - Replace font sizes with getFontSize() helper\n   - Replace spacing values with TOKENS.spacing values (xs, sm, md, lg)\n\n6. **Preserve Functionality:**\n   - Ensure winner text displays correctly from matchState\n   - Ensure final score displays correctly\n   - Ensure set history populates scroll list with all sets\n   - Ensure home button navigates to index page",
        "testStrategy": "1. **Build Verification:** Run npm run complete-check after migration to ensure no compilation errors.\n\n2. **Visual QA - Round Screen:**\n   - Test on round simulator, verify header elements (title, winner text, final score) are not cut off by screen edges\n   - Confirm round-safe side insets work correctly for header card\n   - Verify history card with scroll list respects round screen boundaries\n   - Ensure home button is positioned correctly at bottom with safe insets\n\n3. **Visual QA - Square Screen:**\n   - Test on square simulator, verify all elements are properly centered and spaced\n   - Confirm scroll list occupies appropriate body area\n   - Verify header and footer maintain consistent heights\n\n4. **Functional Testing:**\n   - Complete a match and verify summary screen displays correct winner\n   - Verify final score shows accurate set tally (e.g., '2-1')\n   - Verify scroll list contains all played sets with correct scores\n   - Verify scroll list is scrollable if many sets were played\n   - Tap home button and verify navigation to index screen works\n\n5. **Styling Verification:**\n   - Confirm typography uses correct token sizes (pageTitle, bodyLarge, scoreDisplay)\n   - Verify card styling (background, padding) matches design tokens\n   - Confirm button styling uses correct token colors",
        "status": "done",
        "dependencies": [
          "40",
          "41",
          "42",
          "43",
          "44",
          "47"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove Legacy Dependencies from Summary Screen",
            "description": "Delete SUMMARY_TOKENS constant and remove all legacy calculation functions from page/summary.js",
            "dependencies": [],
            "details": "Remove the SUMMARY_TOKENS constant, delete calculateRoundSafeSideInset() and calculateRoundSafeSectionSideInset() functions, and remove all inline position calculations from renderSummaryScreen() function to prepare for migration.",
            "status": "done",
            "testStrategy": "Verify the file still loads without errors after removal, expect some functional failures until new system is implemented",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T23:18:19.223Z"
          },
          {
            "id": 2,
            "title": "Add New Imports and Define SUMMARY_LAYOUT Schema",
            "description": "Import required utilities and define the declarative layout schema for the summary screen",
            "dependencies": [
              1
            ],
            "details": "Add imports for TOKENS, getFontSize, getScreenMetrics, getRoundSafeInsets, applyRoundSafeInset, resolveLayout, createCard, createButton, createText, and createStandardPageLayout. Define SUMMARY_LAYOUT constant with header, body, and footer sections with all element positions and roundSafeInset configurations.",
            "status": "done",
            "testStrategy": "Validate all imports resolve correctly and SUMMARY_LAYOUT object structure matches the schema defined in the PRD",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T23:18:19.227Z"
          },
          {
            "id": 3,
            "title": "Refactor Header Section with Layout Engine",
            "description": "Implement header section using createCard and createText components with resolved layout bounds",
            "dependencies": [
              2
            ],
            "details": "Use getScreenMetrics() and resolveLayout() to get layout coordinates. Create headerCard container, titleText, winnerText, and scoreText elements using createCard() and createText(). Replace hardcoded values with TOKENS for colors, typography, and spacing. Apply roundSafeInsets from layout engine for positioning.",
            "status": "done",
            "testStrategy": "Verify header displays title, winner name, and final score correctly with proper styling and positioning",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T23:18:19.230Z"
          },
          {
            "id": 4,
            "title": "Refactor Body Section with Scrollable Set History",
            "description": "Implement body section with history card and maintain scrollable set list functionality",
            "dependencies": [
              3
            ],
            "details": "Create body section with historyCard container and scrollList using layout bounds. Preserve existing SCROLL_LIST logic including params and callback for set items. Ensure scroll functionality works within the resolved layout bounds. Use TOKENS for all styling. Apply roundSafeInsets for element positioning in the body section.",
            "status": "done",
            "testStrategy": "Confirm set history populates correctly and scrolling works properly within the body bounds",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T23:18:19.233Z"
          },
          {
            "id": 5,
            "title": "Refactor Footer and Complete Token Integration",
            "description": "Implement footer with home button and finalize all token replacements across the screen",
            "dependencies": [
              4
            ],
            "details": "Create footer section with homeButton using createButton() positioned at the bottom. Replace all remaining hardcoded colors with TOKENS.colors, font sizes with getFontSize(), and spacing with TOKENS.spacing values. Ensure home button navigates to index page. Verify winner text displays from matchState and final score displays correctly.",
            "status": "done",
            "testStrategy": "Run npm run complete-check for build verification and test on round simulator to verify elements are not cut off by screen edges",
            "parentId": "undefined",
            "updatedAt": "2026-02-26T23:18:19.235Z"
          }
        ],
        "updatedAt": "2026-02-26T23:18:19.235Z"
      },
      {
        "id": "50",
        "title": "Migrate Settings, History, and History Detail Pages to New Layout System",
        "description": "Refactor page/settings.js, page/history.js, and page/history-detail.js to use the new declarative layout system, replacing page-specific TOKENS constants with design tokens, layout engine resolution, and reusable UI components while preserving scroll list functionality and navigation patterns.",
        "details": "Migrate three utility pages (settings, history, history-detail) from the legacy token-based positioning system to the new layout architecture defined in the PRD (Section 9: Migration Plan, Phase 8). These pages share similar patterns including scroll lists with icons, settings icon navigation, and go back icon navigation.\n\n**Implementation Steps:**\n\n1. **Remove Legacy Dependencies from each file:**\n   - Delete the SETTINGS_TOKENS constant from page/settings.js\n   - Delete the HISTORY_TOKENS constant from page/history.js\n   - Delete the HISTORY_DETAIL_TOKENS constant from page/history-detail.js\n   - Remove all inline position calculations from render functions\n\n2. **Add New Imports (for all three files):**\n   ```javascript\n   import { TOKENS, getFontSize } from '../utils/design-tokens.js';\n   import { getScreenMetrics } from '../utils/screen-utils.js';\n   import { resolveLayout } from '../utils/layout-engine.js';\n   import { createStandardPageLayout } from '../utils/layout-presets.js';\n   import { createBackground, createCard, createText, createButton } from '../utils/ui-components.js';\n   ```\n\n3. **Define Page Layout Schemas:**\n   - For settings.js and history.js: Create standard page layout with header (title), body (scroll list), footer (optional buttons)\n   - For history-detail.js: Create layout similar to summary page with header (title), body (detail content), footer (goBack button)\n   - Use createStandardPageLayout() with appropriate options for each page\n\n4. **Migrate Settings Page (page/settings.js):**\n   - Keep SCROLL_LIST logic but use TOKENS for styling (colors, typography, spacing)\n   - Migrate title to use createText() with TOKENS.typography.pageTitle\n   - Migrate goBack button to use createButton() with appropriate icon\n   - Preserve clear confirm mode for delete action behavior\n\n5. **Migrate History Page (page/history.js):**\n   - Keep SCROLL_LIST logic but use TOKENS for styling\n   - Migrate title to use createText() with TOKENS.typography.pageTitle\n   - Migrate goBack button to use createButton() with appropriate icon\n   - Preserve empty state message display logic\n\n6. **Migrate History Detail Page (page/history-detail.js):**\n   - Follow pattern similar to summary page migration\n   - Create layout with header/body/footer structure\n   - Use TOKENS for all text styling and positioning\n   - Preserve go back navigation functionality\n\n7. **Run Validation:**\n   - Execute `npm run complete-check` after each page migration to ensure no compilation errors\n   - Test on both round and square simulators",
        "testStrategy": "1. **Build Verification:** Run npm run complete-check after migrating each page to ensure no compilation errors.\n\n2. **Visual QA - Round Screen:**\n   - Test Settings page on round simulator: verify title, scroll list items, and goBack button are not cut off by screen edges\n   - Test History page on round simulator: verify title, history entries, and empty state message display correctly\n   - Test History Detail page on round simulator: verify all detail content and navigation elements are visible\n\n3. **Visual QA - Square Screen:**\n   - Verify all three pages render correctly on square simulator\n   - Confirm scroll lists maintain proper spacing and alignment\n   - Check that titles and buttons are properly positioned\n\n4. **Functional Testing - Settings Page:**\n   - Navigate to Settings page and verify all menu items display\n   - Test scroll list scrolling functionality\n   - Verify goBack button returns to previous screen\n   - Test clear confirm mode for delete action (confirm dialog appears and works)\n\n5. **Functional Testing - History Page:**\n   - Navigate to History page with existing matches\n   - Verify scroll list populates with match entries\n   - Test scrolling through history\n   - Verify empty state message displays when no history exists\n   - Test goBack button navigation\n\n6. **Functional Testing - History Detail Page:**\n   - Navigate to History Detail page from History list\n   - Verify all match details display correctly\n   - Test goBack button returns to History list\n\n7. **Regression Testing:**\n   - Verify visual appearance is unchanged compared to pre-migration implementation\n   - Confirm all existing functionality is preserved (navigation, scrolling, deletion, etc.)",
        "status": "done",
        "dependencies": [
          "40",
          "41",
          "42",
          "43",
          "44",
          "49"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Remove legacy dependencies and add new imports",
            "description": "Clean up legacy token constants from all three pages and add the new architecture imports",
            "dependencies": [],
            "details": "Delete SETTINGS_TOKENS from page/settings.js, HISTORY_TOKENS from page/history.js, and HISTORY_DETAIL_TOKENS from page/history-detail.js. Remove all inline position calculations from render functions in all three files. Add the following imports to all three files: import { TOKENS, getFontSize } from '../utils/design-tokens.js'; import { getScreenMetrics } from '../utils/screen-utils.js'; import { resolveLayout } from '../utils/layout-engine.js'; import { createStandardPageLayout } from '../utils/layout-presets.js'; import { createBackground, createCard, createText, createButton } from '../utils/ui-components.js';",
            "status": "done",
            "testStrategy": "Run npm run complete-check to verify imports resolve without errors",
            "updatedAt": "2026-02-27T01:03:42.748Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define page layout schemas for all three pages",
            "description": "Create declarative layout schemas for settings, history, and history-detail pages using the new system",
            "dependencies": [
              1
            ],
            "details": "For settings.js and history.js: create standard page layout with header (title), body (scroll list), and optional footer buttons using createStandardPageLayout(). For history-detail.js: create layout similar to summary page with header (title), body (detail content), and footer (goBack button). Pass appropriate options to createStandardPageLayout() for each page type. Ensure layouts account for scroll list functionality and round-safe positioning.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2026-02-27T01:15:34.776Z"
          },
          {
            "id": 3,
            "title": "Migrate Settings page to new layout system",
            "description": "Refactor page/settings.js to use design tokens and UI components while preserving scroll list functionality",
            "dependencies": [
              2
            ],
            "details": "Keep existing SCROLL_LIST logic but replace styling with TOKENS values (colors, typography, spacing). Migrate the page title to use createText() with TOKENS.typography.pageTitle. Migrate the goBack button to use createButton() with appropriate icon. Preserve the clear confirm mode for delete action behavior. Use resolveLayout() with the defined schema to generate final layout coordinates.",
            "status": "done",
            "testStrategy": "Test on round simulator: verify title, scroll list items, and goBack button are not cut off by screen edges",
            "parentId": "undefined",
            "updatedAt": "2026-02-27T09:41:02.317Z"
          },
          {
            "id": 4,
            "title": "Migrate History page to new layout system",
            "description": "Refactor page/history.js to use design tokens and UI components while preserving empty state logic",
            "dependencies": [
              3
            ],
            "details": "Keep existing SCROLL_LIST logic but replace styling with TOKENS values (colors, typography, spacing). Migrate the page title to use createText() with TOKENS.typography.pageTitle. Migrate the goBack button to use createButton() with appropriate icon. Preserve empty state message display logic. Use resolveLayout() with the defined schema to generate final layout coordinates.",
            "status": "done",
            "testStrategy": "Run npm run complete-check after migration to ensure no compilation errors",
            "parentId": "undefined",
            "updatedAt": "2026-02-27T09:46:36.265Z"
          },
          {
            "id": 5,
            "title": "Migrate History Detail page and run validation",
            "description": "Refactor page/history-detail.js following the summary page pattern and validate all three migrated pages",
            "dependencies": [
              4
            ],
            "details": "Follow the summary page migration pattern. Create layout with header/body/footer structure using createStandardPageLayout(). Use TOKENS for all text styling and positioning including TOKENS.typography.pageTitle for title. Preserve go back navigation functionality. Use resolveLayout() to generate final layout. Run npm run complete-check to verify all three pages compile without errors. Test on both round and square simulators to verify proper display and scroll functionality.",
            "status": "done",
            "testStrategy": "1. Build Verification: Run npm run complete-check to ensure no compilation errors\n2. Visual QA - Round Screen: Test all three pages on round simulator\n3. Visual QA - Square Screen: Test all three pages on square simulator",
            "parentId": "undefined",
            "updatedAt": "2026-02-27T09:52:00.063Z"
          }
        ],
        "updatedAt": "2026-02-27T09:52:00.063Z"
      },
      {
        "id": "51",
        "title": "Create UI System Documentation",
        "description": "Create comprehensive docs/UI-SYSTEM.md documenting the new layout system architecture, design tokens, layout schema syntax, component API reference, migration guide, and practical examples.",
        "details": "Create a new documentation file at docs/UI-SYSTEM.md that provides a complete guide to the new layout system. The documentation must be structured with the following sections:\n\n1. **Overview and Architecture**\n   - Layer diagram showing: Design Tokens  Layout Engine  UI Components  Pages\n   - Explanation of declarative vs imperative layout approach\n   - Round screen handling philosophy and why the new system was needed\n\n2. **Design Tokens Reference**\n   - Colors: background, text, mutedText, accent, danger, primaryButton, secondaryButton, disabled, divider (with actual hex values)\n   - Typography: pageTitle, sectionTitle, body, bodyLarge, score, scoreDisplay, caption, button, buttonLarge (with scale factors and semantic use cases)\n   - Spacing: pageTop, pageBottom, pageSide, sectionGap, cardPadding, elementGap (with scale factors)\n   - Sizing: cardHeight, buttonHeight, dividerHeight (with scale factors)\n   - Helper functions: getToken(), getSpacing(), getSizing()\n\n3. **Layout Schema Syntax**\n   - Section properties: top, bottom, height, after, roundSafeInset\n   - Element properties: x, y, width, height, alignX, alignY, reference\n   - Position resolution rules: percentage (relative to parent), pixel (absolute), reference-based (e.g., 'header.bottom + 10px')\n   - Code examples for common patterns (centered element, anchored to bottom, two-column layout)\n\n4. **Component API Reference**\n   Document all 8 factory functions from utils/ui-components.js:\n   - createBackground(widget, metrics, color?) - Creates full-screen background\n   - createCard(widget, bounds, options?) - Creates card with optional styling\n   - createDivider(widget, bounds, options?) - Creates horizontal divider line\n   - createButton(widget, bounds, text, options?) - Creates button with variants (primary, secondary, danger)\n   - createText(widget, bounds, text, style?) - Creates text with custom style\n   - createPageTitle(widget, bounds, text) - Creates page title with token styling\n   - createSectionTitle(widget, bounds, text) - Creates section title with token styling\n   - createBodyText(widget, bounds, text) - Creates body text with token styling\n   Include parameter types, default values, return values, and concise usage examples.\n\n5. **Migration Guide**\n   - Step-by-step process to migrate a legacy page:\n     1. Remove page-specific TOKENS constants (e.g., GAME_TOKENS, SETTINGS_TOKENS)\n     2. Import design-tokens, layout-engine, ui-components\n     3. Define layout schema using section/element structure\n     4. Call resolveLayout() to get coordinates\n     5. Replace inline position calculations with resolved coordinates\n     6. Replace widget creation calls with component factory functions\n   - Common patterns with before/after code snippets:\n     - Page title setup (legacy TOKENS vs createPageTitle)\n     - Button layout (inline math vs schema + createButton)\n     - Card creation (manual rect vs createCard)\n     - Scroll list implementation (legacy vs new approach)\n\n6. **Examples**\n   Provide complete code examples referencing actual migrated pages:\n   - Simple page (page/index) - Home screen with title and two buttons\n   - Card-based page (page/setup) - Setup screen with multiple input cards\n   - Two-column page (page/game) - Game screen with Team A/Team B columns\n   - Scroll list page (page/settings or page/history) - Settings or history with scroll list\n\nReference docs/PRD-Refactor-Layout.md (Section 11), PRD Appendix A (Example Migrated Page), and PRD Appendix B (Token Migration Mapping) for additional context and ensure alignment with PRD requirements.",
        "testStrategy": "1. **Documentation Review**: Have a developer who was not involved in the layout system implementation review the documentation for clarity, completeness, and accuracy.\n\n2. **Follow the Guide**: Attempt to create a simple test page following only the documentation (not looking at the actual implementation files) to verify all steps are accurate and complete.\n\n3. **Cross-Reference Verification**: Ensure all design tokens listed match the TOKENS object in utils/design-tokens.js exactly (names, values, structure).\n\n4. **API Signature Verification**: Verify all component function signatures (parameters, optional params, return values) match the actual implementations in utils/ui-components.js.\n\n5. **Schema Syntax Validation**: Ensure layout schema examples and syntax descriptions match the format accepted by utils/layout-engine.js.\n\n6. **Example Code Compilation**: Copy and paste all code examples into a test environment to ensure they compile without errors and produce expected results.\n\n7. **PRD Compliance Checklist**: Verify all requirements from PRD Section 11 are covered (comprehensive guide, all tokens documented, schema syntax with examples, component API reference, migration guide, common pattern examples).\n\n8. **Migration Guide Validation**: Walk through the migration guide steps with a legacy page file to ensure each step is actionable and correct.",
        "status": "cancelled",
        "dependencies": [
          "50"
        ],
        "priority": "low",
        "subtasks": [],
        "updatedAt": "2026-03-01T15:15:33.568Z"
      },
      {
        "id": "52",
        "title": "Add coach-to-whistle two-tap manual finish flow with 3-second confirmation and tie-aware summary output",
        "description": "Implement a safe manual match finish flow from the Game screen using a 2-tap confirmation pattern with a 3-second timeout, while preserving set-level score context and updating summary to handle tied matches.",
        "details": "Use the docs/PRD-Finish-Match.md as the PRD for this task. Implement manual finish functionality in page/game.js:\n\n1. **Footer UI Updates:**\n   - Add confirm-finish icon button beside home button in footer\n   - Use coach-icon.png (gtr-3, gts-3 assets) as default icon\n   - Switch to whistle-icon.png on first tap\n   - Position icons side-by-side with proper spacing\n\n2. **Confirmation UX:**\n   - First tap on coach icon changes to whistle icon and displays toast prompt\n   - Start 3-second confirmation timer\n   - Second tap within window confirms finish and triggers match completion\n   - Auto-revert to coach icon after 3-second timeout if unconfirmed\n   - Ensure timer cleanup on navigation/destroy to prevent memory leaks\n\n3. **Manual Finish Logic:**\n   - Capture current match state for finishing\n   - Append current in-progress set games into setHistory as partial set snapshot\n   - Guard against duplicate appending of current set snapshot\n   - Determine winner from setsWon values only\n   - Handle tie scenario when setsWon.teamA equals setsWon.teamB\n   - Maintain existing finish pipeline: navigate to summary, persist finished state, save to history, hide resume button\n\n4. **Summary Tie Handling:**\n   - Add summary.tiedGame localization key to page/i18n/en-US.po, page/i18n/pt-BR.po, page/i18n/es-ES.po\n   - Update page/summary.js to display tie message when sets are equal\n   - Ensure set history displays completed sets plus final partial set snapshot\n\n5. **Implementation Considerations:**\n   - Use existing confirm-button interaction pattern from page/history-detail.js as reference\n   - Ensure normal scoring-based match completion behavior remains unchanged\n   - Handle edge cases: empty state, mid-game finish, partial set display",
        "testStrategy": "Update and extend tests in tests/game-screen-layout.test.js:\n- Assert footer shows exactly 2 icons (home + coach) in correct order\n- Assert default coach icon is displayed initially\n- Assert first tap on coach changes icon to whistle and shows toast\n- Assert second tap within 3-second window triggers finish transition to summary\n- Assert timeout after 3 seconds reverts icon to coach without finishing match\n- Assert timer is properly cleaned up on page navigation\n\nUpdate and extend tests in tests/summary-screen.test.js:\n- Assert summary.tiedGame message is displayed for tied finished matches (equal sets)\n- Assert winner message is displayed correctly for non-tied matches based on setsWon\n- Assert final partial set snapshot appears in set history lines\n- Assert set history includes all completed sets plus the in-progress set snapshot\n\nIntegration tests:\n- Complete manual finish flow and verify finished state is persisted\n- Verify history entry is created correctly with tie status\n- Verify home screen no longer shows resumable active game after manual finish\n\nRun npm run complete-check to verify all tests pass",
        "status": "done",
        "dependencies": [
          "7",
          "8",
          "12",
          "18"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Footer UI with Coach Icon Button",
            "description": "Add the coach icon button to the game screen footer beside the home button with proper positioning and asset references.",
            "dependencies": [],
            "details": "Implement footer UI updates in page/game.js: Add confirm-finish icon button beside home button in footer. Use coach-icon.png (gtr-3, gts-3 assets) as default icon. Position icons side-by-side with proper spacing.",
            "status": "done",
            "testStrategy": "Assert footer shows exactly 2 icons (home + coach) in correct order. Assert default coach icon is displayed initially on both gtr-3 and gts-3 screen sizes.",
            "parentId": "undefined",
            "updatedAt": "2026-03-01T15:54:59.849Z"
          },
          {
            "id": 2,
            "title": "Implement Two-Tap Confirmation with 3-Second Timer",
            "description": "Implement the two-tap confirmation UX pattern with icon switching, toast prompt, 3-second timeout, and proper timer cleanup.",
            "dependencies": [
              1
            ],
            "details": "Handle first tap on coach icon to switch to whistle-icon.png and display toast prompt. Start 3-second confirmation timer. Handle second tap within window to trigger match completion. Auto-revert to coach icon after 3-second timeout if unconfirmed. Ensure timer cleanup on navigation/destroy to prevent memory leaks.",
            "status": "done",
            "testStrategy": "Assert first tap on coach changes icon to whistle and shows toast. Assert second tap within 3-second window triggers finish. Assert icon reverts to coach after 3 seconds without second tap. Assert timer cleanup prevents memory leaks on page navigation.",
            "parentId": "undefined",
            "updatedAt": "2026-03-01T15:54:59.852Z"
          },
          {
            "id": 3,
            "title": "Implement Manual Match Finish State Capture",
            "description": "Capture and prepare match state for manual finish, including partial set snapshot and winner determination logic.",
            "dependencies": [
              2
            ],
            "details": "Capture current match state for finishing. Append current in-progress set games into setHistory as partial set snapshot. Guard against duplicate appending of current set snapshot. Determine winner from setsWon values only. Maintain existing finish pipeline: navigate to summary, persist finished state, save to history, hide resume button.",
            "status": "done",
            "testStrategy": "Test mid-game finish scenario and verify partial set is appended to setHistory. Verify duplicate guard prevents multiple appends. Verify winner determination uses setsWon values only.",
            "parentId": "undefined",
            "updatedAt": "2026-03-01T15:54:59.860Z"
          },
          {
            "id": 4,
            "title": "Implement Tie Scenario Handling in Finish Logic",
            "description": "Add logic to handle tied matches where both teams have equal sets won, ensuring proper state preservation and navigation.",
            "dependencies": [
              3
            ],
            "details": "Handle tie scenario when setsWon.teamA equals setsWon.teamB. Preserve set-level score context in tie scenarios. Ensure normal scoring-based match completion behavior remains unchanged. Handle edge cases: empty state, mid-game finish, partial set display.",
            "status": "done",
            "testStrategy": "Create test scenario with equal setsWon values. Verify tie state is properly handled. Verify normal completion flow works for non-tied matches. Test edge cases with empty and mid-game states.",
            "parentId": "undefined",
            "updatedAt": "2026-03-01T15:54:59.863Z"
          },
          {
            "id": 5,
            "title": "Add Summary Screen Tie Display and Localization",
            "description": "Add localization keys for tie messages and update the summary screen to display tie-aware content with partial set history.",
            "dependencies": [
              4
            ],
            "details": "Add summary.tiedGame localization key to page/i18n/en-US.po, page/i18n/pt-BR.po, page/i18n/es-ES.po. Update page/summary.js to display tie message when sets are equal. Ensure set history displays completed sets plus final partial set snapshot.",
            "status": "done",
            "testStrategy": "Verify localization keys exist in all three language files. Test summary screen displays tie message when sets are equal. Verify set history shows completed sets plus final partial set snapshot for finished matches.",
            "parentId": "undefined",
            "updatedAt": "2026-03-01T15:54:59.865Z"
          }
        ],
        "updatedAt": "2026-03-01T15:54:59.865Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-03-01T15:54:59.865Z",
      "taskCount": 52,
      "completedCount": 48,
      "tags": [
        "master"
      ]
    }
  }
}